{"info":{"type":"runner","start":"2022-02-18T02:19:01.009Z","_duration":19113,"cid":"0-16","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir27912_1795368451"},"goog:chromeOptions":{"debuggerAddress":"localhost:62448"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"06c09c8227dd3058dcfb865587f42946"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/problem_user","filename":"report.html","reportTitle":"Sauce Demo Report for problem_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js"],"sessionId":"06c09c8227dd3058dcfb865587f42946","isMultiremote":false,"instanceOptions":{"06c09c8227dd3058dcfb865587f42946":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/problem_user","filename":"report.html","reportTitle":"Sauce Demo Report for problem_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:19:20.122Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":19113,"start":"2022-02-18T02:19:01.010Z","end":"2022-02-18T02:19:20Z"},"title":"Sauce Demo Report for problem_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:19:01.019Z","_duration":18936,"tests":[{"type":"test","start":"2022-02-18T02:19:01.020Z","_duration":18912,"uid":"test-00-0","cid":"0-16","title":"TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c421102f-5b74-4b64-a459-283fc624d4a0"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/value","body":{"text":"problem_user"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/value","body":{"text":"problem_user"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"10c7af8c-552c-4234-87a0-45d065f3ed9f"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/value","body":{"text":"secret_sauce"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b7452d42-9dfe-4166-b0eb-a8de523cd792"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b7452d42-9dfe-4166-b0eb-a8de523cd792/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b7452d42-9dfe-4166-b0eb-a8de523cd792/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25c258d7-7f48-423b-b56a-7d23f1f2597f"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a065249d-9125-462e-a779-02b28068eb97"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a065249d-9125-462e-a779-02b28068eb97/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a065249d-9125-462e-a779-02b28068eb97/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25c258d7-7f48-423b-b56a-7d23f1f2597f"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69391942-fc51-4d10-9986-0876ced43d70"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/69391942-fc51-4d10-9986-0876ced43d70/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/69391942-fc51-4d10-9986-0876ced43d70/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a15e53bb-c109-49fd-a28c-e9ea5eac1701"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a15e53bb-c109-49fd-a28c-e9ea5eac1701/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a15e53bb-c109-49fd-a28c-e9ea5eac1701/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0fadc9f-ea88-442d-8376-7c14f9963666"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0fadc9f-ea88-442d-8376-7c14f9963666"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0fadc9f-ea88-442d-8376-7c14f9963666/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0fadc9f-ea88-442d-8376-7c14f9963666/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e0fadc9f-ea88-442d-8376-7c14f9963666"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2feee114-fabe-490d-8c2d-71d5cd167ca5"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2feee114-fabe-490d-8c2d-71d5cd167ca5/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2feee114-fabe-490d-8c2d-71d5cd167ca5/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fbc47a43-005a-4116-9e9d-5a1cabdf8877/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fbc47a43-005a-4116-9e9d-5a1cabdf8877/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e8b473a1-f02d-46d2-aa50-73b01a4e1abe"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/value","body":{"text":"problem_user"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/value","body":{"text":"problem_user"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07d3a54a-712a-41e3-bc12-1d8be5a7a794"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/value","body":{"text":"secret_sauce"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"047dc9a6-2a3c-4a1c-bd37-f6d3022bbb78"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/047dc9a6-2a3c-4a1c-bd37-f6d3022bbb78/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/047dc9a6-2a3c-4a1c-bd37-f6d3022bbb78/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"de27441a-6f30-40b6-afd1-6c6bc7b95423"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/de27441a-6f30-40b6-afd1-6c6bc7b95423/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/de27441a-6f30-40b6-afd1-6c6bc7b95423/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c92b2c5-3afb-43f8-ab25-fc4921f64735"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c92b2c5-3afb-43f8-ab25-fc4921f64735"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7c92b2c5-3afb-43f8-ab25-fc4921f64735/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7c92b2c5-3afb-43f8-ab25-fc4921f64735/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"7c92b2c5-3afb-43f8-ab25-fc4921f64735"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8fff7b54-f160-439e-81c2-68a9fad14757"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8fff7b54-f160-439e-81c2-68a9fad14757/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8fff7b54-f160-439e-81c2-68a9fad14757/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d00f09b9-edc3-433a-9a4f-be5c1830fbdd"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d00f09b9-edc3-433a-9a4f-be5c1830fbdd/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d00f09b9-edc3-433a-9a4f-be5c1830fbdd/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3e3eded6-1e9b-47f4-837c-684182ba2327"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3e3eded6-1e9b-47f4-837c-684182ba2327/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3e3eded6-1e9b-47f4-837c-684182ba2327/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"13ac9719-0e58-47ce-a373-12b3635c6899"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"13ac9719-0e58-47ce-a373-12b3635c6899"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/13ac9719-0e58-47ce-a373-12b3635c6899/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/13ac9719-0e58-47ce-a373-12b3635c6899/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"13ac9719-0e58-47ce-a373-12b3635c6899"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2b2fd731-49a9-4d52-94f7-a52ade906a98"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"faf1759e-4768-46e7-915d-cb29ec7cfce7"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c79d30fd-f981-4ed3-95ca-a61a005d0e22"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2b2fd731-49a9-4d52-94f7-a52ade906a98"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/value","body":{"text":"Jane"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"faf1759e-4768-46e7-915d-cb29ec7cfce7"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/value","body":{"text":"Doe"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c79d30fd-f981-4ed3-95ca-a61a005d0e22"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/value","body":{"text":"90210"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc07aaa0-7aba-4803-9955-9ee9f39e3d84"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc07aaa0-7aba-4803-9955-9ee9f39e3d84/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc07aaa0-7aba-4803-9955-9ee9f39e3d84/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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AAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgKLunT0AAAAAAABg28yaNavd1zls2LAkzkgAAAAAAAA2QUgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKCoe2cP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AACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAA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Z37BvXMs2N54iONvuFshluB9nxLsNYpjWNbP43jRef8YIufNJxMJffn7+xMWGsrVV8cTF3sV+/Z/ROWOKg4cOKgLmUdcCNMyVrM9uZbXC0so319HeYkNAKMpkhlpd3HXojRmfd3TrpmqsjoghLTvxw2ydiTJCxIo+LiO3RU1tKakEjGEiOIzc7h952MUn3D/PDQ2nae3JrJ721aK/1jHX8vL2Q1gDCHq71NZcmcG6bM8NeGz0d7cPGhPu3brwHmtXi55jjg9YIKIiIiIiIiIyPBq3MyJH1YQnLsO001zCLw8GkPv4YvFjH1/FR2/fYJTJe6qCeowZ82m6451jPvpQowxkRjiIs/MbdhP19Y1tBTVnVdogx3ijwxXdURQ6X0Y3YZRQWt6GpYVjxN2RzKGy0349WYFLGbsjR/S+WIubW7//VzOJBw8CcfDJQ0iw87P6XQO2yXhC9IXff3nspLfD9c2X3M4HHR1WTjZ0kJ9fQOf/V8jSf+YSMLV8cO+t4jIUI30/40iIiIiIiIj4fOrdLegiIg3U/92eFjWNZvNHp8tWbJkyOsUFhZ6fObzFQl9+fv7Exw8luDgyURNjOS69tmjHZKIiIiIiIiIiIiIyKgoLCwcUjLBWxIBfOyy5XNhMBiIiAgnIkK95kVERERERERERETk0jRYkmCw5/AtTiSIiIiIiIiIiIiIiIjnZMFQkgigRIKIiIiIiIiIiIiIyLde/6TBUJMIoESCiIiIiIiIiIiIiMgloTd5cC5JBFAiQURERERERERERETkknGuSQRQIkFERERERERERERERLxQIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDwKHKmNFqQvGqmtRERERERERERERETkAlFFgoiIiIiIiIiIiIiIePT/mayzK7yNhyUAAAAASUVORK5CYII="},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html","stack":"Error: CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html\n    at CheckoutStep2Page.ensureOnPage (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\checkoutstep2.page.js:20:19)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:61:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:19:19.932Z","errors":[{"name":"Error","message":"CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html","stack":"Error: CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html\n    at CheckoutStep2Page.ensureOnPage (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\checkoutstep2.page.js:20:19)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:61:9)","type":"Error"}],"error":{"name":"Error","message":"CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html","stack":"Error: CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html\n    at CheckoutStep2Page.ensureOnPage (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\checkoutstep2.page.js:20:19)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:61:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:19:01.020Z","_duration":18912,"uid":"test-00-0","cid":"0-16","title":"TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c421102f-5b74-4b64-a459-283fc624d4a0"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/value","body":{"text":"problem_user"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c421102f-5b74-4b64-a459-283fc624d4a0/value","body":{"text":"problem_user"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"10c7af8c-552c-4234-87a0-45d065f3ed9f"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/value","body":{"text":"secret_sauce"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/10c7af8c-552c-4234-87a0-45d065f3ed9f/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b7452d42-9dfe-4166-b0eb-a8de523cd792"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b7452d42-9dfe-4166-b0eb-a8de523cd792/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b7452d42-9dfe-4166-b0eb-a8de523cd792/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25c258d7-7f48-423b-b56a-7d23f1f2597f"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a065249d-9125-462e-a779-02b28068eb97"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a065249d-9125-462e-a779-02b28068eb97/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a065249d-9125-462e-a779-02b28068eb97/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25c258d7-7f48-423b-b56a-7d23f1f2597f"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25c258d7-7f48-423b-b56a-7d23f1f2597f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0df49919-65bc-4750-a2e9-2d30d1abe57c/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0df49919-65bc-4750-a2e9-2d30d1abe57c"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69391942-fc51-4d10-9986-0876ced43d70"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/69391942-fc51-4d10-9986-0876ced43d70/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/69391942-fc51-4d10-9986-0876ced43d70/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a15e53bb-c109-49fd-a28c-e9ea5eac1701"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a15e53bb-c109-49fd-a28c-e9ea5eac1701/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a15e53bb-c109-49fd-a28c-e9ea5eac1701/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0fadc9f-ea88-442d-8376-7c14f9963666"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0fadc9f-ea88-442d-8376-7c14f9963666"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0fadc9f-ea88-442d-8376-7c14f9963666/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0fadc9f-ea88-442d-8376-7c14f9963666/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e0fadc9f-ea88-442d-8376-7c14f9963666"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2feee114-fabe-490d-8c2d-71d5cd167ca5"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2feee114-fabe-490d-8c2d-71d5cd167ca5/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2feee114-fabe-490d-8c2d-71d5cd167ca5/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":false},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"fbc47a43-005a-4116-9e9d-5a1cabdf8877","ELEMENT":"fbc47a43-005a-4116-9e9d-5a1cabdf8877"}]},"result":{"value":true},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fbc47a43-005a-4116-9e9d-5a1cabdf8877/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fbc47a43-005a-4116-9e9d-5a1cabdf8877/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e8b473a1-f02d-46d2-aa50-73b01a4e1abe"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/value","body":{"text":"problem_user"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e8b473a1-f02d-46d2-aa50-73b01a4e1abe/value","body":{"text":"problem_user"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07d3a54a-712a-41e3-bc12-1d8be5a7a794"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/value","body":{"text":"secret_sauce"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07d3a54a-712a-41e3-bc12-1d8be5a7a794/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"047dc9a6-2a3c-4a1c-bd37-f6d3022bbb78"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/047dc9a6-2a3c-4a1c-bd37-f6d3022bbb78/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/047dc9a6-2a3c-4a1c-bd37-f6d3022bbb78/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"de27441a-6f30-40b6-afd1-6c6bc7b95423"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/de27441a-6f30-40b6-afd1-6c6bc7b95423/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/de27441a-6f30-40b6-afd1-6c6bc7b95423/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c92b2c5-3afb-43f8-ab25-fc4921f64735"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c92b2c5-3afb-43f8-ab25-fc4921f64735"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7c92b2c5-3afb-43f8-ab25-fc4921f64735/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7c92b2c5-3afb-43f8-ab25-fc4921f64735/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"7c92b2c5-3afb-43f8-ab25-fc4921f64735"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8fff7b54-f160-439e-81c2-68a9fad14757"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8fff7b54-f160-439e-81c2-68a9fad14757/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8fff7b54-f160-439e-81c2-68a9fad14757/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d00f09b9-edc3-433a-9a4f-be5c1830fbdd"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d00f09b9-edc3-433a-9a4f-be5c1830fbdd/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d00f09b9-edc3-433a-9a4f-be5c1830fbdd/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3e3eded6-1e9b-47f4-837c-684182ba2327"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3e3eded6-1e9b-47f4-837c-684182ba2327/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3e3eded6-1e9b-47f4-837c-684182ba2327/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"13ac9719-0e58-47ce-a373-12b3635c6899"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"13ac9719-0e58-47ce-a373-12b3635c6899"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/13ac9719-0e58-47ce-a373-12b3635c6899/text","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/13ac9719-0e58-47ce-a373-12b3635c6899/text","body":{},"result":{"value":"1"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"13ac9719-0e58-47ce-a373-12b3635c6899"}]},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2b2fd731-49a9-4d52-94f7-a52ade906a98"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"faf1759e-4768-46e7-915d-cb29ec7cfce7"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c79d30fd-f981-4ed3-95ca-a61a005d0e22"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2b2fd731-49a9-4d52-94f7-a52ade906a98"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/value","body":{"text":"Jane"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2b2fd731-49a9-4d52-94f7-a52ade906a98/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"faf1759e-4768-46e7-915d-cb29ec7cfce7"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/value","body":{"text":"Doe"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/faf1759e-4768-46e7-915d-cb29ec7cfce7/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c79d30fd-f981-4ed3-95ca-a61a005d0e22"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/clear","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/clear","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/value","body":{"text":"90210"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c79d30fd-f981-4ed3-95ca-a61a005d0e22/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc07aaa0-7aba-4803-9955-9ee9f39e3d84"}},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc07aaa0-7aba-4803-9955-9ee9f39e3d84/click","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc07aaa0-7aba-4803-9955-9ee9f39e3d84/click","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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AAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgKLunT0AAAAAAABg28yaNavd1zls2LAkzkgAAAAAAAA2QUgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKCoe2cP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AACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAA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Z37BvXMs2N54iONvuFshluB9nxLsNYpjWNbP43jRef8YIufNJxMJffn7+xMWGsrVV8cTF3sV+/Z/ROWOKg4cOKgLmUdcCNMyVrM9uZbXC0so319HeYkNAKMpkhlpd3HXojRmfd3TrpmqsjoghLTvxw2ydiTJCxIo+LiO3RU1tKakEjGEiOIzc7h952MUn3D/PDQ2nae3JrJ721aK/1jHX8vL2Q1gDCHq71NZcmcG6bM8NeGz0d7cPGhPu3brwHmtXi55jjg9YIKIiIiIiIiIyPBq3MyJH1YQnLsO001zCLw8GkPv4YvFjH1/FR2/fYJTJe6qCeowZ82m6451jPvpQowxkRjiIs/MbdhP19Y1tBTVnVdogx3ijwxXdURQ6X0Y3YZRQWt6GpYVjxN2RzKGy0349WYFLGbsjR/S+WIubW7//VzOJBw8CcfDJQ0iw87P6XQO2yXhC9IXff3nspLfD9c2X3M4HHR1WTjZ0kJ9fQOf/V8jSf+YSMLV8cO+t4jIUI30/40iIiIiIiIj4fOrdLegiIg3U/92eFjWNZvNHp8tWbJkyOsUFhZ6fObzFQl9+fv7Exw8luDgyURNjOS69tmjHZKIiIiIiIiIiIiIyKgoLCwcUjLBWxIBfOyy5XNhMBiIiAgnIkK95kVERERERERERETk0jRYkmCw5/AtTiSIiIiIiIiIiIiIiIjnZMFQkgigRIKIiIiIiIiIiIiIyLde/6TBUJMIoESCiIiIiIiIiIiIiMgloTd5cC5JBFAiQURERERERERERETkknGuSQRQIkFERERERERERERERLxQIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDxSIkFERERERERERERERDwKHKmNFqQvGqmtRERERERERERERETkAlFFgoiIiIiIiIiIiIiIePT/mayzK7yNhyUAAAAASUVORK5CYII="},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"06c09c8227dd3058dcfb865587f42946","cid":"0-16","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html","stack":"Error: CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html\n    at CheckoutStep2Page.ensureOnPage (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\checkoutstep2.page.js:20:19)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:61:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:19:19.932Z","errors":[{"name":"Error","message":"CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html","stack":"Error: CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html\n    at CheckoutStep2Page.ensureOnPage (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\checkoutstep2.page.js:20:19)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:61:9)","type":"Error"}],"error":{"name":"Error","message":"CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html","stack":"Error: CheckoutStep2Page.ensureOnPage: Not on correct page on page https://www.saucedemo.com/checkout-step-one.html\n    at CheckoutStep2Page.ensureOnPage (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\checkoutstep2.page.js:20:19)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:61:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-16","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T02:19:19.960Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\problem_user\\suite-0-0\\0-16\\report.html"}