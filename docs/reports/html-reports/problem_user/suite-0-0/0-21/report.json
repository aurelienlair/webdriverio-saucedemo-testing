{"info":{"type":"runner","start":"2022-02-18T02:19:24.606Z","_duration":19654,"cid":"0-21","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir27912_682006013"},"goog:chromeOptions":{"debuggerAddress":"localhost:62264"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/problem_user","filename":"report.html","reportTitle":"Sauce Demo Report for problem_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js"],"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","isMultiremote":false,"instanceOptions":{"aec0942da913946fe8bc2c1bbd25a0fe":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/problem_user","filename":"report.html","reportTitle":"Sauce Demo Report for problem_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:19:44.260Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":19654,"start":"2022-02-18T02:19:24.607Z","end":"2022-02-18T02:19:44Z"},"title":"Sauce Demo Report for problem_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:19:24.625Z","_duration":19417,"tests":[{"type":"test","start":"2022-02-18T02:19:24.627Z","_duration":19374,"uid":"test-00-0","cid":"0-21","title":"Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","fullTitle":"UserStory: Reset Cart State.Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05efb020-22ab-4408-af03-1294be8183fd"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/clear","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/clear","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/value","body":{"text":"problem_user"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/value","body":{"text":"problem_user"},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bc697674-2e11-48fb-8b81-10e66561facd"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/clear","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/clear","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/value","body":{"text":"secret_sauce"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4611d61b-1d23-4bf1-8b76-80d0cbac0593"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4611d61b-1d23-4bf1-8b76-80d0cbac0593/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4611d61b-1d23-4bf1-8b76-80d0cbac0593/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a348d2b4-9868-4a7a-ad0a-6e31aed83932"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a348d2b4-9868-4a7a-ad0a-6e31aed83932/text","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a348d2b4-9868-4a7a-ad0a-6e31aed83932/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c9f83e81-06d0-4a90-bbd3-a646480d138d"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c9f83e81-06d0-4a90-bbd3-a646480d138d/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c9f83e81-06d0-4a90-bbd3-a646480d138d/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b0d15826-4e72-4ef9-b98c-01fe0455a8a4"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b0d15826-4e72-4ef9-b98c-01fe0455a8a4/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b0d15826-4e72-4ef9-b98c-01fe0455a8a4/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3e985a4b-60b7-4c98-8b1e-ffd599da8624/text","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3e985a4b-60b7-4c98-8b1e-ffd599da8624/text","body":{},"result":{"value":"2"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e903fd46-d73e-4945-9de7-d649e2937241"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e903fd46-d73e-4945-9de7-d649e2937241/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e903fd46-d73e-4945-9de7-d649e2937241/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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uRNIeOA+7gHgCna+/GR/dBE7X5dTBO7/y4fGAYDHDt7LYwD/4NX8/OZyRtO8/K3cfsdN3PDGS6nGHx7hz7+TAxQv+0eXcbK7ql71C1wO0HyH+398kj8SERERERERERERETkDnjOBhMM/7gIB/+AiXvyUxsnTLV5wUX7zd0d4vPvssb99KL95xUvZfkpn9WMe/mF+9zMXn6DU0qT5he64h3j88Am2FRERERERERERERE5g4qzfQKny3BUAqisjrvdVN//MY/ByQUODu3nA3vv4P5jfnkp19/xEcYtGro0h83NlU/WD//mEOx8GkEIEREREREREREREZHT6DmTkXDKXn7xKWYfnBk/82IFEURERERERERERETk7HnOZCRsf8lLqXiA5vsP8TcBtp9kBsDhnzyS37xwgfNG+3rRS4GH4K8f4TDH6G2wbTe3LO3e9OF93Lbnwyxt+OxiLnkl8D343o+eRmbB0SO5RwPbOG988FnmTqaD9Ehsn8bGIiIiIiIiIiIiIiLH9tzJSLj0Mq4E4F4Ofv9kf/QIB7+xAsCOV7x03CR5+ysuYw7ge/fyzVPqUbDAz786Bw8e/M/3cbK7ar77Z3wLoHo1Oy4efTrL4gvzu7/5yZET7mPc50FERERERERERERE5BQ8dwIJvV9g11UlsMLSF+8+qUn75W8vceejAJdxza6JbIGXX83bXgJwH3fuf+SUTuuSXbu5BODgF/hPJxPgCIdY+qO7AZj7pdezcyKzImdKwPJf/fgE1/cI938nv9vxkouPu6WIiIiIiIiIiIiIyPE8dwIJlFz5T9/Bjgqab3+SD//xCQIAj+7nxn9zgGXgkv9pL7s31C+6iN2/tptF4OE//Nfc9u2V4+8rrHDw059j/7G+u/ga/vmeBeAId37sDr519Hg7WuHg7R/iU98Hql184G2Xbvh2nClx8Av8x4PTz2k9QHIRu161cPxzFxERERERERERERE5judQIAHYtpubb9zNIi33//6/5F0f38/9m5fuhyM8+LU7uP59d3B/A9Ur9/LhX73oKbua27mXW667lIojLP32dVx/6wHuP7yp70BoeezgEjdfdx0f/PJDNJS87K3v4KoNrRBKdu79CNe/soSf7OfGvTfwqW8eogkbd9U8eh93/psP8MGvHgEW2HPjXq6c3XRSL9/D9a8pgSMs3XwDNy89wGODiX2sPMLBL3+C93UBkrk3vIPdSkgQERERERERERERkVNgUkrpbJ/EUxzazwf23sH9J7Hpjutu5ZY9G5sYL/9giY/81uc42E2yV/PbOG8WCCs8fmiFBoCSl73pN/nIu1/N4nEaMx/+9uf40MeWeHA0Yd9bYPtiBTQ8/uiRbl9QbbuC93zwn7HnZzfP/nfCEe659UN8/E8PjY+/eOEiNTA8fIjDg5Pcz8oDfPbGf83nf3D8ZsqLr3s/t9yw6ySaTq83id5z8xe5fueJthcRERERERERERGRc8XRo7kMzsGDB0/7vnfuzBPGxWnf8zlg7mf38LEvXM3D9+zn8/sPcPCBQzx2FPLk/WVc+Y+v5lfesIuXLZ5oT7D4mrdz2xfezMPfvpv9+w9wz1/+mMcezc2Oq/lt7Nx5NVf98i52v3zb8XfkFrjy12/lK2+7j6WvLLHvGw/wN48e4nC3n5e96gqu2bOb3T+3jep4k/+zl/LOf/sZdv/FAT7/pSX+/K8P89jRdnw+L35F3s+enSc4HxERERERERERERGRk3BuZiSIiIiIiIiIiIiIiMgJPRMZCc+tHgkiIiIiIiIiIiIiInJaKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTFWf7BDa7Zs9bzvYpiIjIGbRv6Ytn+xRERERERERERORpUEaCiIiIiIiIiIiIiIhMpUCCiIiIiIiIiIiIiIhMdc6VNlLJCxERERERERERERGRc4cyEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZKribJ+AiIjI2fT440fO9imIiJyU885beMaPqf9HioiIiIicPmfjz/SnizISRERERERERERERERkKgUSRERERERERERERERkKpU2EhGR57Vnc1qhiDz3nUulhb72pf8day3GGGKMmASQADDGYIwBDDFASomUEjFGYvIANL5leXVA0waGPjBsAisrnr9fOcrKygrDgWfQNoSQaNda2rYlxkjbepqmwVrL+S9Y5B++/BJ+5pKLOW9+Huccrkh432ABg6OwjhACw2YNAGstKSWcsXjfsrKyQkppfM5t22Ktpdfr4ZxbP3fvaduWEAJFUWCLgrrfwxUGGwKklhQ8q2tHKVPEA5iSpvEUvR4+wmAwwDlHVVXYou7GKlEUBaurq5SuYNh6Fs97ASE5YoC5uTmKoqAoShYWFmh8y9rqkALDob8/xOEnjtC2Lc45fvJfH+fI0VX++tFDeBMYDNaoqoqLX3gBF56/SL8/S1FUhGZI0zTUdc1Mv8Z7z+LWebZu3cLCwgLGOCKGujdDObsFbIEJnuFwyGCwil9bpqgKvG+YrXsYY6h6M8QYWVtbI5LYsrA1PwPJAZZePUNR5zF1zhFTHk9jDEVR4GxJCAFrLd778dibwlHVM+PnKlkDkJ8rA2VZklL+LITATw79V/7yL/+SB37wQ3wMvPjFL2br1kWaxnP0yBOsHV1mfssWts5twSRYW13GDweYEDD9it6WrfQv2MbiBeezdb6irivmFi6m3LJAv6i6Z4Xu+X5mbZ2pn/FjioiIyOl3Lv2Z/lQokCAiIiIiIic0mkgdTcAbIMYI5Ml6yAEEWJ9wzf/OOKiQUiJgiAl8SAx9S/IB3/q8r5QwKR9jclLfWotzDmMMZVlSlG4cIBidQz6/SEqWRCCEsOEcRvPAxpjxBPbo3J1zFEX+q5H3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nHPOOeecc84555xzzjn3TZ5IcM4555xzzjnnnHPOOefcN3kiwTnnnHPOOeecc84555xz3+SJBOecc84555xzzjnnnHPOfZMnEpxzzjnnnHPOOeecc845902eSHDOOeecc84555xzzjnn3Dd5IsE555xzzjnnnHPOOeecc9/kiQTnnHPOOeecc84555xzzn2TJxKcc84555xzzjnnnHPOOfdNnkhwzjnnnHPOOeecc84559w3eSLBOeecc84555xzzjnnnHPf5IkE55xzzjnnnHPOOeecc859kycSnHPOOeecc84555xzzjn3TZ5IcM4555xzzjnnnHPOOefcN6W/9Ak455xzf0l/+tNPf+lTcM65X+WHHz78qx/T/zfSOeecc865fz5/if9P/8/FKxKcc84555xzzjnnnHPOOfdNnkhwzjnnnHPOOeecc84559w3eWsj55xzv2l/y2WFzrl/+/6aWgv9n//H/04IARFBVREDMABEBBEBBG1gZpgZqopaBWCrhS8vV7bSWGtj3RrPz5U/Pn/i+fmZ9Vq5lo3WjHIplFJQVUqpbNtGCIEff/+R/+0//yf+1//0H/jh3TtijMRk1LoRACGSQqS1xrpdAAghYGZECdRaeH5+xsyOcy6lEEJgWRZijLdzr5VSCq01UkqElJhPCzEJoTWwgrXKy+UT2ZQKIJltq6RloSpcr1dijEzTREjzuFdGSomXlxdyTKyl8vGH39Msog0eHx9JKZFS5sOHD2y1cHlZSQh/+OMf+Meff6KUQoyR//7f/sRPn174f//rH6jSuF4vTNPEf/i73/Hvf/zI6fRAShNtW9m2jXmeOZ9maq18fP+O9++f+PDhAyIRRZiXM/nhCUJCWmVdV67XF+rlC2lK1LrxMC+ICNNyRlW5XC4oxtOH930NWAQCy3wmzf2exhhR6/dTREgpEUOmtUYIgVrrce8lRab5fKwrCwLQ15VAzhmz/rPWGv/9D/+N//Jf/gv/1//9/1C18R//43/k/fuPbFvl008/c/n0hXdPT7x/fEIMLi9fqOsVaQ05TSxP7zn97t/x8Xc/8v7dxDxPPH74D+SnD5zSNNYKY33/63p/nv/Vj+mcc865f35/Tf+f/n+GJxKcc84555xz37UHUvcAvACqCvRgPfQEAtwCrv3vHEkFM6MhqEFtxloLVhu11P5ZZoj1Y9wH9UMI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"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:19:44.001Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:19:24.627Z","_duration":19374,"uid":"test-00-0","cid":"0-21","title":"Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","fullTitle":"UserStory: Reset Cart State.Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05efb020-22ab-4408-af03-1294be8183fd"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/clear","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/clear","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/value","body":{"text":"problem_user"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05efb020-22ab-4408-af03-1294be8183fd/value","body":{"text":"problem_user"},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bc697674-2e11-48fb-8b81-10e66561facd"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/clear","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/clear","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/value","body":{"text":"secret_sauce"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bc697674-2e11-48fb-8b81-10e66561facd/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4611d61b-1d23-4bf1-8b76-80d0cbac0593"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4611d61b-1d23-4bf1-8b76-80d0cbac0593/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4611d61b-1d23-4bf1-8b76-80d0cbac0593/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a348d2b4-9868-4a7a-ad0a-6e31aed83932"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a348d2b4-9868-4a7a-ad0a-6e31aed83932/text","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a348d2b4-9868-4a7a-ad0a-6e31aed83932/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c9f83e81-06d0-4a90-bbd3-a646480d138d"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c9f83e81-06d0-4a90-bbd3-a646480d138d/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c9f83e81-06d0-4a90-bbd3-a646480d138d/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b0d15826-4e72-4ef9-b98c-01fe0455a8a4"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b0d15826-4e72-4ef9-b98c-01fe0455a8a4/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b0d15826-4e72-4ef9-b98c-01fe0455a8a4/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3e985a4b-60b7-4c98-8b1e-ffd599da8624/text","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3e985a4b-60b7-4c98-8b1e-ffd599da8624/text","body":{},"result":{"value":"2"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e903fd46-d73e-4945-9de7-d649e2937241"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e903fd46-d73e-4945-9de7-d649e2937241/click","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e903fd46-d73e-4945-9de7-d649e2937241/click","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3e985a4b-60b7-4c98-8b1e-ffd599da8624"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":true},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c","ELEMENT":"b862a3ef-6b42-43fe-a5a4-e1073ceea43c"}]},"result":{"value":false},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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uRNIeOA+7gHgCna+/GR/dBE7X5dTBO7/y4fGAYDHDt7LYwD/4NX8/OZyRtO8/K3cfsdN3PDGS6nGHx7hz7+TAxQv+0eXcbK7ql71C1wO0HyH+398kj8SERERERERERERETkDnjOBhMM/7gIB/+AiXvyUxsnTLV5wUX7zd0d4vPvssb99KL95xUvZfkpn9WMe/mF+9zMXn6DU0qT5he64h3j88Am2FRERERERERERERE5g4qzfQKny3BUAqisjrvdVN//MY/ByQUODu3nA3vv4P5jfnkp19/xEcYtGro0h83NlU/WD//mEOx8GkEIEREREREREREREZHT6DmTkXDKXn7xKWYfnBk/82IFEURERERERERERETk7HnOZCRsf8lLqXiA5vsP8TcBtp9kBsDhnzyS37xwgfNG+3rRS4GH4K8f4TDH6G2wbTe3LO3e9OF93Lbnwyxt+OxiLnkl8D343o+eRmbB0SO5RwPbOG988FnmTqaD9Ehsn8bGIiIiIiIiIiIiIiLH9tzJSLj0Mq4E4F4Ofv9kf/QIB7+xAsCOV7x03CR5+ysuYw7ge/fyzVPqUbDAz786Bw8e/M/3cbK7ar77Z3wLoHo1Oy4efTrL4gvzu7/5yZET7mPc50FERERERERERERE5BQ8dwIJvV9g11UlsMLSF+8+qUn75W8vceejAJdxza6JbIGXX83bXgJwH3fuf+SUTuuSXbu5BODgF/hPJxPgCIdY+qO7AZj7pdezcyKzImdKwPJf/fgE1/cI938nv9vxkouPu6WIiIiIiIiIiIiIyPE8dwIJlFz5T9/Bjgqab3+SD//xCQIAj+7nxn9zgGXgkv9pL7s31C+6iN2/tptF4OE//Nfc9u2V4+8rrHDw059j/7G+u/ga/vmeBeAId37sDr519Hg7WuHg7R/iU98Hql184G2Xbvh2nClx8Av8x4PTz2k9QHIRu161cPxzFxERERERERERERE5judQIAHYtpubb9zNIi33//6/5F0f38/9m5fuhyM8+LU7uP59d3B/A9Ur9/LhX73oKbua27mXW667lIojLP32dVx/6wHuP7yp70BoeezgEjdfdx0f/PJDNJS87K3v4KoNrRBKdu79CNe/soSf7OfGvTfwqW8eogkbd9U8eh93/psP8MGvHgEW2HPjXq6c3XRSL9/D9a8pgSMs3XwDNy89wGODiX2sPMLBL3+C93UBkrk3vIPdSkgQERERERERERERkVNgUkrpbJ/EUxzazwf23sH9J7Hpjutu5ZY9G5sYL/9giY/81uc42E2yV/PbOG8WCCs8fmiFBoCSl73pN/nIu1/N4nEaMx/+9uf40MeWeHA0Yd9bYPtiBTQ8/uiRbl9QbbuC93zwn7HnZzfP/nfCEe659UN8/E8PjY+/eOEiNTA8fIjDg5Pcz8oDfPbGf83nf3D8ZsqLr3s/t9yw6ySaTq83id5z8xe5fueJthcRERERERERERGRc8XRo7kMzsGDB0/7vnfuzBPGxWnf8zlg7mf38LEvXM3D9+zn8/sPcPCBQzx2FPLk/WVc+Y+v5lfesIuXLZ5oT7D4mrdz2xfezMPfvpv9+w9wz1/+mMcezc2Oq/lt7Nx5NVf98i52v3zb8XfkFrjy12/lK2+7j6WvLLHvGw/wN48e4nC3n5e96gqu2bOb3T+3jep4k/+zl/LOf/sZdv/FAT7/pSX+/K8P89jRdnw+L35F3s+enSc4HxERERERERERERGRk3BuZiSIiIiIiIiIiIiIiMgJPRMZCc+tHgkiIiIiIiIiIiIiInJaKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTKZAgIiIiIiIiIiIiIiJTFWf7BDa7Zs9bzvYpiIjIGbRv6Ytn+xRERERERERERORpUEaCiIiIiIiIiIiIiIhMpUCCiIiIiIiIiIiIiIhMdc6VNlLJCxERERERERERERGRc4cyEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZCoFEkREREREREREREREZKribJ+AiIjI2fT440fO9imIiJyU885beMaPqf9HioiIiIicPmfjz/SnizISRERERERERERERERkKgUSRERERERERERERERkKpU2EhGR57Vnc1qhiDz3nUulhb72pf8day3GGGKMmASQADDGYIwBDDFASomUEjFGYvIANL5leXVA0waGPjBsAisrnr9fOcrKygrDgWfQNoSQaNda2rYlxkjbepqmwVrL+S9Y5B++/BJ+5pKLOW9+Huccrkh432ABg6OwjhACw2YNAGstKSWcsXjfsrKyQkppfM5t22Ktpdfr4ZxbP3fvaduWEAJFUWCLgrrfwxUGGwKklhQ8q2tHKVPEA5iSpvEUvR4+wmAwwDlHVVXYou7GKlEUBaurq5SuYNh6Fs97ASE5YoC5uTmKoqAoShYWFmh8y9rqkALDob8/xOEnjtC2Lc45fvJfH+fI0VX++tFDeBMYDNaoqoqLX3gBF56/SL8/S1FUhGZI0zTUdc1Mv8Z7z+LWebZu3cLCwgLGOCKGujdDObsFbIEJnuFwyGCwil9bpqgKvG+YrXsYY6h6M8QYWVtbI5LYsrA1PwPJAZZePUNR5zF1zhFTHk9jDEVR4GxJCAFrLd778dibwlHVM+PnKlkDkJ8rA2VZklL+LITATw79V/7yL/+SB37wQ3wMvPjFL2br1kWaxnP0yBOsHV1mfssWts5twSRYW13GDweYEDD9it6WrfQv2MbiBeezdb6irivmFi6m3LJAv6i6Z4Xu+X5mbZ2pn/FjioiIyOl3Lv2Z/lQokCAiIiIiIic0mkgdTcAbIMYI5Ml6yAEEWJ9wzf/OOKiQUiJgiAl8SAx9S/IB3/q8r5QwKR9jclLfWotzDmMMZVlSlG4cIBidQz6/SEqWRCCEsOEcRvPAxpjxBPbo3J1zFEX+q5H3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nHPOOeecc84555xzzjn3TZ5IcM4555xzzjnnnHPOOefcN3kiwTnnnHPOOeecc84555xz3+SJBOecc84555xzzjnnnHPOfZMnEpxzzjnnnHPOOeecc845902eSHDOOeecc84555xzzjnn3Dd5IsE555xzzjnnnHPOOeecc9/kiQTnnHPOOeecc84555xzzn2TJxKcc84555xzzjnnnHPOOfdNnkhwzjnnnHPOOeecc84559w3eSLBOeecc84555xzzjnnnHPf5IkE55xzzjnnnHPOOeecc859kycSnHPOOeecc84555xzzjn3TZ5IcM4555xzzjnnnHPOOefcN6W/9Ak455xzf0l/+tNPf+lTcM65X+WHHz78qx/T/zfSOeecc865fz5/if9P/8/FKxKcc84555xzzjnnnHPOOfdNnkhwzjnnnHPOOeecc84559w3eWsj55xzv2l/y2WFzrl/+/6aWgv9n//H/04IARFBVREDMABEBBEBBG1gZpgZqopaBWCrhS8vV7bSWGtj3RrPz5U/Pn/i+fmZ9Vq5lo3WjHIplFJQVUqpbNtGCIEff/+R/+0//yf+1//0H/jh3TtijMRk1LoRACGSQqS1xrpdAAghYGZECdRaeH5+xsyOcy6lEEJgWRZijLdzr5VSCq01UkqElJhPCzEJoTWwgrXKy+UT2ZQKIJltq6RloSpcr1dijEzTREjzuFdGSomXlxdyTKyl8vGH39Msog0eHx9JKZFS5sOHD2y1cHlZSQh/+OMf+Meff6KUQoyR//7f/sRPn174f//rH6jSuF4vTNPEf/i73/Hvf/zI6fRAShNtW9m2jXmeOZ9maq18fP+O9++f+PDhAyIRRZiXM/nhCUJCWmVdV67XF+rlC2lK1LrxMC+ICNNyRlW5XC4oxtOH930NWAQCy3wmzf2exhhR6/dTREgpEUOmtUYIgVrrce8lRab5fKwrCwLQ15VAzhmz/rPWGv/9D/+N//Jf/gv/1//9/1C18R//43/k/fuPbFvl008/c/n0hXdPT7x/fEIMLi9fqOsVaQ05TSxP7zn97t/x8Xc/8v7dxDxPPH74D+SnD5zSNNYKY33/63p/nv/Vj+mcc865f35/Tf+f/n+GJxKcc84555xz37UHUvcAvACqCvRgPfQEAtwCrv3vHEkFM6MhqEFtxloLVhu11P5ZZoj1Y9wH9UMIxBgREXLOpByPBMF+Dv38FLOA0WitvTqHPQ4sIkcAez/3GCMp9X8a1Vpf/Xz/fj8PkXHdpphqD3ZLIMdMbYYitGbUdjvvqkYe74d+TTlnRCITCaUHxbX1z96P11qjjffVcT3jzrKuVyT0a5tyRKui47Nba8d9qbUiQIyRnPNxDiJGawVQVA2TdCRYbNy3PWmU5wmw4x7ta6G1Rq2VkHryJsaIoMSYgdu1qCq11eO9Csh+78ZxEB3nlTBrY52lkaoa6y68DubvSYnHx0ceHs9crutxvNvz6tfQWsNa/7O1RhBIY53FGI/X9tdXGJ/hnHPOOec6TyQ455xzzjnnvutbO7L34OvboOv93/fAdlNo2oPsl7Wwlo1aK9YaVhXUEAlHIL0nFML4isxLZp4zKQVikiNYfn9Mk3YEuM3sSECoNURu1RK7PYkQQjjO08wIdz8XEeo4VmsNrRWsEjCCJESMmCaaKKEZVUERYl4IMVJrRc1IMY5AuZCnCYB0ysQ0Uer2OrA+jiUhEjJs23bc6xACpaz9nuTI4zJRXyrNevC+1vrq3uzXsN+Lfl1Q6opaRVtAYrg9ZxFKrcd7YhB0244kRYzxuE8AKSVUtScaDEAxGkZBTdEGzfp5yzgHU3uVzDFrx9fX1pjdXQeMqhgR5nnmxx9/5O9//jv++Mc/Umi8vLxQq7JtG601tm3jmWfEoJYNrZWcIgZIDMd5CJFAQK2MShqvCHDOOeec23kiwTnnnHPOOfer3Afg7dhh3wO7PQj+lcA+duwI7zvTjWttvJTCdStoVcQEa0pMkVZ78L+1vit9mqZjZ//5vJBzPALiPahsr5Icx07+8WXWd9K32gA7PncPHu+70VX1CI7XWkkhjDY6dlQwtNZQq7RSECp5BKEFUAmEmEgJWlPEIjFkggQM7cmDPBNCYFsbMSRSSsznE00Dkwa0tleVH6qK5EwKCbPLcd77uUxpYpkzyxyJ62gBNK5jF2MkmL66R3nq96/WQisVUyGFWwInxN5uaJom5tNCq9eRQCkwWjXtiZow7hN3511rb0UlCib9uYfpRIrTXdLp1harn/dI8IiC9ITS/ZoTuVUMmN0qJnLuLaD+l7/7e+q68aftwrqtlNKiWvUvAAAgAElEQVQo6wa1cTWjbYUoAUGxWglRSEFeJcKEUV2je1Lj9dpyzjnnnPst80SCc84555xz7le7JRDsFzvohYjxOplQtVG1sZZCa7BV2Dblcl37DIJaER2fMf4MwQBlWaa+637e5wv0QHoOkRhvu9JFAty18mmtHTMW9t3y/e89ubAnCOC2y31/3x5MNzOIYNoTCzHkMfNBsSAE2/v3JwIBkUytjWaC2dj1P5IUmQmJkTTNfYd/DkcCYzk9spa++/96vUKQUR0glFaZZcEMVG6tggDmKTHPM7U2zlMmhQhBjrkOqkqMkWWZ2C5Xmham2O9FngK1bYBRykYIkSinnhAY91AxYk5YVWoxtm0jSk+qrOtKSD3Bk1I6gvBNlZx7tUJpGzEH9o5Mewuh/dzCXTIA6O2O0PGzfW01DMMsEEJ/FiYZMx2vgZgTZznz448/8uXLF/70h39gXVculwtlrcwh0WqlmLJMJ4IYEQi5V5uUUb3S18dMwMAatDqO05/FLaHhiQXnnHPO/TZ5IsE555xzzjn3q7wNoh4zEHT/+eu2QdCD39dtYy2Va4W1KC/rC7WWI9hdQ++fX6ui9EB5niKPjyfOy0zOeeyyH78VJYpRrRFDBIRqhrVbRcE2WvHM8wxqx7kAx/yF/Zr2uQl7oH7//f3u/hACOlolRYFAREwJKRND7skFKtFAUiCEiDCqJ2ImTwt5OpPzDPSEiAIxT+SQCClStI3BzJnWDEICiZi1W8ui2nfKn89nTqcHyrVwejiTPr2wpMxl3SiV0YJICAGaluO+xLvB2KhhuqGaCSlDDGhbAY62TiEExPYkxq3iI6U+C+FotxQjeZ5JIY57Zpg2ZDxPmqJya4d0P5C7P5PcEwbShzXvr+nfKaK9WdL+zBQFG7MNsnB6euTD737kw+UzP6//yPOzcr1euaoRDGLq1Qs5TcwpkvKExP7P4bJdWC9CeZwxXXqFSSv9edxVWjjnnHPO/ZZ5IsE555xzzjn3XXslwjFYebQsup9n8DXa4LJuXLfKWpXrtXK5XGijNQ5ya8nTWsMEYhTO88wP7888Pp7HTIBGXTeiBMIIgotBlHF8681y9iqJOnr892PcqhngNjx5v663X3tbof0zjkG8QIwBCUIYu+fn6URIywjWC4ohIaOEHsCOkZwyaTkxLWemabndQ4GYEsEM1YnSCtN0IuYJk0rM6QjiH8OqWwM1zk+PLMvC5/QzD09PzP/4M8vLxIs9U5qiekuY7F+1FoiCaqCqEtSw2iAmQsqYCa2uxBTI+fRqyHVKCWvluGf391NSJOZeIbEnh5oWVCspzr+4z3B7HntVSR9sHY/P3K9Xwv5ewAwLAYg9CSJGCH0g9unhzIcfPvL7L58olxf+9KfG9XplXVfEYFkm3j0+kVIizZlpmiD1+1OvF0qAUh4xe0SsIa1hrdCSECQR/9n+S3LOOeec+9vkiQTnnHPOOefcr3bs4K8gCNjrYctfGxi8XgvXUrmUxvPzpQ/DLcqcJkrtLYfUKmLGNE2czxNP58zvPjzx7t0TtVau15UtwilHovTqg4Ago93+nlTQMachpXS0DwJ6OyThCIzvSQcdlQiMr32XvIggKkeQO4RAAFIIqPZkQQyBNE8EybS1kfKMEbAYMRPiCD/neSZNC8uyEPPElJd+jBgghuOebW1jns9AQEKvCKg6kgeMNkxjSPE8z6SUyDnz8TTx/uHMl+f1Lljfg/Q2WjmVUkYiQtmuV1rpcyBae2TKfaC1lg3DSHkihIUY4gj4J86Pj3z5/BMAFgQVkHGsFCMxpiNxEWMarZP2xNNIxIzqABFBgpBS7oF+EWJMtzVkt7ZVqMG+nkSICBjYeIb7fQkhcD6f+d3vfuDl5Qv/8A//dbQ4egaVo+VSmifyPBPnBYk9oaLbtVdubAWs3zNtBWsVs4xxS3g555xzzv1WeSLBOeecc845911vKw72hMIeBN+TB/vr7negX7fGy2Xl8+XK88uVy+UCFggjYLxtG61Vcl54elx4/zDz/v2Jj+9OPDzMqGZegqBz5t3DzJTycYy9Nc7bZMY03Qb7hhgResBbRI62R/c7/ffzf9v26P66UkoY7Xhd/30PiqsqJiAx9iRAzCRktAHqAf8QAiln4jIhqsQ09fZF41rmZSWmmVbKmBPREzG1VmKMpNRfG8fAYxuJl5AmTvPClHJvFTVef71eeTidjmoSM6W2yud1pa2Fdw+Px3WllGitEmJkOT2gLfXrU2Fezly0kqcF03q0gbLR6imlxDRN/Wd7mysLt0qOMTj5fs3s93a/pv3zgFdVLkf1xqgseb3+bhUTANM08e7dO3744QOPj4+o/n997gXxlhyaEvnhRJqmY67Guq6sItSyobWRJkPLRksX4rK8Oq5zzjnn3G+VJxKcc84555xzv8rrQPCtxc19m6Bj8PLeYsiUrfZEwpfPLzxfXlhrAQvQ7NauB5iXzId3D3x8d+LD08LjaWGZ+k71aL1lztPpTBTpVQFvAv1HUsEghTja5XAMA75vabS/FjhaGN3PS9gD3HsQ/r7CoicS8i/uj5lhIRFGNUEYQ3r3ocQ9aD9hBGJKSJ4QubWLSvPS5y2YYK2Mc9VXiYsYY2+HNK4lxsh8PnN+eGKaPh33oQ+cboRzoo5rba2hrbI9X7FSSU8fsdGKCCCghPmhtzqyW/A/TZm4ZnKeqBuoVYL064njuvZ7KhJAeoXC7fncEkv393L//OPejd/fPxuRW8XGSDPc1uKRqOifkVLidDrx/sMT79/3r23bqFsfst1MCSkR54mYJmyrlLr1ao0gbGMAeG4TRqGuK+lBCd7XyDnnnHPOEwnOOeecc8657zMRlL45O5hBEEwN/cqA5eM9ZrRmY05C4Xnd+Hy59j76EjGDKCBiTHPg6WHi/ePMu4eJ85LJMZJCrxA4zTPLspCnfRByOxIaPVCtlLJhxi+SC6oKBqq36on7wcqllCNYfV+hcOxi31sPbRtNyy1BoYIaVLvNDjBrGH0wcw+oj2HEGE0rqpVWtFcoaKBZr57ojaLikXQo/UJIUZC5JzcIgqQxDJo+XyFOmWk58/DwMD6HMd9he7Wbf7+eVo11LaQQWc4nTBRE2cr1aJekDYLsrYVGMiVmJGZMymjVlJG7CLuqEiQRYqLRCKEcg5ZFDDVDrfZKBQk9kcToSzVIHNULdxUhakbckw/3sziOZIRyW35Kjonz+czf/7u/4/nThW2r/PzzZ5S+FkKKhBRRE5oppfWZHdmU58sL1+sL05IJZFpcb7MpZFRI/Jl5IM4555xz/5Z5IsE555xzzjn3XWEMpm2tISEAr9sa3Vcn3LcG0tYD0VstbLXyXCrWlCUJzTZOuc8aOM+Zd4+ZDw+Rx1mYUyTFW2ubnDPLsmAKEhSjAUIIEdO+237bNlTtdeC8tf4ZBq29rkoAjoTCq6TD+HkphWU+I6M1Timlz3K424GfUqKUcgyKFjOCNgKGjJZBiKG2QQNrGxD7sGqzPlMhBSSOCoNeOnEcI84zsSYu9kKK0y+qG+blTM6Zh6dHlmUCS5j1JMA+GyGlRNsKIn0mwFoq+XEiTr3dkomyXj7x8P4/9XuliowWT3uFQEgRkQgWWObzcc9aa+QQyGkG0pFsCGMw8zFIWeVVAue+fVG/573FkhBotR6/f9ty6kgQCSgN9soYA0GJAR7nd/z7v/t7ri8X/vsf/sj12pMqCoSQiEzU1ls0VVVe1itJGy8vL7xcV06lkIMQtGK1YDmjY3C2c84559xvlScSnHPOOeecc79C77EfJKAIcheMf9ve6F4PiI+gsym1KJjRpI2qBCPlyPk0ccqBnGCKqQdyYyQgR/A8SuiDbzFER8ucYKgapRRqrdTajqBzrfU4JzOOpMJ9O6VjqC+3NkYxxqPff389r67v/nr3BEZrjZgTomPyc89/9HMwMBlJh+uFkCeq9mB7iBmq0DQS0KM9UEo9CRBCoNFeHU8xRHrrpjwvI8gvRzum+wHRe/ujsjVi7L+v2isi5tNESBnoQ5/vZxTs7Z1qreQ8Y9bnSuQ8M88nYrKecBiB/RgCrRpIxcZ7+/1M2JiFEUIg3LWIijEiwQgE7O4Z3D8PHc9kvy4RYx9aIAbW9uenRIQggTAlPrx7x+9//3t+/+9+5OfPn6j19pz36gZVpdS1J4GAbdu4Xq9cr1ckBmJstFaIqgTvb+Scc8653zhPJDjnnHPOOed+FRFBfsXk2bdDkG+DiUe1gCqBxDJlcgyccmJJkRx7q6M9mJ9yJkg8/r5/RmsF0F59UI1a9Ajm78mDfcf8EZi+q5S43xH/NjFwGxAsR9Odvb1NCAG1WyVGCPGoYlBVwmi51L9XhLGLvhl1W2kpUdLGNC39WDET8gTSRmVFo7WAjHsAPRHRat/dr1b7oGiB0+MDc5AxJLm9uv8xxqNNUeQ2KPp+DkQaLZJCyqQ8k6elB/fT7Vnvcs6oKqfTCRuJmpwFa+0uIVNpWgkkMCWN99w/g31Hf281FY7v7wcyt9ZerbC3VS/9OfXAf/9ejjkKt+cSmOfM49OZ3/3uR/7w3/7Iy8v11fFbK5i1I8ExzzMxRrZt43K5IBESQiorsZ2Jko7jOeecc879FnkiwTnnnHPOOfdd9+2Kxk+++pq3w4zvW/HcVyvkHDnNC1mUOSem3FsZicgtkRAnQogjuH8LKqsqgR50bk0pY5ju2zZLe9uc/j4F7Aiq70mH+wHLbwcB7/q19AD1PoTYzEgpHtd4a6fUqx2iJcIefJYGbePaGjFP1OnUKwVyJqQJkUbOMxCwYJgpOfeBytu20tpGnwXQ5zRstfD+h4/9HKZ8tO65JQkSy7IwTRNxzAaY55lS+nyHEBnVC0aKE9M0k+eH2zyAUS2wB9lTnNAE6RSo2/V2f+/aRJk2TAtoJRCJcekzH+7u7f0g5eO+v5lDcV+RcP+6+3V1zE4YaS1Rw0KfMnHfCuvh4YGPHz/y/v3T0eoJenJGtbfH6vc6HzMmaq28vLwQImSEed1IS0VDbwPFV9aHc84559xvgScSnHPOOeecc9+17/Teg/PhTWIA0RE0H+1pgkHbKxLkaHWTciAQeVhOnHIihp5IyLEPJEYrFgRiD6TvwV8RjiD3HrA3642OFCPmRDMlk/sAaAEJgtaGaiPe7cbvn9ff2XfCG0XHLIFWRgA9IXHskB/JDREhpEiaMjFNxJz67AjZBxxXTJRtvXLKCQmGmoD2gcE//fQTp9OJdt3G8OREPi1MUyKKQJhH0LynacIYBB3FkDhaDplS13q0/ckjcH6c30jcPDw8cDrNfdh1KaR5Yq0reZ5ZlonlNPX2RdNEzCdizKx1DBfWDUhHUmJvj6TaW/2ICKU0UgSxRrB9t77SxtoAjlZLxj5fQIFxb4W+RnRUltBIIRKiILa/C4IIEsC4JSCgrxUJAhiGIRpA7qtghHmeOZ8XPnx83ys0QkZEqG1DaT0ZkRMnCTw+PjLPM8CoShDUhPXpSizrqMoItCjEsex96LJzzjnnfks8keCcc84555z7rq/t1j92/N/97FULGlFSUFIcyQeEKIGHeeK0zMxTYo6BGJWqSmlgkokxEtOExAjsO9nLrUWOCToqBJBAMjl20SOw1XK0G9rPJed8BMX3r333+n1LJLvb1Q7QtIzA9ImcJyKZ5XQmpJ7oEAMTYRvVDVn1tmteG3k6UasRQ2SKE0n63IGffvoJs8bjx4/k+YRaRLJxjifiqFjo93hUYEQgRRShNEUIhBCJMVPqC6WN14mNJIYSUiDmxDSfeP7yqScA6sbD4ztMBIsRi4kw9SQCWmnrMyKRapmQIrVszKnPoLCmSOitpWpRwtTvgbZCEENUaQphDiCRNoY+p6kng7TetWCy8Or5BBPQRogZtb1KwTBroBUkYkEIdqtOQe8SWbdHdqzXnCOPTwu///EH7P0+XyKwld4aSyQy5RnJcDqdmMZ5Qh/Sfb2+MH/5E9M0UXLGQgQTAm/aZjnnnHPO/QZ4IsE555xzzjn3XfcDcP+cvfXQMXMgQgqMXeZ9l/ppnlmmxJx6O6MQhaobrfVd8AQhhIgQf3HsfXbBbY7B60HJvf99e5UoiDEeX/ftl/Y/SylH+x3GYOUYx+71uvUd9JOQ0oQFIeaZlEYlAJCDjP3ygCrTNB3nnFKCYCQR8nwipISY8Pz8jGpFpok4fUbCxPwQe0IEEImY3dr43CdybskQ6QH71gP9Olo3TXMixv7aeZ6JYebL86fjM+bzCULsQ5QljtZOBWmVUntlhrEQSTRVokGrFUYVSK0V00prhlmABm1UUrTWyCK0vVKg6TFj4T7w3rQQALOGyGgRhfbEQa9hGBUnDdFelfBn//lqit1lE/ZqlvP5zO9//IhYYts2Pn3+0pMixyyOiTAqL/ZE0z4HobaN6+Vn5uuJNJ+RNJNC+hcdk+CJCeecc879tfJEgnPOOeecc+67wgjs9p3ct+HF+/dvqSpiEBBCEFLo359yZM6RFGS0wDFUK1UrpgJ8fU6BWQ8ThxCoKtgITCv7AOZ2JBJqrX3Q8BjYHGPv1X/f2qgHxLfRw7/vUL8/912z3kiHIIQYkWmCIPSaAAHrvflb22jNiASW+Tza7Agpz0hLxADnp/cAxKkR0oxZorY+92CthVMIWBuDm0MPqoeQMCloE1ozIGAm1Kpcr1di6n3917WMpyQsebq1kkqJFDM5zejcqK0wz3NvJRXA2korF6xs1HJFS+V0OqG1UrcwqgV0tHiKUOnnaJVadFSBREJtY+7A61kGrRVai+P9ICHQak/ckMYzMfrzjEawBmYEImoKprAnj9BepWLW1x/0GRB7Oy2hZ6x69yNSEE7zxNPTA2KBWjO1NaopOtaMSD+f2gqzTH3NpIDahhZFa6GVC+v6GYknEhHL01hL/9P/Wd0ZbZq+k6hzzjnnnPtL8USCc84555xz7lc7Wu5wG378teCnSB+EG0IgiBEQ5pwgMmYjQIxCqStmrfesvwvg3x/v2M3OrcWSqvad5TFh9ib4P9ocichRHSBvBjDvsw/2gcJob7tzPxBYVcECMSaM3iaIMWC4zy4IpL5VnlIK67oSR2ukRk9AxCmjJRBzZskLZatILTy8+0itW58tIdBnB4yKilqOaooQAjKSBaWU49xKKXz58oWYJkopbNt2DI2epmnMJOD48+npPSlGtu3KNE0sU9+hr9tGW1fEKtvzJ+pWmIKxqVG1cXo4oymirYFFhOk4vrR+f9MUepWCGSEnVHXUknS1VvRugHPTOgYdB0KYYFQyJE3onqi6e/6BnmzQpljoAyRCkO8G3fcBy6fzREBoLVNaJU6Z67pxuVwodWNdV/I8cT6fiTEyzxOlKrWWcf4bcnkhyhemmLCU/+xxnXPOOef+LfJEgnPOOeecc+6fzGgghtBnArwlIswpEyLE3rWIKUdSoFchjFY5Sv1F+569T75qHZ+mx+yDWiu1VkQCqhwJgdZqr4BIkZzTEZDviQ9DtY12Oj3oLtyGOMeoEANFGxOQQsZQ0pSPtkYSjGZGq5VmUA0kxeN8ypjHYGaEGAghEaIwTY+0AOSCrSvvfvgd2/rC5XKBu0HJEgNWG5Yago1h0HG0WaqEJKxf+rDmZsq6rlyvV7bt2u+QKiGPaox0++fe+Xym1o2YJ5ZlIUqvhNjWC+s1obVwefkMpXERQzGKNpY5ouVE2TZynjBJx3PaaiGkiBTBtN/TNE+3Z6+NGAKtVqxVxEayx6wP69ZK097GSVulaSAQCDH2lkbSqw3ukxLoPmR5tAG6H3wst8TCvn5yzizLhKC0Gnl8fCTmQrqu1Fa4rheu24Wl9kHLMUZChKCJEDIpzliDtl7Z5BN5npg59ZkOCN6KyDnnnHO/FZ5IcM4555xzzn3Xn9v9vQ8Wvv/7LoS+Kz+lRMp31QQGYkqpl74bPQkxJ2JOPfg+dv4bt+HIOgLRt0HEe1sjPSoXoM8FmOf51XDl3o9/7I5XRbX2djr0n1U1kipFC1UNE0hTJmDEGAihv44KIfVWPdaUUhoS4ct1ZV17xUCuo6XQEsfw5kRcJgKBmBYszbyryvX5Z0yFnPo1cz/EVw0tFat9936/7h5cv64rVRumfSd/a72aI0pApAfQQ8wjsdKD+TkvpJSY58w0TVgrlHXj+vJMtErdCi9fvhDpbaPm09TP3aCWFWuGRYFgx7PZqyCqFGLozzgYBANpFQVSjFjPFiD31SxAq4ZaIYRGALQWJMbeHmkkYYSIROltlWwMX347WXlfC3drYl+DIYSeUBntkJZTRlLEJHB9eeYZoxnoaLF1X2ETxlwNUaPVFVs/M5cnWlOSBCT05krOOeecc78FnkhwzjnnnHPOfdfe8/6rPzO9GwDcf7e3Noox9sG3aWbJCd2D34Bp4Xq9EEXIeR67wTMpjtY8th8D0Eq7aznUB+VGyj78d/wpIizzzDz62JdajiBza0otK9oKrVZEjWrKWgtNe1VCUcVCQoGYMynRd8CLUq4rZsZ0Wvprt8a2Va5lY90K17VRFfJknE7CQwhAIEQh5UyzRI4ZTZUHIlqN87whUyTEPtg4i6DWEwetNWrbgH5/x0Z8LmvjWhtJAtWUZv389oHBWCCkBPQqhrT0f/alHDifT73FkDXEjLJe+LxdKJcL67oxx4SWyrREYpoxjWipffC12hHDb62xbdsIuhvLtBDjA40+WFpahZhAIiJ9FsG+evakj6qhtSIpEVIEbeiYpRH2aw4ZQkDHDATVRkq3gcgy5mxAL0gIY9DzsQZFiDH3c4+NKQhBDG2wnTLPUzjW1J6UaU0BO9ZuX1tXQhBKWammJKyPY/CCBOecc879RngiwTnnnHPOOfdde/BeJIzgcW87xN1OcBEB3SsA5KgmCJKOmQWBPj+31JVSVtZtY86JKWfSPI0hyb0ioVXDVAm0owJgT1DsxzNVtLZjF3meJpapt6nRWnvc2wwJAVWjqVJqpdSKVqOZIhJ7xUEzrBmVjbU0FJhib1O0VUV0DBQOwrUWrtfKet348rxyrY3LutEkkrdIk8CHdgtoq0CKiZQyBTjzyLp8Bn2HWiXGPIYp99ffzzyAfo0ppZ5cqJXrZeM0z31WgfTBwzaC2mZGTnNv29T0+MwYI49PZ1rp1QKlFLRtYI3ry2cCAdSY54lpWgj5jIWImewdhECVtRSeny+U0jCJfR1sK+eHJ7CAWF8HIQp1KwTrbatCkFE1YrTS5w8E9goT7ckGbdDARoujKHH87q4Sxfq6ACBG4pih0K+9wdESyhAxUsgoPdkkJpCNuSqPDw9cHh84f37pCZnW2LYrEjIiRgwzqFDahoYGdaOVjVo2bCRqfp1/7tc555xzzv3r80SCc84555xz7rvuWxvtven33ej3v9srE95WL/RAcqDWHozvvf1faK1yXmaWZemDe9OtrRGitFZR6y2DtPa2OiH2z9uHD+9B8t0+1Hc/j1IKOWdUlW3bjnkGqlCtDzteayVJ6O2BQjwGKqccaWp8eS7IqLyIVSFGPn258PKy8XzZeiLhurGcH2jaeHqKGInaGjmn2z1IkQyUpqTlhERYX55vMxtG6yfV28DoPgeiVxzsMyLWdeXhdOr3W3pQ/fnL9fh9CIEYemJgv0cpJQyllXH9QK2Nur3Qu/T04cnnxydCWJC8EOKEtUaQhCKgyvPzM1spEFNvUdVgXk6E6UQY8yJ6ZUSj1YYEGwOx5age2deRjGqDt2tIVCE0jHTMQdhfsw/BPl4r8up3Jq+Hb+9Jp32YtYw5HTZNPJ4XzqfMtdReYUFDbWKeZ2Kgz5GoKyEaWKSs117VcjqhIzHmnHPOOfdb4IkE55xzzjnn3D/Z/WyC+/7yRyLhbrTCMR+hFLZtY137bvqUJk6n05FIeBUYtjEnwAxs73/fw7d7G5q9D/4+/2D/3X4+rbUjiLxtlda0JxGqYiJogKZGDPR5DiMpUUohlcjW4PPLRmtlBPQn5tMDn75s/PzpmbUYtSmX2jg9RSRCyjMika1Vkk1HIHtPDqzrynxaaFNkWy+gRjtmIfSKj/31Nlod7dewD5vehymr9WHULy/Xu/fTEw+jWiOEQM6Z2urxOSEELmVDt8Y89fZCp4czy/mExYl5PkPKiF57xYQptRZeXl7YmrJMS7+/NObzA2maiTH1KoQQoDXQOioaFIi0Uo9rOc51rIsgclS4mDU0KBIaMpIGWP8UVUXeDDo+5mhIvy72ZFYQggTM5EhQRRGIxpQjp3nicZkoaqzryrpVlvmRGDIx9PZNapWogBXKdqWUCyYfejLDiwicc8459xvhiQTnnHPOOefcd91mIBhpBPJ7YuC2473/fp+lMIbytnoEv82M2ja2slJKobXGNCVyzsxLTySEEJAYev5hPyZ9wG5vrdQDzaqKjiRGij1Qv+9237aNUsrx3kZDqlFab1HUWxxBaQ2JASESYyblifl07i2CRChN0ZcLW4t8vmyUrfaqgdR4aomXF+XTl5VqkPPMNAXePz2Rc+Th4YGYF9QExY5EQt+Fn5AYSNMMJjSFiFDrhlkP/Ke9FVQI1FoJKRJqbxiFKGKNlAI0PZImpZRehSCK0RgjGpAAMSdElet228EfY2RbKzFElmVhXhIPTw/kaaGGxHJ6omhDQ8UEytb48vLCZb1iQUh5HkOeleV0Js9Lr1SR/mz3mQ7WCq1BSoZYw0IfniwiFKtgECVSzZhiQqn9OkMfuIz2xIhhBIkjmXRLTN0nFGQM1u6v7/MW9vu4J5VE+hDpGIWcAg+nmQ3h8+dnni+fefd4q3gxM1IOgNB0Q7atr2XlazOff/V/S84555xzf2s8keCcc84555z7rj0Ie99CaG8rc19BcP/3Pdi7D7Et2v+8bzH0eD5xnntbozhPMGdMBBnH2z8zxgTaA8ZGr0QQicSxa39vVxRjfDUIOESOJMNW2lGdANCoBE2kEJnzwrIsnGFX9yoAACAASURBVB+euNSeiGibslWjmLKWypeXMnb3G9ftS78G69UP53Pk9PjAw+MPPDzOvH//joeHmZjAQsY09lkM0tsLxRhpKLmClo009SB8rZXWjCnfkjX7vW2tMcfALNKTOWrUWtAGqqC2sidwWqmw9DZPMadR2dATP0fliCrrtfLwkHl898BpEqbTQp6fCAIhn6G9QAxstXItV/74+ROqgDZyzqy1EGMmpoWYJrSV29owaKroeDbzPB+JoP2Z1rYdz2R/LqogtiJBkDwhjPUU0qs2RftxbvM75Bfrcv/Z66TDWKOiSISnxzNNAj/9/EeeX34G7c8hp5mHeQHLmEQUIWrpia7wL1OK4EkG55xzzv218kSCc84555xz7ruS7P3lDQs9SCx2C3zuFQfhzWyEPWCtqkcSYQ/6i8GyLHfzEXJPGBCo2sZAXSVIevV52hqqPWDe0xpCKfVIdPxingMcQ4r31kd1DE5WqxgR08L54Yk0L9Aaao3nLxcum0DOqAVKbdSqSIq06wYWMImEIJxOJ969e8eyLPzud79nWTLnZSIECBFiTLegtjGqKIxaQbRXBxCMsm6kfMKs74pvrYEKUfqg5SkmEsIUA61W1IwpzTzrFbShWplTxEYbojnPI/lzaz+lqgSEz8/PvX1TmjmfT+QEKU+QEjnFXtlgvfXUly8/sW4bP/38GZPM+8cFoVdGiPRnBuE2m2Kce6uFuhXqto7PSsQpH88mhIDVRsQQNUyMgNJK6cOf49ZbOMktUYCFV22eXj/rr6w/DDMB+nqx0WhpT3Yty8R8vTIFo9aNz58/8fz83FscffwBkYaSMPb5Dn2Q8zjqOI7y2v15/HI93s7NOeecc+5vgycSnHPOOeecc9+1t4Y5drPb65kIcOt3D78MmN739t/bGqUQyTmTcybkdJuPcL9rnrtd+WP3f9XG1hQhHu2U9l3p+7DmaZp6skLsOH6tlartGJosIdFPWWgNtlZZt421VC5r43lVXlZFipHnhYZRtCGlt1WKMZCmTDSO+Q5NC8syIdJnFKQUkGCkKcNo57PPLFDrVQLzwztSztB6W6Y8nY9z3qsy9kHL+879vcoixMg8z+NYiZiEaU5jUHXDkh0JHKMhAlYbtW68fPlCiDDPMzlnpmkmpKW3e8oLOipIcoxc15XLVvj5+QWRzDIlPn9+5loLT0+Rdb0gYqj2mRaS+/lprZRtgzEbA0CSoCFQikHrAfg9SQX9Gqsq2QxqhZR+ddD9virBRpLhyD+YHeH9/Tn0NkUFWuU8ZR5y5vlSeHm5sK3KnCday0xthph5UkH29JX806sSvnU9nlxwzjnn3F8rTyQ455xzzjnnvuu+ZVEPyPYg6r4D/e1r7//ce/jD3rqnB7ZDysQYCTkdgfjI3TFE0JGc6IHhHhS/1sq2bcRwm40AkHPunxHjUZnQtBzn2EYlg5mO4cMTpkLIE600aml8fn5mLY3ntbJqYKuF68uVdyEfLZq2UjidTv3cQ2BJ+dUg6X3Pe2/fE8fQ5DwGBEegt2DSGhEST+8+sJUrVo113Tid9dW9CghpBNP39jx7YiamxGmeOU0zyzSNpED/Z95+H2utaCuYKjHAWjfKuvZ7GAOn09yTL8sjIS+QAxYTKopqReKEKlzXjedrQQKcXjbM/pGijdPpgev12mcKUJjG/SjrioxzCHviIwQmTWjZaE0QMQJCK7Vflwg594oFrIFdgeXV2tKmxzO/b/3UEzRyq1I4ElGjguHN6/f1u21XglVOMfEwz1y2L2x147r2aoymJ85ixKTUtlck7Imz/4n/qJxzzjnn/oZ4IsE555xzzjn3XXtg36wH05HwKoALI3EQbj3wb27DllUrtW7EGJmmRMp9R32eJqaYiBJo0vrQYX3djqfUdgTGL9eNGJWUErXWPqg57oOab22L9nkJ67ayrusRiM/zRDOjGQQLmBhbbVyeLzRTritcilGtUlrhp8+fYASw13UlTpk45T7cN51oo33Nul64XC7MS37du98CEuKRBNgTHaqQTycu28rL5dLbGWmh1nDr9R8ChFsiJ6XEtm083s8ACD1gf56nca/bUUWiTWmt0FpFa29/tF4umFam+dQrGGIgxBnTACKEONHaS08ESGA+namfvmAI07Tw5Xrly/ML7z5+4OVSaO2PqCoPp8zT0xPbdaWVwpQSdduYpnRc+1auvS2UCVECKtITFncJKLMxF+FtxQuGih2vDaPNUa8w2VsYvZ6TcPxdf1kxo1ZpZaWuV6Ip51NmvvTkz/PLyufPn0eCI5DniEh61abqFxU5f8bbJMbXXu8VCc4555z7a+WJBOecc84559yvcgRm1TBu7Yf24Of9wNt7qoqgoPVICsTYKweS9GHJebTmAYMgBEClJxLaONbe5mdvU2REJCpVG/m+FZBxfN+2le1yYS31SGakODHlM9dakKA0iRTVXq0gUAlYhGRgGpmmmbLVY8ZCa43r9YVpmvqmd9GjGqGUlZ9//pkne2CKabQ5EmrbiGbEeNfySUBiRiI0U1SUINBar6KIIR9zBFprGIIGIaXAtWzHnIDr9Xqc1z5sutZx78Y9a6XSdL8HwlYraQyYztMZYh9yrSg5L6Q48XK9EPKZkBeWh3fk0wvv338kxIxulU+Xn3hoxk+fnqFVQhTKu0e2Cm0rLDlwmhMCxCbMcyaEXmmxz70wjBgn9vkK/Yf2evhyuWIhIzHSByWHoz1UGLMT7itjvlUh89a+FtdaWK8vAJzyxNMycZ0rtQjXWslVSUVJcyDlE3nMqXj7Wd/zP5J0cM4555z7a+OJBOecc84559x3vdotzmibQ/vFa17tAH8TwL1vcZRSIoVAHImElHo1glpjHKEHlkeiQltPJIQQxpDjcRy9Ha+OioWcRlC6VWrpLXxKbZgERAMpTcSYUTUkC9rguikWhZAyGoQpBVLqg5GDNGq5HD3+izbqpVdB5JCPJEKMkZeXZz59+kQKkEPk3bt3pEhv+5OMTHx1j/aWRXsbJNM+v6A143x+fJVIgICkjMTQP2/MAXj58oltK0cVgqqh49HsFRitNZo2dCRUalFimljOJ0gZSWeaCSFF4piT0DQwnU5YXsgPxnz6wsePDSzw5csL4UuibI2XyydKKZzOMyaJz59eEIyP7xaiKKc83QL/IVBKI6SxlmRPQMVXayWNllAmgpUNyXsFjCHR2Gcbv11j+/X+uTW8f6+qaOvP5rJemPNEjolzSrw7TZQW+OlSKWo9MRMm8vxAjIHwT+xpdN+2yznnnHPub4knEpxzzjnnnHO/yn0A1FR7lxgDsR4QBjmGF+/2QPjbyoWUbnMRcohM8dbXX7X2Xfm1ERHqCH6r9jkIMfbWQHurmBh7EHqfKYBFRIxmSqlQ1EAiBgRJhJAoTSHI/8/e28fYcZ1nnr9z6uve280mKZltzVimjZWZQDPUrDNiAAckoIAa2BC1csyMIpsr2yPHVpQEsqKBuaERDWiYWC1Cr4JxZO3EspyYI49A26MNnXhDIZ4VYQEkLEBkbEAKhDHNxYSiE6opsrvv7Vtf52v/OFXVt5vd/JAokZTqAS66bn2eOnVuV9X7vs/zEIiQvCjopymd3pg3K44SojBEG4OxAiEtYWFwLhvxHVD0+316SY9h1GnYGKZUZMMhWZIQBTlGWYSTaFsQdGUj22OMl+EJw5iiKBqTaK01RZlhDU0iASexxiCDgLgyVs7T3JtJS8ns7Gwj6VNX5jvnLQKCqqq/7p80TdHKYIwjCKDb7SKE96lARIgwBhEAEilDZMVUiJKEMI6YWLGKOI5J0xOMrZggL0vm5uYIopDIxKRZwVx/wDWrJigLDV3vd+CklwcSQuK5FY4wCAhEzWIRI9fUIGW1nfUMhGonOO/yjai2E0Kgna0ktRzWOUIhEE7iHMhqbCwO3o+yaVSuyLKs8nKIwFjGkghjJZZqvwZkEBPFiWfRILzhODWzYKFsEZybcVCvaxflExwO2ZIVWrRo0aJFixZXINpEQosWLVq0eEfjlQ+8Z+GM3jrEDRsI7txC747NrJx48459Zvd7GD4B3PIYq/58KysuyV6PcPIDH0W9oX3sYOznD3DN69gyP3GE/jN/g9p/GPvikWruJNy4Dvmvt5J8+nYmbpggXm4HJ/fxi033YwH5xz/hPXdOXnQbBk/fy8wX9wNbSA4+weR1r+NEWrRosSR8Ffd8lLNmCHiWwsJK6wVyM5V3gYXK5DgiiiI6nQ5xZRAcCOn18I0FY7EVe8FBYyxcy/Qs1NJ3CMF8RX9V+a51SVEoMmWwTmClxBGiHeTWILXDRhF5qZkdpt4foZ/S6cGqKPJV6nmOqBIPQgSN54GUkrI0DIdDdKEJKwmiTjdGStkYD+vKFNpaSRh4w+RavkcphTEGUXWnFAFBEFGYjKIoSOKu94lwftv6/DqdDnGng8gKjDGEFVvBGHeW8XVZlsg4wRhDHMcL2mSModAOGYVVyFtAGOAEFEoTR5YwjnBS4CrGhbWQJEnT/0mS0O/3KUpFIiRlqSkKRRx5c2bjfBLHFiWRhSDuEgoBImj6UQpZXd+KbSIsZVEgA0dIhyhOfLBdBogg9BJZUiJGDI/nk1XzCQI5wo4ZHb816gSUN4Uu6c8NKYqSKExwzpHECSuEpTAwLLznRthNvC9GNbblSJLmQqWKrlZJozd8f29xQZh/hoHoO7/gug2Xsw1X6nPU63/WXfBsOfLMebn6+m2Nkf7l3r/mvTtuvtwtanDlj/EWLa5cyPOv0qJFixYtWryDkB7FvbgX/aVP0d90F//0XB99mZqi+0eZemgPZy7T8S8K5jinHrqLU7/+UYrdj48EGQCm4OVD2Ke2k33kRl69Zw/T/cvW0guH6TPz9C5e/enlbkiLFlcORk2Va8+C0cDoYjPZel4QhgSVB4KUsmEixHHcfILae8FYnLVYXWn7G9N8GjmaKmBez1/s0eAZAyVZkZMXCqUdMkgI4gQXRKTKMiwVw1wx0x8yyAq0EWRFQZqXZFlBnpWkaU6WFk3QePSchRBkWUaapvT7fdI0bdoxGAxI09QnI7KMsiwXMDO8l4IP6i/s1wCtLFmWIQNQqmjOxzmHCAPiTkLcSQD8etU+GzZG1edlWTZSTPUxtNbN8etqfhmEEAQgBEEksQK00yAFuvKiAC9HZK2l0+kwHA5JkoQ4SijyEpAY48gzb2gthMBgKLUmLXKGRcGwKMlLhbYOEUaEYUwYxghRm07bRt7IurI5dyECHBIRhD6BULW7MUuuEjOjyaXF6ywew/W1CIIAKTw7ZDjMOD09Tb/fR2tNEAi6SUIShUgBCEvciQjjpY2WLwaj7JzF8684vB3v7y1atGhxudG+Z7S4StEyElq0aNGixTsavT3fW/Dd/sNL6Of2og8chfQQ+rOf5PQP/pp33/jWtis9sIvTDz4O6Q7Chy9my3V093yPaMlls6g/uRf1IsA24j1bl3kQmCS5mEOa40z93m9QHJjy31dvJvjYrYS/to4g9sfVzx1CfX8Pbho4+BBzv9XH7XuAa3oXc6C3EP0D/NOWL6BPThF9Z+flbk2LFlcILFAxDqogrcWh60ryCguCt1IgAkEU+0r6TqdDmedgvTdAGIbESUgUygWJAet8skC6eTaC1honvUlwqb0/AMIgqILPzFeha+vNhlVpvKwREAiJFCGFK8hLhUGTF5oiVxjj0IA1YC2kaUYYhpSlwmJwLsA4h7KGsiwBr8OvlEJYwXA4pNPpVGbMGpWVjKcpE6snyIoUGXTQWqKtgdJQFJ5NYK3FxrFvr7NoY5oEgGc9lIRhB2VVE/yvK/m1NWRZxuprrmkkkYxxTTKlLEs6nU5l6Fz3SQmA04ogECSVd4Hvw0piyFmcm9+Hs5puL6EoCs+icJrB0EsZOasJgoCkm5BlGUWhSDoxUvoEUFoqXKoZ6/YInEAbh7EQBRKHxAECbzTNCMOg/iul9Mkl4fz4sxqHraSNgiogb5CEQLAw0VXtexSjy2VAxYgIkCKkLDV5nlIUijCSCDtGIAVJFJFEAS4QhIlPgC1mNoz+vRh4xo07e96Vkk94O97fW7y9cNMDdL6w6YIrZOX7V76pzWnR4oLQvme0uIrRJhJatGjRosU7Gtdu2rhwxqaNcPd9pM8/yplP7sZxhPI/7Wf4tS2MvYXtMmdegfT1bDnBysXn1GCKqW/V02uJNm18XfJFizH84eNNkEF8+tusemgz48GilTZtgS/u4PQjnyR94ggc281w9830vryRziVowyhW3PkEK+58gztJZ7Enpy5Je1q0eLtgKaYB0FTB17JC83JDogl8J1HI+FiHsbEVlFmJKstGGz+KIiIZgHUYKoYBPnEQVLrzjbSRdRCFFIUPiMtG4qauaPdtqqvovapShBNgrEA5KJVBWcPcMGN6ZkgQRHSSLrbydgiFN14OjEHIGGcUWTbEiQCtNXme45yjl8RI52V56ir84XAITmKcIy1LUl1S6IJEC/IcelqjlKIocqiC9Vrrhk2QFymqzMC6yhBZkyQGnPPHkD7ZopSiyBVuzFUSPVGThImiGEHQMCecc0RRRFlWyQuncRgElrFOMiJH5SWSnJAI5/+Jl1pRFpooHiNNU8qyrJgX84yU8fFx4k5CWZZkWcl4LyIIAoqyRBtHXgrGxrsk3R5BHGFF5VmhFYIAJ30fShZ6GdQfay1CCqS1mDJDBKFnr4QWYcE6B9bipB+HdUDxXIbGQgikkEAIQUwcJxjtyFKF0pZrJjTCGoS0dOIuY1ajRUAUJo0c0lK/iQv53ZxvnSspkXCl3d9btDgL1/wSnU0bL5E8aIsWbxHa94wWVzFaaaMWLVq0aNFiCfQ+dA/JbdWXZw6RtlT9ZTDFcN8eP3n9TsaWCjLUCCa4dvtjJLdU35/6OrP/8Fa0sUWLFpcE1iEcCDcf+AxGjGwt/rNY6qg2Vu71evSSDp0kIYliuklEXMkbCSzOVHJGlbzRKFzFBrAG8rKgKDXCSiIZIxFIF+A0DXOhVIZSGWTgg9raOqZn5jj12jSzg5TBXEZelgyGGWWhUNbL/ki8T4FzjjwrG9kc5wRFUeCswBrvPZArXbEXcl+57xyD/pCiUAgRUBTeAyFNU7IsI88LsjRlMBj4fWKaREJjvGttxUIIUYUmTwvKshxZR+IL8iuJJ+On8zQjECFWG98fQjRSUHXAv05W1HJKUkqSJGn6F3xSSFga+aM6aZGnGXmaYa0lTXOklJWkEQ0TQylDEEQVk0GTZQVOSAIZEYYRTkhUaZgbpPSHKXmhqS9zGHp5K2MMpjLWds5V8lYWGVCxPWzlG1GPM588Mo1xsjemrpM09RhcDOccOM9QCYKIIOkQBCGFKkmLkkJ5DwmsZzwINDIQdKK4SiTUfgxv5AdV/UasW/C5coyW2/t7ixYtWrRo0WIh2kRCixYtWrRosSQmCK6vp6dwr4sd8E7AK9gD1eSH1tFdLshQI1jLxKfvq74cQP+krcZp0eJqQs0OaAxtpQTpJY7q5TXmGQkBYRjS7YT0OhGdTkwnDomikCgOCMN5X4P6U7McRk2WnXMY59DKNgHu0baUZUlR+MC7D76bJshcKsFgmHF6do7pMwPmBjlprptjKaUYDocURdFI+OiKPaCUqfarmjbVskRRJ8GMmExnWdawFrIsI89KBoMhwywjK3Lm5vpoVRAE84yB0YB/7cUQBMGC87HWEoaeTD7qF1FLGtX9UEsi1QkeUSUU8jxv2lyWJcPMJwWcWHhNrYWy0JVpcuXPYEXj/xAEAUopykKRpil5njMzM8Pp06ebZEqpFVmRgxQkSeQlmgpLmiuGhf+khaFUjkJZslyhnUYIg3M+0SGIcDaozlWd5YPQsFSQuEXsgFH5otG/oxhly8RxTKc7Rmd8BU5IsjwnHebeX6PMUGWKcJo4DIijaIGMV328N/JZ6je23LK3Fu39vUWLFi1atGixEK20UYsWLVq0aLEMXOOyPIk4h9ZvOX2U/tN7KP76EPblo37mdRuRt24l+fTtrLph4oJvuIOn72Xmi/tH5uxm+IHdDAHu/Wveu+Pmiz2NNxkJ9PAyTP/9VQo4r5RB55dvQjKJvXEdbnoKmFx+ZdNnZv9e0qf2Yg5XfXvDFoI7tzH28c2snDh7k/k+3EJy8Akmr5tfdmb3exg+ge/L7Ws4tesh8n0HIF2L2LSZ6H/9l+jf/98YrYVWn3gPrwCwg7GfP3BJ5KBatLhaMRq4h3nGQR3wB3C4JtjqJWQEQRDQiyPGezFzSQe0IRCCMAwJAsHiWG9dNe+D7d4M11mBFQ6D9AFvrYlji5S+XUopHD5Yrq1PRNRV8NpArmBumKOKkiAKsYEARBNcz7IMox1OAIGvpPceAQKVl6hKbsgYz4wQBHSShCzKwM23QWtNkZVEnYjBYA5pOr6SXSrCuSHdsS5SehmhMHC+x0bkm+I4bhIESinPUAhiOp0OeaHQ2qKV9UbB1Xp1wsCbBAfNsroPiyInCIJGhmk4zOjGCVU3NccW0hs4I2MQEXXdWZ7nI1JWrvITKLFacerUKbIip9MZRwhR+T+ETExMeJaB0uS5QhlvVuyc9zxQVpCVBlNmjPciwl6Msd6vIgxjnLMVS8QhTUBUsR2gCrZbSxiEjHorOMcCmsDigPyoKXed/AnjmE5vjLHxCWQYkc316Q/nmMjGiR0UBmQQEyeVOTML/RGWZTwsgaXnL9/ey4s37/4+PHaAuSf3o54/hDt2vJq7FnHTeuSWC7m/n/t+3Nzrz7WemeLMvu+QPfX/zhtIr74ZecvtRJ/YyqoNk8TLnaiZ4sy+feT/z99gDi7cNv7sNlbfeOHPfW8mXm8/L0Z58hDTj+xBPbffe2FUz7id39vGtdedY0PTZ3r/XrL/+1nM3x3yY6m3DvGvNxL+L7/J+Nabl2e5XEFIjx1g8OR+1LPP4k5W4/rGWwk/sZUVn9h4Qecwd3gfc9/Zj677EP/cGf7be5jYso7e+fbxNh6v+Ykj9J/+S9SzI+9RTMKN65CbttH9d1u55lzjjOoa/dle1POHF12jLfTuuLBxPgp94gBTn/0U5hjQ20z81Dd5901nO8hd9Ng4uY9fbLq/fc9ocVXjSri/tWjRokWLFlce0iOU/62a/vQWViz5AFow8/Qu5r64h7Ne+08ewj51iOypr5B/5jFWffHCXjSuPqwj3ArqKeDFrzD39ZuI7l1/7hei67bynp9vPf+uB4d59e6HKA8vqmo8th+zez/9b2yj2PcIk9cvvfk5oY8z9XufmzeQ5Dju4H7sv/2fX8fOWrR458Cb2Bqcs4jqex2gNqYyXRYjRrnMV4QHQtBNYsa6HXSeE4YhURISRsFZwd75CnmLcZ5VYAGtLFYKrABwGGd93LgK8iNcZdwLFukr643FiRjjoNSgDYgoxJr5ZIhSCmMtpVbY4ZAgjogTgSm9VNAwyyuWhGkkf2qWQBQmqCJjmKWskOMgvVdC3I05deo0q9//PtIiJ0kiVChZIccpisKfqwAhBUVeNMwI72eg0MYhAtkkKLrdrmcfOIcTEilD8jwnqTwbajZEEATEcUyUhBhnwMzLJymlGM5l5GVBGIZo6xM1nmWgiYMOw7yg2wnJisK7TyxibQiR4KQgz3MGg1nOzExjrSWIEwITUJYWAknS63rj4lAymJtjbGIMjGcChC7EyYC81MzNzlCqCGs7hE5itEPIECkhwuGMwRlDRC1JRGW27H0d5gP5AkaktbyRsWnMjB2uGZvWWXA+MRCGIXGnw/jECi/TpCzDNGeYZWi8/0SUJERBsESQf+nAvxULkwa1XNGl8lR4a/Am3N/Tl3j19++lPHh8iYXHcS8ex7y4n/7XNpL9xbe5bsPZgbtLgfSnjzP96V3YxWzT6SPY7x+h+P4upu78Nisf3syKReeb/2wvZ+7ejpleetv8+1/n5Mf/hJW7zt72LcMl7Gd38FGmdu1eyMytnnHTpx6l+PKTXHP3urOTTOkRTn78c6iXFz3DpUdxB4+iDu5hevc20tf7HPdWwPR57Y8/R/atQ4sWTMHLe9Ff2sv0V7cw/IvHlgwyA5Ae5dUdn6Z8ZvG1OI47uAd1cA+nv3Efwz/byZpl+uFtO17NcU7t3E7+3cX9C76Pp7AvH2L4xFfIH/kukx9be3YA0xzn1EP3kz99ZInt/TXq795MvkwiYCnoU4c4db4kwqUYGy1aXKVopY1atGjRokWLEeiiT//wXv7p459DnwB6W0l+Z2nDwMHTX2BQJxFWbyH64+8xcfBlrn3hx4x/4xHCGyeBKdy37mL6oQOeVXAedO/4E6594WVW7NxSzXmA7gsvc+0LL3Pt5680NgJAwqpP7KzqM6ewj3yE0x/6FP/41X2cPjZFbl7/nu3D91IeBnHHw3T2/ZhrX3iZ1X/7PeKPV2bS03spHtzL67Kv+Nb9FAdA3v9tf82e/Vs6O3bS/chvcM0LL3PtDx5pHpLCb1T9/8J9jL/+02nR4m2DUTNcmJeJGWUlLF4WVj4JnTim04mRSYSIQ5IkIZJhs15Tke0kWlkKZUYCw75C3dQa/1G4oBp81KDXOIdGUFqYHRa81p+jKBVhJJFhSKfTIYoiQhFiLZ6J4OaTInNzc8zMzDA3N0ehShDCSwINh410kdaGslRNFX6e51Viw59DmqbM9YdoA3ODDGtByoBClVXVvmlYBN7IWBOFCXlZkKYpw+GQJEkauaKy9J4EWeYllrxpsz9uLTlUyx8555MetS+CN25WOG1w1lIY602nlaJQilIbhkWBUv6ftggkaZr6bZVBlYbhXMZwzicg8qxkmHlmgzGOwmoGc3MgJYUySBFjjaTUjmFWUliLMhYZRD5wH8cEYYyxYEWEdSFF4UhLgzKassz9X+1ljYStWBv45IGUEunAWl2d6zxbZsE4Yp5tMRqgHx2nUkpkKFgx3qObdBBAoQ39uSFapQgUlovMCAAAIABJREFUkQyIpSAU8qz9L/5tLJb/eqNSR5cPl/r+PsXUg5+qgtuTiI8/Qre6t1/7wk+Y+M4TxHdU9/f0EGr7HqbfwDPEcsh/+ihn7qyCsr2NBDueYPxZf59fue8Jok1rAXBPf4rZr71EPrKtPrGP03fWQdm1yHsfY+ysbadw3/0Us48cWbDtW4dL2c/7Kb+4G5euRT5Y99OPGf+PO5GrAY5jvnQXZ55Z/CQ2xdSDVRKht5Hwy99u+vjaZ/+WzoPVM+70XorPPs7Mm3Cd3zgKzjzyyflA8Y3biL/xI1a/8DLXHvwRvS/f59nK0/sp7/4CUyeW2IU5ztSDd80nETbtIPnOj8/uh5cfJ//so5xZQkb17TteC8587f75JMKmnXS+U/XvCy+zct+3Se6t34WOY7Y/yvTiZAhTTP3eb8wnETbtINmzxDVKD/hrdPICmpUe4bVP3oU+JxPhDYyNNVva94wWVz1aRkKLFi1atHhH45UPvGf5hZt20vs/7+PaNUss+4e9zH5xn5++YQdj+x7gmkb+aILe5rVwy8b5Kpmnv8DsLc8xdtu5ubVhMkGYgGn21UWunuAcykqXHeGN97Hya8eZ/XyVVJk+gHnsAOljkNYU349uJN58K2Pvn6BzwRVPk8iH/4o1H187T9devZHxhzfwWvghsqem4Kf7yI5tY+KG19Hwz3yTax+8uUoSrad373o/P06g6FC/r4iJCXqrX8f+W7R4G2KBlMsiPwRgQcC2STZUfwMhiYKQpBN5+Z4gIO50GhmeOkBbo9b+H9231honHVSySH6Za9Zz4D0RrMNYy1xhGeSKtDJOljIgCCsDaARWSrS2KLuwkj3LMhBl4zUQyLgyTs7QWjVeCr6NPiA/WrmvlCLIBXpMMzeXEgSeFSCCkKIo0doRRRHGGMqywGqDNYYwjL058zAjjBLCMKQofCKhlk0qS98urTW5dURZhzgOG9+Euq9GWR2jAW5rvaOFdpbSWCJtIbAUShOVpe9DHEXFSFDKG0YXhfdGcM4xGAyYm/Pz0iLHSkEcWQpVesPnSropK3Ks1YyPB5TKIIRESpDSv4YqaxAywkqfdLDOEEmBDLyZtlKKQEhqg2V/gSTOVewDYViqNm5+HC0MzteJIj9AF3oldDodksT3uVKKuTRlYiJEOIMQjigICIIRaSWvo7RQbsmNsB8WtGdxu5bHlZRMuJT3d/3ivoYFKO79Ju/acfNIkcYEbNjCyg23cvpdHyX91ktw4i8pf3Yf3Hgpz+g4s//7bn8uva0kP3iMyfeNLF69hYk/X8/U7/0GxYEp3GN7GPy7R+hUQfPTD95fVYXfTPSd/7qwkn/1Fib23MrMk19gsGsf7onPMf2h5/lnt7y11ciXvp8Xn+sEvTvuY8UtG3jttz6KOjaF2fFnnN68g2vrVU4cQlVtCL76bf7Z5tF+Wk/v/icYrLmXmYf2w7Gvk//kPtjwOk/4ufuZ+cD9zJxvvVseY9Wfb2XFBe42P/hVhk9UAerNj7Hqz7aOVOxP0Lt7J/rDt3Lqk3ehj+2jeHAjs9/dxsqR30D/Ow+NXIu/Xngtqn7IP7yX03duxx7bzXD3zfS+PFq89DYer9PPkj+2XP8CqzczcdNmBu+vxgl7Uc/vhJH3qPzgtxb07zXbbx5hTPlrlP/yKl77xG5cuo/i6d9F379++SBoeoSTWz+KOo+c0RsaG0FCd3X7ntHi6kbLSGjRokWLFi2Ww98fRj1/lHSJSqnpH9RyRpuJ/9NoEmEEwVrW7NxB2AOYwvz537y+6vmrACtue5jJg98j2rxu0ZKK4rv7ftKP3MipX/l1frF7PzMX0hEf/ENWjCYRGiSsuuMz1fQh7InidbR4PfFv3nxevecWLVosxOIgp3MO4UDiEwUScXYiwfp1vNyRIAok490OY70eY90uUaU7Px/09oFXY7wZsHEW4yzKGJQ1FKU+ixUxGjS3FrSGQaqZmUuZywuGeYbWtgm2l2XpZZIqrwVtLdpCqb2UkipN41Hg2QJl4y+QZVnFTphjMOiTZRlCBIDEOEGa5yhjQIYkYcLMTB+tNYNhhjaOPC+b/ZVlydxgiBRB1ZeSNM1QSpEkyYLzNMZQFhprIAziKgnh96WUaQyqgYaJMJo8sJWZsnXCexAgUdqitKXUhlJbCm1QtjKuViX9uTmGwyGzs4PGr6Hfn2N6ts9cOsRoR14laYIgIE1zhAgIggilDMPhkGFekCvNzKDPcDgkz7wfRV6ZGiulMNpRGkupNAbhr4H152eMwTo9zz4QFmsUOIN0IJwjQPhpO584wTmcsThjwboFn9GklRCCoDKo7nQ6jHV7OOsTKGVhMdpV0lAGWTFvFsgnXeJPc72s5UrApbq/56dmkDdthN42kt9Z7v6bcO1Hbq+mX8JdCJXzIqBffIbyp35a7PjDhUHZGsFartn+B4jrNiI2JbiT/hlDH/7+/LY7H+NdS8oBJay6+w+JPwgwhX5yP4NLewrnxaXu5+XONZy4mVV/VJlrp49SHBi58CdfqTTg1xOsWTowveK2bQSrb0bctAHyK+3peIr+tx71k7376H5165KyP+Gajayu++CnXyH7ychCc4R0d+VW/sFHWLF96WvR+aVtjG/f7L88tYf+SNX823m8lidncTdtRKxeT/z5pfsXYMUtW5qgpRuOcib6DL5bX6MH6D5485Kya50N99G5cy3ipo3IfHZ51kX6Eq/+9ufOm0S4JGOjRYurHC0joUWLFi1avKPR2/O9hTOmj6MOH0Lt2wfT+1H/fj9nDn0bs0B39CXKp1/yk7f8Jr1zVcP3NtL9/fUMHnkJfnqA/OQ2Js5jGHa1Ir5uI9d940eU6XGGzx6ieG4/6ocHvLlejfQo9ol7GTy1kexr32TNLecwePs3N7EcfyO8/r1IwAL21CznNGxeEhsJ/qeL3KRFi3c4Ggmj+fJqjDUNm6CukveV/7LxSICFsjOdOIJVKwhkRK8TIwMQ0jWB71ruxx9iPrDqvQkcylqE8MHdThTjHE3FvhUWh8RYy/Qg5XR/yLBQ2LJARAJnfTvz3IcTlFIoo3HCa+XX1f7GGALpg815nqOVN/etGQGenZAipSSOY5LIGwHHccxgMCAMvWxTkiQMBgN6vQ5nZmaYfNe7sFY3BtV5NsTayqehNJjSMx3iMKLX66G1ptcbI01Toihq+qI2C7bGJ0eGw2HjUVH7VRgjq78Wo/0xS+MTDCKIAUGpHUGh6cY9nJs3nlZGkxU52TDFahj0M3q9HjMzM5zpD5menaVQClsqtDXEMiHLCjqdgIk1KxFCkGUZhTIknYh+3ydTijRj5cQ4K1eMgzWcPn0aiWWYR/TGYsaSmCCMUM4ilcIKRxxGhHGEwyCFl22yFsIwPIvJskAiqAr6i5G/9RiUUlJZaXh2ipDIIKA71mN8fJw0nUMpQ5Zq4qAkSDKUKlCqXDA2F3t7vFFGwpXERhjFpbi/j2/ewfjmCzjY6jWV28Wlx/Anz1ZTW4hvXbvseuEv3cP1B+9ZMG/u8N/Mb7t5Ca32GsFaOh/dSPnTQ/Dcs2SntrJiKWbrm4RL289biD+8/Ll2Nt1OyONowDz/IvltVTV984z2EuX2h5h6ZAcT/2IRY2ViM//8hQtp6Hlw0wN0vrDp/BWy4+uILnSf/ZfQz1XTH7+dVeegBXc+dGvVB1Oogy/Bhord+rPDqOr3IX9r4wKmwmKs3LiFAQdw7Ec9PwUf88+0b+fxGt+4jffs23b+FVdPNs/7C1C8iH6mmr7737ByWSJFwrv++MfnPkb/KK/u/JT3ZDtnEoFLMzZatLjK0SYSWrRo0aLFOxrXbtq4aM5GuGMb7PgDXn3wLsoDU7inP0V/w09YcWcVrO5PYWq9y19ae16adOfGjQx4CdiPPQG8TRMJNeLeWuI71vp+BPKTR0lfOEzxzF70DysqcHoI/dlP8tpiqvUI5LsuNjlwMViFbL3PWrS4OAiLdZraSLkOltZB2lGfg9F51lbmzIKqcl2wIhlHhgGdUILROG2wOJyzTUKhOigWb7RsnEAbh3aW0MommC6EX8ezFjRWJlgXMBwqZocFuSrpSonBMyOElGhdeKaDMX6+8AHlIAgotWqCwsYY8jwnDBxhJYtTLyuKgiRJ0FqzYmysWVaWJb1er0lMWGs5MzvDWNFlmJVITCXDlFOWGmRAVK2X5QV5qb3pr9ZEkZd9mhumxHGM1galdJPsqP0PlFJoY+h0Y0QgGwaD91cIKnaHQBtLXipIujiEl3VShsiB0o6y0J71gCMrC+8RkSmsC1CDPtOzfQoDaZoRRKHvQxx5odAS3j35z0mSBIQkiiNio8mzAmstaZqSDuZ8MkQrVJGTpiljSQe0RiiHLjQqVySxpBMInLS+/+OQyBiEtUi8rbJwjCRV6rEpsE4jRTgS2K+TWBKLbCSNjIAgkEhLkxBaMTHB+HiP116TqFKTDhWRLAk7OUVRoFRRsSMMUs5LGo3CJzEW/m4Wz7/y/BAuDJfq/j4KXfQpp18l//lR1HOH0M/sf1OSCFCgjtXGqDcRXtSz2BTl31UFJHwAOdYnPUuvfR7hdeuBQ8A+7D88Bm9hImE5vL5+Pk8/Be8luAUfWD02hQKfSLhuC8ndk16C8tgeiq17ONVbh/zwbYS33E73lnX0JpJLE4y65pfobNp4wZJFF4T/7yVqfpd87wTldJ9y2ZVXIjcAh4EXjzJgPSuAuf/+YrOGXLOKdPocrIuJdxMAGrD//RV8ccw7dLyagrT/KsXf/xz18kHU08+cnUQAOHF8/hrd8N43MJaOU37+LtyxyhQ87SBWn+P/1iUYGy1aXO1oEwktWrRo0aLFUuit4927H+Yff/VeDGAf28fMnfexCiCdbV6+5A3vPe+uOmOr3sSGvgk4uY9fbLp/6Qd3uGid2c516+jcsQ7u2EY5/RIzu/+I4ukjwBHUH/8l/ae3Lcs8eNPwofdeeGVaixYtAM6qvh6t8q5RV8SPVs5b66VonKcOEAZd4mQMIR3SWYxWaCzOzleTjxraOiuwBowW3mzXWoQImmA52BEvBYk2kJeGtJLMkVX0tpY1Ct28HJIQAikEMgga/XxfsS9H9PTnK9mDar16+7ovRgP7QGN+PBgM6Ha7zA1S4iCkKAqsKrGVxBFSkiQd8rJAlSWDwcAnUqz3VEiSbuO/oLVGa9VIM9VtMMagKikjwbzfBMhKJqqS+9HeW0AZS2QFSImyDqEcXe1QRYkuvQ+DE6CzgjTNwAQgDf3ZnCxVGCGwFuIgwIU+maOUQkZeninNMsYDz/DQ2qC1wRhvUF1i6XYTrFEMh0N6nS4WPMvDhQhTUgQl470YOZ5U4ygjSiLCMkcEEUEQ40Q9zgwucEgZIggQEqyWPsng5q/PKGNhsUG3q65r3O0wvqJHp9chTiKyNCfLS8IwoKcsyiocBsxCI+WlfiML57tlGQnnSiZcDYmG13N/L08eYeYHf4Pafxj74pG3sLWzvpgD4JbX8QzQKIc9Svarj5Jd4Gb2VB/e+qecS9PP5+2nlcjrq8nnX0E18xPetfOvOKW3z5vppkex3z9K+f1HKYHZ67YSPfgZxrfezPgFe2e9RdDzk3bXr3N61wVud2yqGSZOz8tu6t+5kdMXeuyTs6RA7x0yXnX/ODM/2Ev5345g/u7QQpbTuTB9qnkXC97/RgqPXsIdA3qTkE4B+ym+tI/BN5aRW7oEY6NFi6sdrUdCixYtWrRosRxWbyCsWdcnDlOePOfaLS4A8er1TD78GMkt1YyfHiI/dRka0rIRWrS4aIwGYWvWwCgLoQ60L04mGGNwpkBbhYhiks5K4s4YcdTxyQDtFuj5L9CLx2EFGCNQ2nkvghG2Q+1jYIwhCAKEjCk0DIuSotRIIA4TBN7styh1I01T6/oDhDJopJicc400Uc1S8FJNXk4nDEOfUBACqzVBLZXjHLaSEAIfHJ+b8xX4ZZ4jEVhVMhgMmZtL6c8O0NqA9ImBLMuYnZ3FWHyAv0qWZFlGFEWNuXOSJJRliZQhFoeuEhg1O8GfgyAIwuZ6WWtxtea+kwjrfQhK61DaoJWXk5qdHZBlBWWu0JkmmysJ4wRroT/IUIbKD8L7YvhkgcZWskpzwwEzgz6l0RTaJwvq61SUGUVRkKY5g7mU09MzGOu8jNIwZW42oywgLTWDQqOUINeOLC3I84Iiy7G6xFp//ZTRGF3grG7kikbHY81GGJXVEvi2myqkUwfrgyih2x3zhsudiF7SISCoPCgU1gKyiipZc16fg+V+P4uTcaPz5z+m+VxNOP/9vWD6iXt5ddNHKXY/vii4vRZx0zbCHY/R+/JCiZarHQt13d8KXKZ+XizxEqxlzcPfY82Pf0T3y/chb1gkzXNyH+qLH2X6Q9uZOsHbAyeK5YtwLhT92csacH4rx+vgmV2c3PRrZF96FHNwNIkwCTduIfjMI3T+0843P2jZ20j0F8+xYvvN/vtzu+jvOz6aM3jjuBRjo0WLKwQtI6FFixYtWrRYFpOEN0BxYNHs3spGtcAeqynIyyMfzrwZjbsCMMWph+6nOPwKrriHFT+qGBvnQ7CW7m1bKJ7bzxVBo27RosUFwRnrxd4r82SEwGpTBWiBSh4IaHwOgiDAWIVWBTaMiZMVRGGPKIpQZR+jNNopouq1ZLRa3LMRLM5KysoEWBuDKTRRpHAuwVbSRNY6wjCgMCX9vCQtNEIESGHpdjpgHcMsRSlVBcIXaufXwedut0ehfF1tEIRIqX3yQEbNNqEIcML4oID1SQdnIZAhRlsCJEJ46aUsKygLhQwkIpBobRkOh438UQ/QpcIqTb9fGzeLShZJI2XRJDKGw2HVrgCtFdZatLIjSQTXGEIbYwhlj6AK+gdB1LA7oiT2yR68R0QQxWgHIf4YgYxIOhFFoQDpjaAt5HkBdSDeWpCColBEMiIvSgKZc+r0aSYn302WZczNzRHHMUEQ0B/MUBQFY50xikKR5ymdJCFNc8oiJ44EDpAypNSGuXRIOhiyopfQiSCIM8I4ptvtQpiA9VJY3jOhTmg5bGXMHBB6g2+86fLicVWN2EqmKyQMHVEUIUVIEsVVsijySRLnEyFNwsw5nBfEOtsLofouFhIScIwaNM8nrEb/elhqNfDLy0i49Pf3wfe/wNzu/f7L6i1EO7aR/OoGkjUT9EaD0IdfueCi5ItDB1EXWj83Wj1/kfjQY6z6LxfOynyrcUn7+bz9NFI1/6tLV8131qyjc/dOuHsnuuiT/uwg2dMHUPv34qaB6b0UD958edipF4Dwv/yCf/ahN7KHLSQ/eoLJ68+/5kJc4eO1f4RXv7gbdewVxL1/xXvuvDhWQP7TR5n9/OP+P2ZvI8Hn76GzeQOdNSuJR2WvTu7jF0vtYGy+Isj8jynY8HpZCesJv/FtL8P2K/8Hxb6PUB6bwu76Cmc2PcbkOSSl3vjYaNHi6kTLSGjRokWLFi2WxRT62BKzJyYJ6heCnx1ncJ69ZC/WGqdbke+7dK1703DdVt7z81/w3uU+jazRJMGao7hjx+HEsxRL9dVyaMqttszT4lu0aHFFY5QtAGcHQutgbS3/Y4yhKAqKXFEogwhCgjhBRjG+UlxjjGcUaF0uW61tjGMuM+SFN9k1OLQ2DaNg1KA5U5ZSa7KKpRCGIVEUNca84IPn4NkFwIJKdiEEURSRJAlRFBFUEj21tNDoedao5YzqdtTnPsqwsOCD5toSJjFae6mfNE3J5oZkw5Q8zwmCgKgybq6NnYMgIMsyLzlUeTPU16FmZCy+Br5P9YJ+rJMmYRjipKPUikJZvASSlycy2ptLG+0otUYby0x/wOwgJS1ykA6LZMWKlajSNIwLrTXD4ZCiKMjznNdee41+v8/p06/xyivHOX36VNMmrTVZluGcY3p6GlVqojAhCmO0MmRZgdUBJZJUW3JlyZTvC1XkmLLwhtVV4qru94WMDNewYRZcM2F9pb+ZZ6X4MeClkQIp6XR6JFFCJ06I47hhoSRxl0BGZ13/0TG79MeczbRZ9Ftabl+XD5f6/v4S6Vf3+cnrH6D33BNcd+dmVr9vUXAb0HpehMUNC5bGi+hlWaJ9zJLLJoh+uTY7Pdf2vr0nf/XXObH1Ln7x9HFgkvCmKlD5/IsUyzXrsuNS9/OrmHNI+1McxdTGs7+0lu55WhcmE0zctIV3f/kRrn/+x8SXm526HN73gSZQZn52/HXtYsUHbqqm9mOOvZ4Bc4WP1+JV9A8P4Y4dx6XLsBiG+XyqdYEbcp/Bf95dLdtCsv97/PN7t3DNDZNne2eM0AIWHOc966iVh+yxV87JHpj7/v288pG7OHHPo5w+azyvJXh/1bZgPSt37/Bp5nQfxc79Z7/jXYKx0aLF1Y42kdCiRYsWLVosh+nD6JqNcP0G4qYqZT3xndXD/XPfIn35HPtID5F/ozI8u2kjydus8r634RPV1CHK3fsYXAgf2xwn/a9VtdyCfm3RosWVjDoAWk8v1psHmmC8lLJJJOR5TqEdTibIMAEZ4oTDWYOxCqW8ZE+979F9GmPIy5J+XpCWJdYJXBX4rqvErQGtLNaANVBqS1noxhNhtN0wL2kURdFZ8ky1kXQYxMRRhyhMFiQr6raNtlFX/gR1MqPeR90+v8yS5gWFKonCxHsJVEmE4XDIoN/HKEUYBCRxDLAgQZDneROErxMJdf/UElKjyZA6CTEajK77IAgCEBZlLNo4rAFnBUXuJXzKUqO1pdSGUivOzPSZHaQYa3FSgBSMT6wgK3KyNAfnJa3qNhZpxuyZaWZOn+HUq6/y6j/9gmxuiC7Kxhi6LDVGO+bmUpxzRFFCp+MjnUZbnAiRYYJxYESIw7M5VJmjKjkj6eaTQMYYjNI4YxsTZu/NgfeNECHOiYpVY3DW+u0dBIiKQRIShQm9pMt4d5xut0sURVViqUOn02mSPKO/gQuVNDpXMuFiJJLeKlzS+3t/ClNXrm/exIrFMjgNCmZ/+J3mmz01u8x6s7jhcrt4Ef3s0ovGN9xeTe1HHZxarhHoFw+hpo/iXjyEqHyu5vvjccofniu6DjNf/yivbLqLE1vv59WLScK8UVzyft6Dem75cx3+cF8VwJ0k3Li+CQD3f7iLX2y9i1d+9VHOLDdugrX0btvStOeKEpBfs57wg37S/cUzTJ+rbdMH+Md/9Wuc2HoXJx4+NO9FcOPNhFX/66efZbnhCqBffpwT/6pKBDx1tJl/RY/XNWsJqvNzL7y05PnlJ47O+xi8b1Ta6jj2J9Xkhs10zlFQ1H/uLxtJIPdPI9mmifWEdSLqmUP0l02W9Mme3QfHDuH+R0JwHtpL54P30f1M9Y534CH631/U75dibLRocZWjTSS0aNGiRYsWS8EcZ2rHQ817jbj3tgW0/tV33FMJIxyhfHCpChe/j1O7dqNTgEmC37mdlRfdkPNVIV1edDZ9hmRzVfV04H5mHtzDmXO0V/ePMvXQ/ZQ/BZhEPrj1wuQSLiPM/1j+5a1Fi3cSnPPmtt481uKcbaarNQCHEOBjrQ6tFYVSlFp4s2QnvO+B9YwEpRS6LHxVeyVXgxRYLBZHqQxzZUE/zciURjsHMsA4v0xZg64+FgjDGK1AqXkd+2GWMcxSH/CvgvxB5KvMR30c6uB7HeAdNVauq8pH2QtSSlwlrVMUBUoprDNoZ+j1uihVEkYB2ihf7e8sc2mOtl6OaZhnZFlGnqUM+32csYRCEgehD4w7RxjH5GVJaTSl0QzzrPEf0FWbDY5CKwgETnq5JuscSmuscz4BAChtcaJOJMx7JyilQAbkpUIZTak0Rako8pK0KBkOvbdBEAQNYyOIItI0RTuQUUyvN1b1E9U5ZUyfOUN/ZpYiy5FCYIxq2BrWgtYWJwTIAG18ckeGAVHSwRqIKk+CKAiJOx0sDmc0ulRgbOOVMO/JoQHPODCmMkauIITwUkdWQ2XqjbD+U43cIAiI4w5JFDMxMUG32yUMJUknojs2RmdsnCTpIsPwnMmExT4Hi1k81uoFba3/Ll73cuOS3t8nVs4HHg4cZLCMpk7/B7vInlz+ntt9f13lfQj19BHOqoM2fU5/tX7uOhvhr3yMuAoC2l27ltbmN8c587Wv++neAySbfeSx82u3E99QrfLQH/Hqz5aOXOaHH2XukSNw8hAu2Ej3hmVP59LjEvXzKMxDf7RkP+kT+5h5aK//csPv0v21+Yrz0BTYFw/B9LfIltOaN8fJnrlSi0rWMv7ZykPixC6GDx9ibqmAsTnO1I4vYNLjuBePEtyyYZ6VkWyk+/uV5v4zDzHz5NGzxytAeoTXHtyFS4/iXkwIN61rFl3Z43UdUS1n9MzXGRxetH9znNknH6++bCb4F6MR/ElEfZzDB8iX8chIf/o4g92L9WXn9zHx6fv85IndpF9d4v8BkB/eQ/GMn178Lrc0Eq799zurJNAUduefcmp6dPklGBuLV23fM1pcZWg9Elq0aNGixTsapw8eWjRnFv3cIdT393jtVoAbdtC7c5FJ3Pu2sfKPDzHzxX1wbDfprS+idtxDd9NNREmO+vtnSXd/Bf1y9XC4eScrPnzh6q/RmvdWU4dRP3yJuTvWIoNkoW7oFYFJrtn5J0z9w6cwx4BnHmL4zJ8y3LCF6NYNhDdOIgB38ij6+WdRPzwwb6Z228NM3PF6NU3fZKyeRFKpVf/wWaY33U6SgJyYoBOcb+MWLd6eGJXrgXlZmVFZnaZiXzoQvjrfGkCGGGUwRY6TEofClAaUAQPW1kFZfyznHMZZhtpSGG8+7Iylnw6JQ4GUMXN5iUb6pEYgMQIKVSKd8Nr/0ssZFWVBmWfzbAohUJWWvlKG0AkISpyQTXKDRDasgjpQPWpcbK0lDMNGyqgsS8IqwByGIXHsfQiSJKEoCjq9XuNzoMsSnJdXKrIca7Q3aRYBBAIpYkpdMj7RQ4aBZwhYA9ZhjaBUijQf0h8O0c5VCRfRme3kAAAgAElEQVRNEEpEAIVyWCEhqE2ftWcaaEsYxkRJSFr2fYX+iCyQMpos9/4KWZHTTwuK0vdHFMXVGFCM995Fmg+xlcnx2PiE9zzodBcYTdfSUs4FhEFMGMYLJJayLOOaa1ZRWsdrMwPGtUNIR5pnSBGS5wFxFKINzA1y4hUJylhkWRLGOZ1IYk2CcFQmygvZMvWxAuf/aVunKwYKzXVEShwOKX0SI4j8tRvvjREnM3R0THdsjBWrrqU3vppOt9ecY51wGsV8wmDe4HkpObD697J43lLfLx8u5f19PdGnJ1FPTsGJR0l/G8z9v0nvX74byQzFT45QPPkV1MHj0JuEdOnAWvgrm4mv3015AtwTn+O1/h/S+53b6UzkqL8/RPZNvw9xw824Y0fO3kGwlpX/YQev3bkbl+6j2DLFP+34A3q3LvXsNonc9RmurePjwXpWPryD1z7hty23HOEX9/4hnTs30r2mgz1zlOyZr5N/tQqOczPRf/jNN6T7b188xOkL8r6dpLNpHWOXqJ8bXL8eTizqJ14le3Yv2e7HcWl1nrvvYdXIs1Hvw9sY3LDHa81/8Tc4+ZM/pPOJjfSuXwWMXivf9iuxqGTsw/cx3Lyf4sAU7sm7mH5hG8PfuYfuprWEzFD85BD5fxx9zn+Y8U3Jgn2s+vSXyPd9FHVsCrvr1zl1YAfJ527z16N4lfyFA2S7dmGr9w1x/w5WjkqgXtHjNWHlb/0u2ZO7cBxB/fan+Mff3ka8YRJOvkT5n7+OqRnbd//uwvNiks7mzRTPHQD2U3x2O6/eX/dtjjp2mPypPZQ/OARMQm+KpQw9Orf8Lsnmff4aPfFRTr28k84XbmPs+lXQP87wB386f35Lvcsth95GJnbfw5nP74F0D/muWxn+x82MVYsvxdho3zNaXM24smIRLVq0aNGixVuM9J67zr3CjQ/Q/YsHuCY5e9GKO/8EU3QYfGkvTO9HfXH/EmZok4iP/wkrd21mxUU8GHb+1SaC3uOYdAq76yNM7+KKNfgLr9/M5H/9EWd2P0Tx3UPAFBzegzq8ZxlzuLXIBx9j5e/dzPiV+rCc3ER4xyT6B1NwYDtzB7YzVxnmnYuC3aLF2xl14LQOjgILpIOEEwvWhTr54CkKxhiKPCWIAgKrMErPy7togw3tvExNlYAw2lJW7AKtLc5aQhmTFYoo8DJHYeSTGto4RBBSGk2uSnrxGLZKLpRK44w3fx4Ohz7AjZde0tobKosgbPT+ZVBp6DfBZ4GwrjJ2nk8kSCkb1kLNYAjDEKVUk1ioA8lJFJOmKSqKCIUvYSydQ0gIhKAsS1aMrWikfqIoauSMnHMkcYxSKWVZMhgMKJWhqOSLvLF14hkGRlMWmrExiXbefNmJCGMcUlqCKIQqiVBX59f9oJQiyzKUdcylQ7SzTZ8URUHUSXACdFE2CYgwjAnDkiRJmnFRJ2CkFE0f1V4TAFIEGGOJ4w55nvvET8V4MMYQxAHGOApbEAUSgaGTBMSZJQySpl+C0ID0iSurF0pviWp8Ivw5IOogvQMrQDik8FJNQohG7qobJyRJRK/XASwT4+OMT6yiu2IVYRKPsFTcggTTKBbLEy1mGiznswB2mfmXB5fu/p5w7fZvol74HOrlKTj8KMU9j3JWjfSND9B94nbMJz5CeaLWPp+cD1oE61n5yA5e++3duHQK993tDL+7fYGsivj091j14SNMf3KJRALQ+eADvGtfwum7d2HTQ+gvHaL/pbPPI/jyk1zzsYXFDp0ND/CufROc/u2HsNPHsU/cT/rEEjHO3mbiJ/8vrv3gEg+PFwHz8F0XaDy9A/HzdYxdqn6uccPvMv7lnzH87KNL91NvM/FT3+TdNy06z2A91/75t5n67Kcwx/x1yr7LEtIuk8jt3+baj12BRSXBWib/7K84tXM7+XcPwct7Kf/9XsolVhV3PsHEw1vOfj7v3cx1+/6WV3//XsqDx+HgboqDu8++HlU/rL53PZ1FS67k8RreeB8rHznKzPa9kB7CPLaEfM+GnYzv2HjWeU184mHy5z9O8cxxOLZM367eRvzkA8hv/Br5D6h86W4e6edJf40eup/86SNwcBf5wV1nMxPO8S63HMZu+4MmWcAPvkD/Y88zdkvtpXAJxkb7ntHiKkYrbdSiRYsWLVoswCTcuBF598Mk3/kJa76/g3ct62uQsOruR3j3wb8muf8e5I3zdGSu24i8+xF6P3qe6x6+uCQCAKs3c83TjxFuunl+3vM/o7ySNGRHEE6sY/Lh77HmR39L58sPEGzaiFg9skJvHeKmbYRf/jYTL/yY99x/BScRAJhgzcPfI7l7y8h57J/XHm7R4h2IQAgCIQil9C8RtQ59JQ1ktfEa9Ha+GrwJtMoQ43xQXxUlRSU15NcX1T7sIu140ey7STDoeWNlbSEvNXmpKZQhzTWlNqTDsvFRKEtNqVQVYPe6/3NzcwwGAwb9IWmeM5dmDIYpWZZRZiVKGawxaKVwxmL1vJmyq6YFEoEkkKGfrgLRQgiwmmw4wBlv+BxFUbN9nhdNELyeFwg5Px0ECCErI2iJEH6fgQwJghBrDXmRkeYlyjjK6pyUdShryEuN0Zai8MbJZakpcoPWvg+tdZSFWuCXEAQReVmQlyVOBmRZ4Y2TlfH+E5UxtDEGKSX9uUGTdPDDwDbJD+dEY3Ds9+3bHYZR01eBDImipJGWKgrlDZYtlFph/n/23j7WsvOu7/08b2vtvc/LnDkzHjtDMgGsdIIyVBMTowYSqgZhqQSJqOGiVAUJ/riiF7VcKVcCV/TSVreIgMCtIpQrEenSK4zqi0gvcDFqjGJenNuEjhsbPDQZVb4FyxnwOJ7xnJe9Xp6X3/3jWWvtfc6MPU5Laxuej7Tlc85ee708a51kzu/7+32/CYytEGVo2i7nNSSISRNFT89IFjI8SA7HSBJIErJwEP0wMXG0kJ+L+fq2UwCKPIVirEYbxcZ8xomtTTY3ttmcb1LNZ5M4RMoizC37Hn6uhNU2x15KQKNu//4ogAyvNwJ/Yf//vvgm7vm1T7PxsR87+u+lk9+E/tBPUD/yFHf/Pz/G6XvegR0tlW7jfT57z49wz2d/l9k/+AH0PWPh9BzqgR+jfuQpzvzEt7J5h3bJ2Tf+EHdfeorFP/uh2//b7bOf4+zfe8ctxc/82R/gaz7/FBsf+wnM+74VphyCc6hv/Lu4j/0GO5d+ibsvbr8+XZt/Qes8Yv/mj3H6M7+Ee2DtWu/9TsyP/RLbn/2lW0WE8XNv/QBnf2u1TkeemXu/Ff0//jwbv/t57v77txbP3zCYc9z1k7/CqU//EtXf+7uoe9c62u/5VvSHfpL5p7/ImY99J9uv9G/axQXu/lef4+QjP4/70Hei7lkr9h9bh8Ur7OON/Lxufehn8/p8aP3fy+dQ7/sBql/4HKd++Yc4ebusDnOOM//y02z/wk9i1v/WWbwD9cAP5c9+/me5+xvOUb/nA/m93/stmuP2auYcd33sN9j9vz+Z1/fYObh/8bucetW/5V6JM+z+xE8MBdNrhH/403xlXYH5r342yt8ZhTcvSt44s5OFQqFQKBQKhUJhjevXX56+3t3972/+sH7833v4n0/d+VMhdyjqam3QOvvnW2uJBJbLAw4POgIW0TXK5pDf2mqSX0LfE9uepmmwlcPUc2azGTEIne9ZLlv+/PoeLzcdN5eBg5tL6soxrxWussyqeihij6HKmv028vwLN/BJgUTaLtsAKdH4qXu/n8Kgc+5D/nOoqiqcdmA0i8VisC7ygyDRk3yYApBHm6eqqqb12NrayvZCSqYg59lswcbGRv66nhNC4MTONtbkzzpg58Q2Bzf3qCvLzvaCuq7BKIyznDhxguVySYpCipEXX/xz/uyFa7x042VuXD+kaQ45fdcubdNT1RbnDDtbOyzmNadPn8rTEW2PrWZUtSWEwOFymacAklDVczYW27R9x7JrMbrm6vPPo4yhi3l6Yf/Gy4Q+MF8sOHF6lxt7S3a2N7nypf/IxnyT7ROnWC73qKuKw8NDJPgcZjxYO4kIi8UCYy2z2QytNc5lSyJXGYRshXTubW8jkacfdnd3qSrL/o3rnDl9iqp2nL1ri51Nx4aD+XxONZtR13NctUCUPRKGHXuf8yysycciP3ujGIJS2KpGGYO2DiRnN1x/8SrXv/wnvPjCNfYP90gpsdg6zT1fey87b/s6ZttnqOsNNMMkDkf/lFaTNdfRvIP1MGxY2YLdgjo6kfD1b/u6v4Df4kKhUCgUCq83/z3+Tb+39+rh6n8RFGujQqFQKBQKhUKhcEdGb3gZAotTylZDwBDCrAmxzx3hDMV2BVppcJaYcjhzCj3ENFnjjJML+khhVSPKYCuH7gbbG6NJCF3Iwbydz4KA97kLX0RxY29J5wNBclE3pNytj++Jg0WQHyYURsugkZQSONBYfAgIoDTDeWdGq6JVwO/qvbZtsc5Q1w7vfd5WKbS1GKVou2Y6nrUW5xwqBJquJal8/C54qvkMRJjNcn+p954YEjEEDg73hvwBGXIk4ObeAUqZYQIghxj3Pts2iYAoR9v2VDOH0nrKLzDW5dBoa+ibwLLp2NqoiSKI9zkgVTRt36PiagogpcS1P38BJVl86bouhzFrTdu2uMEqyDqHsRbf94PFkCAkjHFonQv/2rghcDivn3GGg+USZQzOGGpX0fkeKkArXFWhyPdPSEj0hNAj6ui9CKFHK8t8sFMSAoo1Gy69GszPWeEyTc5oramqilrmJBHqxZyqnmNttbLyGs55ZZc07mztEVZpyko4bgRw5DPqjWVnVCgUCoVCofBKFCGhUCgUCoVCoVAo3JEpK2Ctq9qwsrbJXdaJEPqh6OyHQjZYY0CpXGeViNaGKKsQYxGZuryVyr76o12QMYYYczE6RaENEa0DlaqwStP2kd5H+k7YP+xIPiIoErnTvfce5SMx5EwG77Ot0CgkjNfjvcdgMCp/TkSwbtU5HjlqZTMWrsfz9N5jrMY5d6Q7HqAfrICqqkIkonW2O0oITdfilCEhVHU9dM0rog8chpAL/z7SNA0Hh80khIgCHwO6h7qeT8cLIZBSRd9FjBaMUUPGgUepbJ+UsIhiCJhOQ5F8mYv22mC0xoRA9CHbM2mb17Lt8F1Hu1wSowwTDgdICqThmrXO1kx1XU/3d8zQCCFgjaPzo8O+BgTRhv2mxUaDj5HlsmE2d2zMZ1k0SYo+CJCL/Ymcv+F1j/Gg3SYSAwk12WApY/IEivdDXsPqXiogimAk2wlpbYDBWsoYrKtwSiMSqeYL7GyONg6tVJ6A4dWDkoV4+7wGVrkN+c3iNFwoFAqFQuHNQxESCoVCoVAoFAqFwmtivfCux6yEAW1ARBGCJ4WeGHr6qNG6YmYteghQ1klQJgsMq/3lPaWU0MqirEHpMdDZHAlm7roOay3WKXofabtIGwLLZaTrAiFGlDIESbS+x3uPHjr6QwiTh/96eDQMhWk8SeXGcq31dA63TC4M2wNTNkIa7HzGaYVxv33f50yEIaB5zEdIaZjc8B5TaRKKuq7p2paqclMIcYyRrssBy03T0Xd+OG+hDwFr9SS8APhhaiCERIyCGiZEmn5Yt3oGURFSRJQiItR1nY/d+SkcWcVI8gElMgVI901Lv2yJQaYA5uXBIdpkIWZjYwNjLFVV41xN0zTTuY2WUCklAgGrzSp8WWu6vieIRQ8CyQxHQgaRyuB7IUWNdgZ0IsSI1gmVFJghr0OBEk0iF+xDCATJQsl4z7TW6LXAZM2qyO9chbE1pl5QmUhKgXpjEzNfYIzDkB8OGUcP1oIMZBAlAGKKR4Q3hToiLBUKhUKhUCi8GSlCQqFQKBQKhUKhULgjYyF0vaiuyYV0rTVJrcKVvfe5gB4tzuZpBWcM3gs6CiKgVA4T1lqtHGGSgFl5yKeUCJKIMoT+DoJClERCcXBwkI+T8jGDT4ACA77PFkppCIIehQQRwSqNJEErtbKjiYmkEsQ8e2CtRdA4Y6eJi0gEEcIkRoDWcmRNQp+L/7ZypJR4+eWXqaqKeV1TVVXu7O/7bG2khv36wGJrY8hwCDhnaQ9zloHWmrZpOdzbp2uzMCJJrxWqV0JGiAqtcii195GuD4jkKYEUISihqmqMVUjXk1S2f6qritlsRtN0K6FIFE5bUhSM1qTBuiiFLC4kn2gOGpQIvu2ZzWaoJGinsbYipSyWVNZhTUWQfpiWyFZY2jlSEEQJ2jjQeS2sziKS9562bVF1DjnuQ+Sw69nY2ACdgIQSIcSAswGRSJI8KzDacPWTrVIiDt+7wXJJiaDW7ptSCm0MZlZhuwqnhSSBemMDW83Q2gxCxStYGa1lIkyTD8eEhBJPWCgUCoVC4c1MERIKhUKhUCgUCoXCHVkXEo5b+4yvbEOkjxRNj389Bh2PFjh9309d/VNH/5Cf4EPA94GQhD6G6XOdD8QhUG7c/2hHlF+J0PWEISSZmKYJBBHJDjnHMh/WJxOELFygcmF7fQ201jAICeOxQwgopei6DmdW+x0Zj52tlTxd1zGfzzEIy7ZFD3kFfd/nsGVyh7/3fppiWC6Xg60RxCjEKLecQ2UNPgaavptChVOM2MrgKjeJD8ZYUtMSEURBis1kxzTtq6rw3jOfz1eiznD88X6vhwivT6qsZ0nAmH+giXG4fh+RIPi+JxAxziJGU1lNZR31zNFJmKyt1JAhcbjs6DYrNjdmpBTwvUdJwDiPNgalDZI4cq+11nkywafpXozvj6xballXY+uAx6OUpqo30CbnS6jBnku9gh6wHrA8rsMoJBQRoVAoFAqFwpudIiQUCoVCoVAoFAqF18R6x/Xxruv1wukoCBhlpmLy9HM0Itk+J60VoaciPatCcAiBbrAniml1Dn3fEyRPQ2S7o8E+aPCc997nyYDeIzEiISIpd7Cjx2OZI4LIuO+UclE5eI/RDuLwuTUbpHVxZL2YHuPK0kZEkBhhOO4UUC1C6Hqs0qQUSCFiXU1l7Vrh208F71F8GEOWvY+EBL4P5Msxw3mNAcyJtu8w5EJ/rGtmqsbUFSkl+r7H2sHKKUWsynkBo43SeExrsvDgnCN4vyYwLPKkwHiNa+uy/nUIYZosycHbeQKlaTra4OmUxypN1AnjLMpZWg0z44ippp7XtJ3H6Z52uQQ3Y1lZujaymCm0sYQmT0SYOgsJo22R954UVmJBjJEoOaT7+PO7ft4RQRmHMg5bkadjqhrjKjCaV5MCxjBqpRRKH32uX/WDhUKhUCgUCm8SipBQKBQKhUKhUCgU7khKYf27tf/mr/Uxz3utNbWtMdUMNQgERis0mpQGqxcFyqySFsaOby0JlMH7IUjZx2m/MUZCyHkEFoVKMVvuiAARkiL4jhR6UvRIONqB7rQZOt0VwqpYr5UhpZR98FmbYFgLhGatcL4+/bAulkyiCAqJAaNAKcHaLBwYla8hRk8KEW0Ns9mMqqrQWgA5krEwZhGMIkXOQMg2PXk6YCiga6Zpi77vUbISZNCCHiYS2r7DuZou9Dl42maLpS54+pAIw3qovs/3zBiapsmd+EpR147l8gClhCiKJMNUw3DOESFIIIrkCQnviSmSvIAR+i7hUySlFqNzVoZxLgdRR0/vDL2fccqdJupE2/fs7e0hm1CHmq5PtF1ksbB0fQAJ0DUkUTilcXU1BVIrawZrrJXoBYNgBMhaAPj4fBhXoUyDxqEdaGdB3xqKnNd6FaicJIISlNZHpjIgRykIMQtdKk1hzVPocqFQKBQKhcKbgCIkFAqFQqFQKBQKha+K3NGvjhTox+5+lYaCLAblHLZeoNRRe6Cps98YUghYpdAydIozFuohJKbAXBFBkbvL27alqnKAbgg9Xd9jbE0MiRBCziEYrJBSSKRczccYg9OW2jpclYUDVKT1LWCn6QTRK5sj3KoADVnMSCLDNMQ4naBQiumc1ic05vN5zj0wluADVW2RmGiaJr+/2GBzZwdjoHYWVMzTCoPdU9d1k23T2OWfu98FkyCFiEIPtlIR5wzdYIuklEK0QlrB1DMAOt9T154uREKEai1Med2iqu9y7oG1dlpva+0rdtqnlDv+xwkKZ2vQGqUSfZ+vtY+BJIak1ZBXEen9ktlswZZs0Sz3cM7R9z3buyepAQmJto/U0dOHSJsc+02LrRy9RFL0hMN9bO/Z1IZZvUUahAHjZoRuOWYgH7kvWmuUsbecf+VqjLaISpjK4ap6mGQYcymO/i4ct1Fat8waGQWeIhwUCoVCoVB4M1OEhEKhUCgUCoVCoXBHjlvYjBZAk71NTDB0s5MESDht0MaAsWhJpKCQlAvvonJh1zk3dbOPBdc0CAhqmBIIoUeLRmGIYZXRME4niKgjVkBxyFggDgKEGiYijGFWz9iYzaeib0w9GEgxe/gnESJyxJZHJUHpla3Rqts8hx3LICwopaZMA6MU1RDqO6uqbMGjVLbzUfn8rDNUVTVMSEBlbb52lXvWZbAi6rpuECtWFkYkQWOm6x2vRyRPQ4w2O957Qoooc4DRlj72pKTxUWGcw3uP1hbIUw3WuinHYXt7O38+JOo6X2foPdWwDaPwkhSJnN2ASdNajMX3lPLkSd8Fkkp0weN9R0weiT2x60htT99ny6R6PuPEzg5b92wSJNH1/RS+fHDYoEQxr4TDrsd3LdF3bG/vUM+38L7D+w6jLCJxCKNOoNSQGQHGanJU+FGssiRXU9dzUt8wqxdUQ9CyUgrSNEuw9nuQbhER8pvj18eUh9ugjqsThUKhUCgUCm9AipBQKBQKhUKhUCgUXhPr0we5iK7Wvk+kJLk4LBEloFFoJWhTQQooFdbsXgzKaKzRRB9IijzlIJIzAGLOMxgDd4mAMIU0K6XWQnQ1wceVH/9a9oExBmcNzjnqumZre4fZbEHTNFTWkcQSiUOIcc4I6GIEFCKDxZFWU1f7GLacw4ZXnejrgcrr9kd5SmAs2Oft6rpeZUYoiMFj7BytLMYp2rYBskVRP1gMjceWEKbsgpRW4cF5kkBPEwWjqOG9p++6/L1xw7UaQoK5qWiahpTG3ACmyYfxvyEErLVTaPF4HetizioU+WhGxrg+xpicwxADKIOEnB1hUCRlSElYLg+OrOGNr7zEol5Q1w5nEjEu8pqEyN5BQBE52DskRU+KgcU8iy4HB3t0/SGLehMJgTSILJDXKttHHX2mxzr+uHZ1XRMk4Jw7YlF0nOOB46v9HRUG1CBiHN9PERAKhUKhUCi8mShCQqFQKBQKhUKhULgjY4F0VSjXKLUKrhVJwytmaxkSQi64a+uIIQfuHg0tHkKX0xCCbDQENXjOryx0rLXEFJEkg83MEBzcdUMhXQhBjgQe5/0rjDZszCs2NuZU1YydM3ehtKXxPa6agbg8/TBOOEhCun6tuC5Tkf144XcK1x1EhTw9EaZ1WrciCiFQ1zUxRmazzXxdY+CzD0gtQyHbTeJAP3TimyFIWKXV+s9mM7rOTzY+o8ACwLBOY8F/zFnwKoCBEDQJRVVH+j5M15oiU+iyUorlcjkJIWMxPk4iymr6Y7Q9GgWEadpjEGa01rRtS0g5EyIpjbbVFH5MCjQHN/NzlQSfhJsvXccqy4ndE1RWiPFE3qco+mVH9B37B0uMBGpXIZJtoLzP0w6VmYPySATnzPRsGGWPFP7H52TEmDwl4pPHOTc9++uTLccFo3UR4fjPXokiIhQKhUKhUHizUYSEQqFQKBQKhUKh8JoYC6Xj17lrX6Yg5iRh1SGfhBR8/jkgg5VMlIRWuWAbkyJKmoreaA1Goa0FbUgxF2yttaikckf7sI+YIn3wGGVJcWXvM4Y355BhhbOWUyd3qCqLMY7dU3fR+R71la8MdkEGox3GJIxVuKSIaezKN0eEBK11DoPWmi54Um40hyGbYCzaj9kGSgl1XXPQ5KBdUYoT9QZ1XedgXskZB9HGnFGwuUkMuZC/bBrCUIh3ztF13TQhoJTBOYv3EaXy+SjNIMoElBKUylMi69MRSbLo4n2Lsg5tGpQ1pNROuQbL5WEWJJRwuDxAK0OMHqUcKQXCIHDAKlfAWoutKhiEC6U1PgZiDEPXfqLplqQU2N4+ycF+x3w+J6VIXc8IvqdpDtHeE4cC/XL/gBhycHPt4LA5wWbXMl8IXjTt3gHtskUroTqxQIRsAQWEPrCoIlYpkgQMNgtYAtqaoxZEa2its62Vs8yYDWHbAaWHbAOV8n0ki2Vw1OrqiIiwlsswshLQiohQKBQKhULhzUcREgqFQqFQKBQKhcJXxWgHM1q7wCAiBI+kiASPSCJKQpJHpx4Ve5LEyed/tMBJgCgZrF8USJ5ScCYXx9eLs2OXfki5k973iaQDMeUiurIrS5+6rnCuYrFYcNfZewhNA2is1fioISmCBPRwnkqDVhqRwKK2dFbTh4gRQaIg5H1rQFmDDmP4rmBYhTMbpRFJaB0xSrKgYA2Vm61smSSvnbMr65yUAoeH+yiJ9H0OSx4nAuywnRKoTEUQIfgsqlhrJ2shrXXOmBgEGO/9VOw3xoCMdk2gJZ9b6pmEimiy5VAKOai67/tpomLcn0jOXUhDxoW1Fm0V2uaJEuNqkhhi6EkhTuKHsznM2kjCSMSS173WCWsVM2dJSojLAKKJQeiD5/Cwoe97rr90E+u2EPUS88oRUqLzgtWJZdfSdDNmwzMSo3DoPc701MaCaJQWQKO0RYbsBuRWO6LRiimELMroGMHlSRtQxNgPIpo+Zu11LEj8mIBwe3OkQqFQKBQKhTcPRUgoFAqFQqFQKBQKd+R2/u4iq5BkiQmJEQlxEhhyKHBAYkdMq3wEAWTIP5Bh24RGSy5GKzEYm0ODjdYYlYjDcWOMJEn4PuB9zJm2Ohe0lbVgDFXMPv6L+Sa7p3bY3NqiJdH7hHGW2GZLpDzRkIv6UakcNqxN9tG3hoRCp0QIuSCvhmwGSFNX+ygkrFv95NIlGRgAACAASURBVPMUUEJKHo1QV6uu9SSRFCLauOmaQvK0bUINUw1jyPIYmDyuXS5yh8kyyFo72QpZq3Pmgw94H4ZzXWUmjBkI0zFjSxrsqWLv6XSccg3GwOrRwmc85nro85gpkEUMi7UVyjpEKRJCiD1N32B8wlqIRiHBMzOJSgWSTlgJKAnMK0WT9BCInAhKQQg0TcPhYUM1a9k4XKJswi82sCiCCNFHXNfThwj9sE5iaftANAGNwQEajbEG0SrncUzFf7M2ZRMhSs7vUAoJiRQ9NkWUSoRBoMmCwdHfi1FEOD6RUCgUCoVCofCXhSIkFAqFQqFQKBQKhTuy3rW9KpgOIcNDsTnGCOnodikFxHtkKLRLjGi9CqAFQGevfCFPBRijMUqvOvh9tkgabXSUJIwN0OXz0kPWghoL5lWFsRUbG1vcdfotGJ2L7qIMxjg6H8BYQoxgFEFyF7tWlso5DKC0JtFnYaTP3fFVVWV7HGUxJiESGAvqKSVSFCJ5AiALHhFjVJ5gGMKKU4hEHyaffZOEpBL9YNskPhfsu64nhJw/MAoJWmtCykJFnjRwUx7BOB0gKHzXE2M/rNlq6iHGbAmVg6qFkPpsh6TDlCGgMTBYLikBSQk9BFuvjmvyZIMaQ54d2hqscySlMNbivUPInzFaUAjaKJxENuYOa7M1liYS8GzPamIQfGXpuzE4Owsce3sHLDZP0PYd6kCIPrExm+OTIH3EukAXE77L16wA4wPKJoIRQhSc1mhj0caC0lN49igEZJEkvwYXLpQkCB5CD8oSY8q5HmShYD3HA8mZH4rx69sELr8KWiCp17ZtoVAoFAqFwutBERIKhUKhUCgUCoXCHVn3gYeVvdHI+nvrnwGmrvZp+iAlgu8hBRLkoGUMxjpAEcJKOBitdUbLmfl8jqjcSR5DFjGMzd34uq6w2pCip8KxWGyyvb2Nb19Co3HVjBRh/7BF1XNic5htg7zF9y3zIVTYaIexBlcv6JYdoRdkyH8YBY6cR7ASUMb1GTMSRICU8wzGIv24Hl3XMZvNjoUzK6IRmqZBiJMtkXM5DNpay2wO3d5yyh5QKhGHgGSloa4drjLT+o95CmoQccZpg3y8eCQ/YTy3qqro+36aSBinDtIUMDxORaTpM9oaXD0nKY2rKkzl6JoO62Zsb1nS4VfQCM7V1HWNs8MEyWhnRU1fOwRDjIKPDanP0xkxRpploOs8BwcHWHeSlHqMrgh9wvc9mMRB49dEl4B2C2wlBJ+m53IMjV7PNRhHB/L6xGGKJE+dANA3RANRQHSNMRpJgtY5yLsU/QuFQqFQKPxVoQgJhUKhUCgUCoVC4Y6siwSrAnSaBITR0mc902AUAkQpQoyTmCASh+mFmAOWRdDaoLVBkkKpMGUojN3+eb+DlY/TSEy0LneJ6+E4zg3d99l5B62hrmtCl7vkazOn7wNN22PqGu09xhraRLatETC2wijNbLHA1Ru8FG9iXIPyaijeA8MUwHo3OwwZCcPkgVKgJFJVdtrWuZWV0fi5MUw6pEhsI1ESvu8mWyNgZaOUFCKREHpEhikBbei6DuvMYK3EEbFHr53r6n4NwlA6KoIAUzF+/Z7HGPFDboJSZrI80tpM1kZVNUMSmMpRVRWiNCd2TtPuXydZS6UT8/mMqqomsUMpRYp6OK4mRUUICR9DDrMerKL6LrA8bNnYaml9YF7VxCj0Ieb/dpHG92ANPkWWhw3WzdnePjlYN42ChUap/JzlMGqO3IeUEtrkSQmAFDy+O8QoweoZ6BkJwY5TCGuCRBEUCoVCoVAo/GWnCAmFQqFQKBQKhULhq+JokKwgapWJoJRCK7tmf2SGIGVZZQSMEwowFHUVGI0yhoQcsetRY/e/yTY7ozhhtWbmKnodh/1otIYYQ375nj7M8KFBUi6M+xhp9vdp2kPq2ebKnklplNFYW7FYbNAtD3CuZuv0W9jbb3F1Dc1BFhKMkCQLCmOBfrI2GmyAUsr2OEoE0ZKzF5ymdgZj1HSuSuVCvhCRqOm9x7cdbXNI6/tsuYSg19Z7DPqNksUInRQ+piyeaDVNE6wLOeN5GpPNhFICpxXSR/QwWeG9n/IX4iD6jISYQ5NFBFkLwNZGYSuHMi7vRwnGWLS11PMN5vM5yxsdzlicFeqqwjmDsTZPPIhCtMYYx7xaoM0MqhlJNNfjAZ3vkZSFi7Zb0nULYtuDndH1gb4PhJDPtWkFUQER6BMcdp7Wh2wzJUJEiKJA25yrAUSy4jTZbolk0QGZgr29b5mFGhV7tJNsbTXYZKlbfhf+y8WEVHSIQqFQKBQKb3CKkFAoFAqFQqFQKBS+Ko4XT/MrF5611iRkEhFEZGzwHjz4M0kUSudCt8LkwrrRyJABoJQCrdCuYlZ5lOQAYuccMeQ8g7qeob2nj7lgjAgxBKIPhL6l6+f07T4+NQTlaJpD9pcNftkgMWFQRKMGS6VAXdfsbJ/ghYOX0Sg2T5/DffkF5vM5ac8QvUcpjZC70a21Ryx+xskMa23+Wq2CePNkAtRVlTMgjEGTIGmUgErZFml/f5+2XdL3/ZHQaqUUSSQXsFWi9wFXQUIgpkl4aZueFLJgM9oHjdMdGIU1WUiwKUFMKOfw3k8WSwcHB1NRfRQgJpFE53NNw7UrrdHGoYccBq0VBoUWw+bONrFvkHCIcRoxgjFjjgOEpIlJgdUYN6PemjPbTFSbgdRXtMs/I4Q9UlIkCXjf0fctvumROSz9khB6QgiEaDlshT71WGtBzWi9sHfQolFsnRDQaromhmtQaWW9NU6b5IBwIQVP27YICSSiUkRHjzYWYxxxCp0umQaFQqFQKBT+alCEhEKhUCgUCoVCoXBH1jMQ1jvxR5VgtLtRAqKyDVGKYDCIKFIUJDEELGuSGrrjyeHKq2K0no6Xu+pz8TkH3TqqytKJx1pLVeVOc6NA2WyX0/f99Nmuazi4+TJVLUiMHNxc8tLeHn3naX1PVdWgbd6XqnB2TrU4QQg9SguHe9eJ0WMrx6yqOGw6lJIp92C03mEtawCGTAglOGew1mC1YlY55rOauq4gJowSoo9IEPTQ5d4tGw4PD+m6DonZkkdrTQx+CDiWIa8gZPsho1FWMEaTgLYPtG2PDMLC+JlpOkGBtZa+79HaMJvNsLM5bdsTY76/TdNM1waDUDTc5TEXQ2uNAM7ViFbD85CfkyiK2Hl2dk9yY+9lnNVoE6bzQSuaLnLY9CSx2Lmm3qypFyeoKjjpNjBph5f3D2h8Q9fHSdgI3uO9p217fGxxdUUi4mPipev77OxsY11iPtsgBtg/aNhcVOjhHiujEVkFhednOub1Gqy6Bi8kUsiC1rSGktBqECJIwFeZjzCOQdyGW/Yjt9+uUCgUCoVC4fWkCAmFQqFQKBQKhULhjtyuaLoeuDxmIUhKqGHKYPKQZ31yQU12O+N+8/eG7GEvR36ulKKeOaL3pKSmbn+rsnhR1xVKa6JaFbtjjMQEfdfRLZc4a+iXHcvDfbpmiY8JlCOabLHjJeCip+2W7B3cJEji4OZN9vyX6H0urDuT/3RKKUFcXX8u9K+sgEbBRRvNfF4zq6ocgmwsVpssItiV1dMYxOy7QNd1U8iyHq7fGAMmhy5XkjBtth7yKSF9jzE11urJkmj9s3kSosIOIcMpyrTuoNExUM1mKGVo23b6/Lr91FhIXwlJCRQ5l8IajK3Q2lBVFXGwQEoJSIKkgEbQCJU1oAytF/a7wNInRCk2lKNabDDfPI3Wmt2730a93fL8C8+zt3wZH1rGyrpSiihC7z1BAiro6Zwb07MIcbKoMkqjVQVoJEEMgt2wt9ynlBKjCiKsB4mrYboh5ckREkaRhQcxoPI6KFbh1oVCoVAoFAp/mXnltohCoVAoFAqFQqFQGFifRgCmDvzJL38t12B8P+cfrDq3x23yK1vEaG2HANwsPoz7zfsSlBLq2mGtRQtYpamty93+TlPNamxd5UL5cI4hZO9830dS3yG+p2sa+qYlhp4UelL0kw9+0zQ0bc9yecDNl18A4GD/BnsvPEfwzWATlM975aV/NHx6/Pl47YtZzYntTeZ1xayqMcagkpCix2qFIqG0TLkEy+WSruumiQqtNVVVUbkZs9mCqprhXD0JDzFGvA94n/MQQgi0bTuts1kLoK6qivl8Tl3n83DOTT+vXX5ZvSqIh5AnHsbXetF93fZIGYerarStqOs5ztUrOyafRQSjBGcUtcuCROs9+12kCYYuWZKqcPNN6sVJqu23snX3X+Oed/w1dnZPMp/Xkz3TetaD954+BNqmx/eR4BNdTPQpElBYU1FVM7S2aDXYTMWVKLL+/K7ft+PPubV29VzLmpimBkHlL4h1kW399bry4uM89OCDPPhzj3Nt/efhOk//ymNcWfvRtc88xIMPPshDn7nGm4X9Zx/n1z//5jnf15PLv/wgDz74EI+/+HqfSaFQKBReb4qQUCgUCoVCoVAoFO6ISATSNDGQv15Z4ABHCqBKKYx2+bNDEPA0taBHqx2DQoPKgbvKrMSE9aKttZbZrMJoBaO9jNE51LeuMc7mAN8UUApSEnwYCv4pEX2ga5ZE77MVURJSyh38Xd/Qti2HbUfbHXK49yIiCe87pD8kxBafYi6+V4aIIJKmwOR1UUFIKKNYbC7Y3d3lrt1TbJ/YpK4sGsGHbgpCHovjohWt7zk8POSgWbLsshiAVlSzmvl8znxjC+NqgCkIOcWcMxFCAPJEQtd1U5HfGDN11Vtrcc5hnZkK88bk3AY7CDbW6ixwGAjJD2JMFhSmY6aE6CEA22XxwFYz6roe7oNDmXxPku8xSmEs1JXLlkwp0fSRpU90Ykhuhqo30PUGer6NO/U2qp17WGzusL29yebmJov5IFTMFtSzBQmh6Vp8DBy2DV2IJKUxdvUsjuJAjB6tzRRGrZSZnkVRiUSeZkgIaZhHECWIErQ1uHqGMW4tzyLm34Mhx2P8TXglIeC1vo7/7rxxuc7jn/gZHvnCNfzrfSr/NXzxEX7yk4/x7OHrfSKFQqFQKLy5KNZGhUKhUCgUCoVC4TUxWcEM/Ui5KD4WbtcKoypbzaOHKYShaB4lDp9LoAWr3BByOxbWc7HZWgtolGhmxiEoZlVNV7VEESpjkcHGRkQwSuOncwO0wseelOpstRNzITgXk1dTFVkwCDl0mEBKChEFEogpEJOgQ0B0TyBhraZtE0aZ6VhHJjS0Yr6xwenTpzm9e5KtzQqjA77r8T5QVTOU0USB5COg6Qch4+b+IQf7S1LMEwF1Xa8FVieiJJZdS5IAWhElIRFCEHzbYec1aq1Jfuy+jzGSui6vf4w4W02F9nk9I6QEKmGcpsISUk3btvgUJlFivEfTNEM1Y1YvqGcb1BvbWGtzXkTK0wvVbA4xIDHkrn5lcdbQdD1dTKAss60TuI2TqPk2bH49cvrtpGpOH1sIns25YWdzi9Qb9oNn5/Q56u0aQiTESJBEFKiVQhuDJE3fB7a3DV3X0bYtrjIcdhtspvkQ8qxQOj8fDIHgGEHFwYJLWIVKG4urLaSIJQ8h6NihjCZpDdgjQeJ/NQi8uRWEgRRe7zMoFAqFQuFNSRESCoVCoVAoFAqFwh1ZhSuP0wlmbTrhViZRQSu00rd2Xh/rxs5hC2ntGLmIrdFEwNjs998PIbiVsQSdSKwsatb3lycHhJgSwSuUIlsJKUWUSEoanQIp9ABoIkoSJCGmSAyJXgQbAkl5okRs5SZLHIUgsloXpRT1YsbJ3RPcc88ZNhYznElsLBY0yyU3Xz6gqi0hpFWgMXB4eJinEQ6WNE2HMwqRarqOvu9JyGBl5NGSA42nLAgtU07A2PW/bgWUBQ+h7/vpPNetiqw1aD9YIQ15Fsulo2/9LZY/xlYYY6jrmmq+wDiHsS7vv+1o2gZl5lhXEUIOWHbaURmL1oo2RNoQSHpGvXUKu3MGs3UKvfMWGjVjMyVuvPwib9meUVeGrY0F3jssjrvOfj2mFg5vfIW+PSDFRIyJNOQ/5JPUSIRlbEghsmDGsmvRxlFXOQtCq2GKhLVnby0bYXr2jEFZh/gONVbPU4AYUCbe9vfirypnTp8BrnH27JnX+1QKhUKhUCj8N6QICYVCoVAoFAqFQuGOrBfM133mU0poDElF1mWFacpA2SwSKIM2o70RKBHWPzB2gud95/9WxlJbx9J7NIp5PSPRYZRGOYPxkRQHj/s05ioMRfShu7yNnjoqlMrWPVYrfBRIkRQ7kDDYMCmUzt73IUFIkZAUygciHrRg1nz6jVLEmNBCzhqoa06c2ub06R1O7GxgchYvdV0jKXFgmiHfIND3ucgeUmTv4JDlcsmyWRJDoDKzYZogj3T0fY+xVS6SD2tzNKchX7NEqCo7rKkiJQGElOI0GTIGVccY0UOuwkZdU1tHYwxJqSk/wVpLCHltEA3j/WdlmSQixD6HNLe+xQfPxs4JjJtDH4aAaEddVUTJEx6YOUksdmML5tts3PMWZrtbhL7BxsS1F7/M7teexohnYz5jvwVVnWB759QwIeDzNIYIMXQopYeXwRmHiMIHn6/XOZS2VFWFqepsy6QgSbrFliilRBynFJRCm7xftMr50jo/M3nSIqJ1QMzxoOWVc/Criwu3y1cYJ1vu8Iv4evHi4zz0c48NeQmXefjBB4ELfN/Hvo8L95xhl7OcWdcR9p/lid94lMe/eJUmANqydfadfNvf/m7ef+/WHQ52jcd/7iEe4wE++j+/k2f/r1/lsWE/duMs7/xbH+LD7zvH/Nin9p+/xGO/9hhPXd0nJKDa5dx9D/CR77rI7lD5uPzLD/LwM8NRfvshHvxtOPMdH+Wj334HESRc5+nffITHvvAc1/t8Pbvn7ueB/+GDXDw17Lx/ml/8p49wZev9/PA/+iDnju/jyqf4Z794ifm3/Qg/+p1n88/SPs/+u1/n0d/5ElcPA2CZv/WdfOCWdVqtyQ9/uOE3/48neK63zN/6Xv7mmSf5t19ouPD9H+P73nX8oFd59Kc/zhPt/fzg//phzr+auXXzHE/8m1+b7pk9cY77v/MjvP2Vth/u8e9fucp+1mOxW2d559/8IN/9LfeypYGbT/Dxn3qUq3c9wEf/lw9wfJXDF36Rf/wrVzj7XT/Oj7zvTs9FoVAoFF5vSkZCoVAoFAqFQqFQeE2siwjrwsJYvB9/Pm5rjMEYA+QMhBzIO8fZOcbWOQxXZxujEMLkxT/uJ2cjzKag2/l8zsZ8QeUctaswa931sAoZznY62f6n6Tq6IZdgVlus0zkXgAShR6eAkYhGYQeBIyYhKU1EiL2HEHFD4XyclICV+LFYLDhz5gz33HMPp07u5P3rle3RuA4pJWIUUhL63rN3c5+9m/t0bU/f+Wlb59y05iIyhSSP+QZ5Pzlwebzucc1HMcV7T9M09H2fpxoGK6YQwipgWARn7SoMehAXxpDm8ZxF5Mi0Q9/3076aw5u0hy9zsHcDJbBYbKJcja1yQLQxhsVshlYKa2dU820ilqreIIli9+6TbGxq5rplZhpuPPclbjz/JYgNVZ3DtOvaYSvH1olTnLzrDDu7p5jPNnGuWk1WmArnahBFFFhsbjHf3GJr6wS2mqHWRKD1tR1f41SHUhqtDYImKRClSAzZCCqhELR4FGmYzFn9brxhgpL/WzD7Gi7cd56zc4Bdzt13kYv33csuwN0P8KMf+xE+cGrYtrnMw//ykzz6x9eYv/UCF++7yMV37NJcvcyjn3yIR774Gq2F0lUe+8TH+fUrLXedv8jF82egucrl3/wE//uxYOdrv/NxfvrnP8Wlqw3b5y5w8b4LnJvv8dznH+FnfuphLjd5u917L3Lxa3cBmJ89z8X7LnLh7HFJ4hjNZR7+qZ/hkc8/x978HBeG69l77nM88nM/zSN/POy8usj97wJuPs0zzx3fSeDpz1+iYZd3XRxFhGs8/vM/ySd/8zJX/S7n77vIxXedxf75ZR795E/z8d+5TRh0/ySP/MIT3LjnAhffdZb5ya/hfe++wBy4/OTT3LKyzz3F0zdg65vuv4OIcJmHf/YTPPrMVfypvC73zq7yuX/9Mzzyx7fZ/oXH+fhPfZJHn7kGZ4d7fP4MHF7l8m9+kod+7dm83YmL3P+1wItPcunqrWvy1B9eAc7z3m8uIkKhUCi8GSgTCYVCoVAoFAqFQuGrIgsKORdBiMiardA4cTAWplNKJKWxdYXRuWNclEKiJ0qPNdkuKE2CQLbX0cZQVRbtLPv7+4iAUQqrTQ7HjaAkkUIcMgQiaRA3RkHBp8Cyb1n0FbXRWJUnFZRkux8kF4bzpIHCKA0kvPf4KFTVDAn5exfzn07OuRwibAxBB7RRbGwu2D11ktO7u1ijsEpjLGizKlKPNkN98EjKlkb7+/s0TTMFIltnqBfzLCQMwdSuzjZHpnKTkLC6BzIVx0XlUGsF9N4fsXuyzrC5vYUo6Hw/nc98Ph/2l6itIQ3e8fP5HKsN+/uJvs8B1kJEqbwGk8CgoT/cx4eOvu+Zb2wTkubEfIsQE6qfUeFQAk4brDZUeobSPTduvIg3+9y9/c3sbgSee/ZZnvmz5wjXX+SG+Qo6tlTVAm0VL++/SN8dMK/vQtQOKghx2dH7lqqqsEpTVRVaZ+HBRMv2zglOntjh5KndHAKt8vSADBMG6Dy1kVIipUiShNEqr6HRMNg8rRgDtT1KLEhEI6CG0ROOTie8uphwu/fe4OLD1nke+N6T2J+7wtXmLN/2vR/hwitsev3zj3P5EM5/z4/zg+9ZK9I/9yg/8wtP8uwzXyJ8w4U7FyNeuszlsw/w0X/6Ac6MRfAXHuOhf/E41z77BM9++4e5F+DFx3n401cJG+f58D/4Qe4/Oe4gcPW3P8HHP3OZh//Pz/Hjf/+9nP0bH+EjWw/z9J9cZ+tdH+Qjd5pEoOHSIw9z+XDOue/6n/jh961tf+MSv/jzn+LpX/0UF97xfVyo4MJ77mf+zCWefPJZPnju3tW2/WWeugK89b1826AjPPdb/4rHrsLue36Qf/g951cTFs1zPPrJT/DEpx/m8Qsf5QN3rZ3Ozevwvh/mx79rfd7hDO85eYknrjzF5f4iF6vVO88++ST77PL++26Zj1gjcPnffIrLh3D2Oz7Kj6ytybXPfJyHfvu4AhB4+t8+xtU058L3/yjf9661e9xc4hf/t09x5clLXPk793KeLe7/5vP8+p9c4Y+fvsoHz55dbbt/iUtXgG94N++uKBQKhcKbgDKRUCgUCoVCoVAoFF4z6x3dAJr13ISj2Qg53DgX9is3w9oK56ohdNhlz31r88uYYTohf8Y5Rz1zVFXFbDbLAcyDSOFDIKQ8ZSAqHfW217mo7JwFEp2PLNuAj4LRYBRYnXBG4RTURuMU2OEvo9B7QshZCSJCCAHvc6E8+jBZ/xhjWCwWnN49yVvu2uXExoy5s8ycpXZ2shLSWILP3e7ee7quoWlywLL3frq+jY0Ntra2mM/nmMH3P+cWWNIQEG20A22n/AOtNUqbI532o2DhvZ+67JE8oRBCmKYTUkqg1HQes9mMmauwRrGxqDixs5EFhUG8GCdQQghH7nPwHaFriT6wf7DH4eE+J3ZOI9UmEYXvW5pBvOj7wM2DmyybfV748+e5ef3P+OIz/57/8Lnf4z8+/QWe/8//H77ZIywPhomJhNVCc7hHc3ADH1q0DGtR1VRVxamdk5w8eXKyY5rNFpw6dYrt7S22TmzhjD4yuZKfTbN6lmXdjihPz2RrrWH6ZkiwVkBKAZUipIjEyBgRIjA9639pJxK+CsIgSN146cbRDvlzH+RH//k/4ce/9zWICADMuf9vr4kIAHdf5OJdQNMwzAHw3B98jmvA2b/1PWsiAoDl7Hd8D+8/CfzJ57j04n/Bxew/nYvdb/0A3/++Y6LDyfv54LecgeYyl/5ouNLzF7kwh+aZp7my5mAV/ugpriQ4e/Eiuff+WS79h+swv5/v/jvnj9o0zc/xwW+/AFzjc39wfLRhi3f99eOiwFne/Y27kK7w1B+trXi6wtPPNEfEi9uSvsTTf9zAiffzoWPCyplvH9bvCM/yp1fn2LvezwPvOjbNMX87bz8FpDDlctsL7+a8hut/+BTrV7P/h5d4jjn3/42LpcO1UCgU3iSU/70uFAqFQqFQKBQKd+SViqO5cJozCqbv9SowGa1QWmMrB2LGD2WfewMQUMqgQv782EXvnMtByipleyPlSWik7fDeI7Jmp6RAaYNKAgqcszjniEETUqLrempnqJzCWYMPGpGICHkSwWi0AiOCD54QFKIV0XuavsO6mr7t0EqYuQqjNWjYmM94y913cWpnO/vwa6F2NVprmnaJUQ6DQoIixkjXdXRdR98HvA+IZLumuq6zQFHZqXCvBKytCJKww9SEMTncOE8wVNNkwfq9yTkMK9ujka7rEMmWSlabSWzwPpf7Njc3IQld22CtRltDe9iSfKLpO1LK99N7z2y0dxIIviP2HQnD/v4+1U7D1s5dXNvbBwzL5QFK5Wjjtut4uVmy3wX6fUW9mPOFP/gsqmuR63uc2pixcXJOigYxFgkRrRJts8/y4Cbed5AUKYG2hq3FFjs7u2itadt2WsednRNsbM6ZLxxKS7aamvQvPeQkBBI6CwWiUdm0CI1BsnKDShGd4iq3QBKSAsSEshFIeb9/xYWD45z56xc5+5nHuPo7H+cf/79bnP26C1y4791c/IZz7H5Vned3cfaeO20TeOHFfeAMF87fzh7nLN/4ri2e+Ow1rl4D7rrNJq/Gc8/m4vfhMzz6K1++9f3ruXD/3HN/Cu+5F7iX996/y6Xfv8zl//Rhzp8H2OfSk1dAn+fbRgufF/+UP22A+Zf5d7/6CE8d329znTmw//yX2eccqyt7O1/z1ttc5be+l7O//yhXnrzE/nvem7f/4iUuNXDuvou8qnHQi1e5moBzb78114GzvPMdc574KO3aqgAAIABJREFU9+s/O893/6N/wncD9A37+y9y9fkX+PJ/vsKXrnyJ524c20V1kW+579e58uSTXPpPH+TcOwCucekPrsL8fi6ef7WTKxQKhcIbiSIkFAqFQqFQKBQKhTuSu7WzDQ6AHixxctgyyOhBH/P7MobWKoV2FdpW/z97bx9r2Vnf+32et7XW3vu8zDm2BziBcYjjDA4DGORJMoC5N87FKDEt3GtauRJRi6pUbZQbtbS9oQpqSBvUXJpYFYqI1PxBqpDGvTHpdYRpsYWtiwlOGWNP4uPAkTMFT8wpPrbPeGafs9fb89I/nrXW3mdm7DHBwYY8H+no7Nl77bWe9axn/PL7Pr/vN37fxXP5rpDvg0Qi8KEXEWKAsFKG4B1aazJj8B4sYmFXfNzxr6UiNxnex+4BAmityfMc71raqsS6QNs4cpOTSYeTOuYH04kWWqGDgBBwLmC9BzTW1rRtgzE5tm1j1kFhUBKyzHD4ynVeffgqJl2GQesdmTFDId8FQ7Ae6z2zssZa24kJsRPBBENRFIzHY0aj0dAp4H0UT6RUNE2L0gZPACGRus+aqNE6zoEjoLRCaEWAaJ9EnA8TBNY7qFsIMd8gGIP3HqUUzrko2niPMYYiy7E+ig1GSZZXJvhzdshlsN4NHRCudTS2xnmHVJogJFkxRhdjtF6CfML5sibPMgJQe0tdN7SNxYaA26ux9R7aWzLr8IXCtQq6AG1rLcILZuenVLM9nG3wDto2Bm6vX/kqcpMDHj0exbBpfOwEkX0otRw6WQIydiAIT99Y04dax76C2IngXECKEO2LgkcAMkBUnmL3jeg6VqLFkbooaPyFuTCk+YeMq27il//rde76k7t45Mkp21sPsr31IPcA+lXH+cB/civXX7TL/VKssHxZ6/xdprsvfEQxGgHTF3PB5+fsGU6dvSj4YKAsy+H1xvEbOPylezj50Ca3Hj0G505x8lvAdW/l2IVCSrnN1sMXhQfM2Y+dF4vToC/lK7F6Pcd/9G7u+tZJTp07wY2rllMPbYI8yttvuMwkPrPDC03h8uolvn/2FJ/9wzs5+dTBVAa9dpj10Q675cHDj77lGKOHTrL5V1vceu1R2D7JQ0/D+rtOcA2JRCKR+EEhCQmJRCKRSCQSiUTislwYVAsLgcuIeYBvf6yQICSBzqJHqriTvCuCaW+wzi94rbqD9jP0NkoCrTXGg5IxdyHu2ldkWUZlHVK7mLvQ7ZgPAbSOFkQ4iwtQ2xbdgAsBlER6OewkDyEgpKdpPbX1uBCTGjwMNkaL4dJSCrIsYzIqCL6lbbtQZa2G3fHWWvbLGVjP+fN77O3tDcV4KSVFUeCNYGVl5UBXQW/PpJTCWjsU1KWUIBXG5IwmYyazGudailGOkr4rnIN3scOgD1fun0s/Jq01VVWRaTPkM/TX6AOdXRuFg2KUY3zAuTFBlNSNI7jYCVLuxcKsQOG8ZTQZI7OC0WTMaMnQlDNs44nFeYtQEiUCCo9wNupRQiDaFhUCWkiM8EgRYhdGCFTVjKZVEFp80+DbGMjtnWWcZ2TGxNwLo8nzGFDdB1X39x0Az/zZzddVV/Dvf7ggTNxZgndIPMI7guy+7wNCOAgOEVpAE7yIp0iNCQP6iuu59Veu51Zbsv3NTb7x2CanHt5i56mT3PF7sPzrt3LNS2K0vM7yOvACtkVVWT7/hy+S5YtyCV6Aq45z/LX3cPdjp9j0x7j60UfYfj4Ln6O38lsfOv4SFGbmWQSPPDrlxp86HTMZ3nj8QGbCJbnyMOvwvGJCnL8FC6Nmizt+7w5O7Y/Y+Jn38J63vZGNtRGj5RGaHe773du558Ipv/ZEzHF4bJOtf3GU5VOPscthbj7+Qp5LiUQikXilkTISEolEIpFIJBKJxGXpsw76YuuFogLMhQWkREqNQMUCLOqAyDD4+ws1hDL331/MO+jfH8KIuyyFvuCd5zmjPCfPc7LO8qfHGEOejcjzEVJKrPPUdUvrHHETegxXFl34snMtlWtxxCDlIARSK0yXVyClxBgzFKRHWY7JNHg7ZBH04dJt2zLbL5me3+OZZ3c5e+456rrFuYAxecwj6HIR8jw/INL0QgIw2BPFnIYWIQTK5BTjCUurKywtLTEeF2iTI4WGILEBpNRD3oT3HmstVVVR1/WQVWCtp21j50RvcdQLFv31iyJjPMkZjXKWlsdkeRRV+rE1TYML0DqP0AapM4RwLK9k1NNz6LwgIHG+RtCghaOQAU20bhLOE6wjOB+fn5LozprJB0tZxjyJYB2utQgfsytEgNE4J+/EIi3kYBHl/fxZALiuM8MLLlpn/bNcXGv9d0MIYNs4xoVnQ2fjFULMSSC0iBC7GRIAuzz46Y/zmx/9NCcbQI/YuPY4N73/Q3z4f/h1bnktsP8ETzz7Ul1P86qrloEdNrcu1XWwzaOPReujjcvlKl+KwxscBqaPPcql+ga2P/8JPvLff5xP/+ViGX6ZEz9zFPwmJ0+d6Sx8jnHs2oVDrjgcsx8e32Szufi89uFP85GP/iaf+PPTL3qofRbB9qlT7Pz1I2z5EcdveL5I7AWu2mBDAn+7dSDXITLliW9dMK+Pn+TUPoxuuI1fff+NHD2yzvLyKIohfoftSz7bLseh3GTz8TM88le78NrjHP9uraYSiUQi8bKS/msnkUgkEolEIpFIXBYhQmc7tLCT+8Dn3Y8SUUSQOuYjCEUI4NzF3QwhzO1k4hZ1Hwu0woMMg3ChjIpdBN1Ofa01xiiyLGYh6C5weC5yRMEiz4totZMVSG2wQeL6fAY5F0S8h8Z6nBB4YzB50V3DkGX5gnBhyIyiMIaVpRjkG8ccz9MX15umYW+2z7m9KbvPnaWuGrQyZCZnMokhxibLMbnGBY8LHuvd8NsTaK2laVuc9zRNQ902OAJCSfI8Z3l5wmRpPARRCxEFGSUNQsWivpQaobpOBRGL6q138c9Ey6PGtlRtRetbmraOAouKgkFRFIxGOaNxwcrKEktLY4qR7q4Tux+stdg2dlq4tmU2fY52/1mmZ5/EaHDOY5sKfMvEwEgJtPBd0dEP62mcZeRKxvN24sdsNmM228c5GzsAfAxgVmqeLZF34oZUIgo7HUN+RgjR2uly9Lke3dojOHCOEDyiW5fguxwOjwgeEVpEiKHL/brtf3440WAAWspLFL8j61z9KkNpt3jg/u2DYcv2LLv7gFxjffWlG9WRnz7BYWD7/js5ecCf37J97508cBb40RPzonUnspVldfmTX3WcEz8KnH2AO++94H6euo87v7wLdo03XLd+4Gv6zbGov/Xlf8upp2H9+AmOLlZf5DFO3DACv8Vdf3qK6eKSKTe54+4tsHDNdd+F8U92PW9/2wiefIQ7H9qCtRs48WLyB/qxlCf5wufPsNhMsPvQndz35KW/Vp49f+BY/JRTf/JZNp9n+W+84wQblGze/zm2zsHRt5944eyGRCKRSLziSNZGiUQikUgkEolE4rIs7uKe+88Tw4T7nd1SYAkooZEqhiWLoVhvkVJ39kZysJ5xzuOtO2CNBMTMARc96eMu+Boh4v++aK0ZT0adsCBASHyIIblSyiFAOHYTCKyIHRHOW4SrqGzMO7B4rI07/aVQKF2ANoBGdUKG6sQLIQRaCMaZZnV5iSuvXMYYibfz0mJb1XjrqWclTVVText3+WvFoZU1hBBkmaau68EuaTabDVkFQggcIYYba0/d1FgfUErhBWgBQhuEEuR5hiQMlka2aREizkff1eDJhw6CwkR/k9bG69Rti3SSzIM2iratcVKTydhV0Ys0QgjGRejuX3Yh1h7fdXO0bRuzE6qSJswwSvLXX/oS9XPblHpG6cCUDRMjWR1pnt4T5FrjcDReIFGMjCTXHqM0mdLIALP9lvN1zay0SKnItcG6CutipoEyI0bjCT40GMnQTTEejShGGXiHEXF99kHgMc9jLoB574c8BkEM7Q5DZ4JFUoOw8b1u7XsBwVuUq0ApQvAEWhCaGOT8w+xvtM6PvBrY3uLz/+tnOH34Gt71H57gQnOajX/2Pq7/2qc5df8n+djDR3jDNevoepczj59ht4GNd99yebud74arbuKD79nkk1/Y4rP/80e5/8gbOLIOu6e/wZlzFibX8L5/vlC0PnyYDWD7K3fwB7MjXP2mW7j5uucraS9z4j+6jW988g62vvhJPvZQdz/722w+voP1mo33fIATFwojQ8DwNjusc+P1F1v4XPPeD3Hjk5/igUfv4ONb93H02AajepfTW2eYWlh+2638wrUXfe0F6bMIznwL1t/11ouezfNxzXs/yInTf8CDX/4UH3803mP77U22nrKMJiPYXzj42uNcP9nk1OnP8vH/6eTwfE9vnWHq11lfK9k9u8PO0xwMtx5yHM5QyqPcdCyVoxKJROIHjfRP7kQikUgkEolEInFZDvjKX+KzocNACIKI/QWLO/UP2M24uXBgbRsLvd1x/XWUUgQlwM5zBWz3+WJnQlFktN6QN479/f0Ypst8R3oUE1S00AkGawPaxbHY1hIQhABCSjyBXBsI0WpIa43qrH4UCiEcRZFx1RWHMCYW2hvnCD4KAs45bBOzEfrCu5Vz2525CFNS13XsirBuCGeWUtJ2YdYhBFpnqa3rMiYkVglUAKGyWAQP866KXpgYRAklUWE+53mez+exaYdQZyUEiC6Y2cTv9teLnQ5x938/9slkwu6ze8yqeI7+2U2n0zgGu8OjX32Qtq15pn6OUFXUOsYHjE1gOROc04HgBRqF1pJxlmG0INOgO+Fjb1rhmmjJlGXZcF9NY8myInagaMFSvgR4qnLWBVcX0S7Kuy7fQg5iivce2eVseB+68fvB4sgLgUTjRSAED8GCd6D0sPZD/3dAeERwsRMhxDn4YZYQeo6++1aOffMuNp/c5NST57n650+wcWENPjvKbf/NL/Mjf/Zv+dLWGTYfPgNoRq89xs0/+wu8643rlzr198Thn/1Vfu3IA9z1f32Jb5zZ5NS3QE8Oc+RnbuK2917P+mLl44oTvP9d3+DTXznD6Yd32dbHX0BIAFav50P/3RFOfe4O7nt0+8D9vOfn38eN11z6u0ffFIv65WtP8K5LVfSzI9zyK7/OG75yF3f/u2+w9fAOAHrtCCfefRu3vG39uy/Y9FkEZzc48Y7vIn8gu4b3/Vf/iqs/dwf3PByfmZ5scOy97+dd9Z186t7FY49y26/cxuj/uIeTZ7rnm61z5IZb+dDPHUd/9XZuv3eHJ/7OwlWLdzDPcRi97e0vrZiUSCQSie8LIlzK3DSRSCQSiUQikUi87OzuPje8Xl8/9LJe/4t/+NGLchIIDhmixY0Ljtq2CKkQZowoVnBSI7MJWuVA7CRQXV6Ccy3eWZqmibZJIdoC9ZZDAD4ImsZS1zWzqqaqHc8+G62ClpeiRdB+VXF+37N7fspTTz1FVe7jXDucQ2sdRQsbrZl8cNF3PwTatsZ2HQVaa5CarCjwDkKI96qVwEgDeIpcs3F4jR951auAWJyvqmrIRYgZBJ6yiSIBwGw26zIcRsM192b7iC6Yuc9BED6GQDvvcUQRI+72n9+HUtF2yOicpmnwrRsCpgXRWqrv9pA6hjXH4rns8gOiSNE0Tde14TFaIiUsLy9149TkJsOomEFhjBnyEwCyLOfs7pRnzp5j9/w+Z6fnqaoGbx1aa6SUZEqT5ZqJUWjbomXLxmHDoYlh53zgyd2Wc1WLJeZaLI80KyPD2tKYcWYwGp5+5jme2dvn3LRmsrLCj//4G7nq6tdTt47V1VWuvPJKsixjZakAAk3TsLS0RDGKIosmsH5oFW0kk8mYpckIIxVaKhAxE6NtG/AeJSRSKwZHFuFx1XlkfR6NQ6iY96GUIkgFoutS0WOcziFbAWlA54OAJcL37iL82le/6ns+R+IfG9vc/a8/yQOr7+PX//NXnnWQffjTfPTfnOH4f/ob3PpddlskEonEDzLfj/+mP3/+/D/IeRdJHQmJRCKRSCQSiUTiRbG4B0lKGXdh+y6otsslCBcc673HC39RoK33Dj90KgRE8MN5pdBRbAgeIdwgXvRFd+fcYGUTi9f2QFfEhcfOxxPQKicz0HqHVorQ2SAprVBKx2sL1+U6OJRUXReEYDTKWVlZIcs1bTPfud8LK1VVxVDmLEOZGHjcZxc0dYNzjrKeMasrclGAc7h2nhMQnAcVg6GdtzRN23VvgDFxnrRqyeQ8hLnv+BCAUnKwSOrP2f/uRQSlFFmWdd8FZwPCyKFjRAgxBFr33QhGKvbaPbJcs7y0RGEKmtZT1o66bRFBYomm+cF50LFQ3whPcIHgA2XtWRo3TIqM1ZGJz1BKjPJMMsk4M2RK4r2lqgOzpqVqLTYElpaXGS1NOgutEAWDoqBta6Ag4GLw9miENpLpdIrshJr5GpHD/Qkp8T6+liqKC0FJZGzOwPmYhSCx0QopSIRcmNPeyguH8JbgLEFoSHv0Ei8z069+gQfOwtF3H3/FiQjYM9x97xas3ciJJCIkEonEDyRJSEgkEolEIpFIJBKXpbfNQfghWVkKSfCOIBgK0M7PLZB66xjXRZSGoGhtDcQivbPtUOAP3c55qRRamdhF4OxgY9R/J4hYQK/bBhf88Pmws18InIsdAlrrBQHD03pABZQyeBF3jYuuQ0JpkMLEoniwQBjypL23jMdLLK9MWFs/RKYVngahBSiQQkIAnWeEEBirjEDsHuhzEGZVSVVVgxVO4yw4j+0EiSDiHAujB4unaHkU57NpGqQWiCBpg8XjDsyzoA+6ltFeKiZOI7vCuVCxQwE37xyo65gVIbzH2t42KgZrO+cGS6HQzb8xhnyck4+WWNuvObc/Y10fYk/NqMwMay0uiJiPERyVpxuLp2wtVQNaZoxGipVQULlAoSXL44ws02glsNbRtI69qmLfWoJRrK6uoky0WcrzvBuXYFbWtG2OkIF8nKNNzMcoy5Ll9bVhfoYuASFiqHLXuaG1RoSAVCrmIHRigW8bQnAIAkLIIVh80dooCBDegXCIYHEhhoWDesn/7iUSL8wWn/34nXyDkunUwsbN3PK2V06pZ+dLn+IP/uIsdn9KaUdc/x+/50VnNyQSiUTilcUr598uiUQikUgkEolE4hXLYjZCv7M7+MUd2LFA66VEyc5TPgRc2xBUFBm897jOIsd5i+88+2MIbrTYiTvHVdddEL9nrR1Cc9u2JQhw1tPULS1QNzNs06INOCtpmgt21yOofAui27Ef5vZJQgiEkoDHB4t3DPkNQghwIDKDyhTLy5MYNuy7rAFrB7HCGIO1ltZ5jDH4AN4LvIe6dZR1TdO2XfcChCbmIngbYgC1VgShCDYGUANDMLUQshNl4lgDHg/o7n6stSgpwQqEliit8CJgtOmCrh1tGzMNZCe6ZFk0KLfW0raOsmpYWgrgA9466HpL6rqmrephRz9IlBasrC7x6uZKnju7R3AWhMVTxHmdjGhqR9irCFmG94K6bZjuQ1FEK6FxIcEGRkaTG4WS0DpL01j2qxofApNiRDFeZrS8gu6Cn+O8+CjKNBYfLJnKhnVS13Gso5HBZMRQahkFo/k99GsjrtN57kEMDlci4ENL8OBkQAYHxPUrZBQKgu+Odx6hHAQXcz4Ica12LHbivJi/W4nEd88yy9mU6bOgX3WCX/ylmzj8cg9pgfXVFcpzZ7B6maP//i9x23WpDJVIJBI/qKR/gicSiUQikUgkEonLMi/ChqFIjwDX1UDD8J4kCAkh7pR33iLQg92Q9xCCwzpLcL7bLR4L+b2tEdAVwOeCAMQCcuscXoAnWh/5AE1TYV2D6r3rhRh23UspCS4GNgclYnXegQ9+wYZpbn/kvIuf+bn4obVmPMlZGo+G4/r76YUQYwyNbXEhdlHEnIUw5BFYa4cgY2Be2O8K1CEotJIx+4CuSyPM5zq+VsOuehkCAkHoQpPjk5EoJXAEpBAYY4DYzdA00XqIXphRCqk10nums31QcTd/K8AIECofCva+tXFnv9DR8sdIVlaWUDLmJ7Q2wwVLUNHeR64usTetwRXkq1cQql1s+Qznq4ZGeAoNWisKCUabYW3VrWOvqtkrS6SULC+NWbvyKoqlZdBRqMnzmLdhbReE7ANZlg2ZEiEEinxMURRkecx5GNauknHOQkDK+TqDuM68VAwaQLD9yh+6Zoa1EmT35wACAg4ZPME7fNAgUldC4vvJBjf/t7/NzS/3MJ4H/ZYP8ltveblHkUgkEomXgiQkJBKJRCKRSCQSicuy6C+/KCTE1xqPH+yCkF33QWvxXkKY78QXncDQti20Di26jAEROxD6cGDo/PYRSOTwWV9cD1LhEMS6vI+F3BBiRkG3e134AEJQNw2td9GCSAi8tTgCyEDwgiB8zEu4wOM+4PBCkBvF+uoKWmustYgwH2N/L1rrLtg5vmetp3WBvdksigMeQCJlDH/2XUaBNHJBMFDRykiGg5Y8Ic6FMhKlTLQbCgHfxowE2QkNITpJ4a3HGNXtujdDlkJ/Pucc9F0ZWlG1FuMdVdOgERilyYygdRbhBRoxWAHRvR6PM0aTgrPndynLGa13eKUJ3mOUwUqLWVujeM011M88gbXnKW2La+Iakp3dUkDj0LTWYx1UjaNxUEzGrKyusb6+zmg0IgB13bK0Em2OwCONRmpFURQopWjrhkwrsqxA63lYdOx2iSJV1AkcInTFfuEIQdIrCEKIKCSFQBS4usP6nxBFqNiAIxDBEXzsSAjEbIUg3WCZdbm/U5d6nUgkEolEIvFKJAkJiUQikUgkEolE4kURi93Md8gzt4SRQmLxCBWL+N75uBO+DehC0kUKk6kM5yzWWnwTg46NMWgTrYKCcxgjhjBla+fdAiEEtNY4F3eQW2sZjXLG4zHjSUN9rhnChpVS1HVJcILGWTyBEDzBewiepm1QRkeLGhmg62To7837gA+eYpyxsjxmfSVGl/bZDaPRCO99tP5p2y7fYV6or+uGqrHMZrMuG0EMO+P7ronF4n7oOhx6gabvppBSIomfGWMOBDw37Vwg6MOU+y4JiJ0IWjOIK9bGeYfYESH0vFBe1i17s9jVMR6Ph/MYYxgVsRNjMbw4iEBe5Kyvr7C/v4+1jppo+eNnNWOjKZYydOFpVIUqDMIu40Wg7uIEsszQBolrA3XdxG4NlbG0usR4MmKyuobJRoQgcN4jpWYymVAUBUIEKAyrq6usrMQx9OPLsijqGB27F/rw6MV1JC6wH4qZEmphnYvhs+6o+DoECC7mawgAj+i6EfAOZEsIGaHr3LmcmJBIJBKJRCLxg0ISEhKJRCKRSCQSicRl6YurUop5d0LoRYW4S1ugEFLhkThnByHBS4P0HiEkQQZCiJ79bVUN9kWq8/N3ne3McA3hhzForQ8Uha21CJEzGueMxwV7sxnVgp+/957QFeED4IJHOQdDBoGHIIcd/T2xsAxKSUaTgvVDKxTG0Hg7hE5nWRa7LpyjbR3OVUgd8weapqEsK6b7Jfv7+531UbTYWQxS7gvNSil8FxKttUaoOK/GmM7+SFAURdxd393bou3R8Gy6boU+77e/jlICrQ1ta/E+IJXAOYuUAiUVRVYQgLJpMVKxNGoHISGEgDf5MJ/eR4EoK6Kd0NraGnt7FVXZ4ltLqwQqEIUZ3+CmT0Nb4kIYMglmtkUShRpUDHe2nthNMF5iNFlmMpkwnqygsiWsbUFojM6GAGhjFNlowsraIYosZ29vrxNaBFmuybIMYwqsbRdsueaiwZCL8Dzr/Hk7BIJD+C503DuQiuAsQbnYeRN0zEsQc1EikUgkEolE4oeBJCQkEolEIpFIJBKJyzIUWJFxNzhzO3knegd51VnDhMHyp2k8TkgUI4RQtCH62Hvb0npHsC3aZxivuowCf6CIPcdjMkVWS0IwWOsIwQ1dCr1PvpSis0FyhOhk1IkfEucZdpUrROySEB4pDSFEcaH/LWQgz3MOrS6zvDyJuQvdjnVj9EInQRQoegHDNi2ts+zvl0z3Z9EeSIihI6K1bQw09r4LWAZkH/7bZVF0nQ1ZltG2LUrMuxNC8IQgsXXMPJBCgwxdcX2EULHILRRolXUiikBIjRAKJftQazeIEeNiROssznmm+yV5phnlGq1jN0RjcpRSNM5CU6FxmFEW8wiKgrW1VabTKdXZvVg4DwGJx7c1eIdwFiGilZGUGlv72IERBCqqJigtUXmB0TnFZIliPEaZgiAk1nl0JqN4kOkoFmjD6vIyeZ7jOmFCZ7rrSMg6GyaicNI/q+7ZhxAIUhA42C0Qxz63Oeq/c7A7ISDkXNwSwSPwuNAigoHQEoLEC9d1PUhEuOAaC+fu30udC4lEIpFIJF7pyMsfkkgkEolEIpFIJP6x0xdAe+/+xeLnYBcjBEGoaG/jPW0bd+uXZYlzDuscdV1TVRVtYw981znXhTH74Xf/uj+3UgqjNEWWDWPp669SxuL/Yg5A37lgjCHTGt25GA33QQxl7u+lv24IAS0ly6OCV6+tMR4XCKmGjgitsyE8uZ+Xtm2pqoq9s+epy5rZbEZZll2eg6CxlqppsNYOwce9ONDPqTEm2jx1QdHz681Dg4eugKoGH7pg6Yx8PGG8tEQxHpEXYybjVSaTSZfb4AlCoqRB6wxj8vn7IYYVj/ICKQT7+zOeOTulLEvqpsS1NU03bucce3t7lGUJxI4OIWFldcLKyhIhOJxrCaILL/YW2eVJKJkjVU5eLFGMltFmhMoLZJajixFmNGY0XsEUI6TRoBUej7UNjoBQEp0p8sJQaMVYK1ZHI5SHsizJstitMC4KCpMNQdmDbdEl1nJP/7mM2ckxm8NfvL6H3IQgF9ZRlKSktwTfgHdIYteNu5RQ8QODZffhO7jn6wtvPX0ft3/kI3zkjzf/wa46PX0fd/3lzj/Y+ROJRCKRSPz9SR0JiUQikUgkEolE4rKIzqoFiIWYWYV9AAAgAElEQVRUwOEvOibump8LAtY68JKmsWgjcAGqukGJaGUTd8I7rJ0XdINweB93jffF4N4WSAmJUIIsy7oMhZh/4L1HhrhTqg8j7j9XSiFCwDUW24cTi4AgCgbCKJrKgu92rDtPnudcdcWVHFpbRSuJ93GHuRnCi90QYhxCwFpL27bMqhpXBvZn+9ggGY0KmqYhBD/ciw8e3Vk5BR87GkxhBtse7z2OeK9Zd1zfEeJbi1I5IPGtBxEFiDwboYymdRalMkwebY5yF/AIcC7u7vce1XUYuLoiiGgZ1XdFWOspy5JZLsi0QuTZkM/QNE0Mls7MgeDrPM9ZWVlCCoEIsRPFGIPsOlOU0AQFeVEwKiYorefiU9dNIaVEG8NiILUMgdbF4GoxFuSFYTQqwHrG4xGZ0kNGxdLSEkqI+OxMFEUu1dnSi0/9e9672KHSiU4y0HWMWKTzIARB9XkIXYdCl5MQQheU7QHpkN5BiBka0dopEITruhwu/Pt0cWfCK4nd+z/FJ76wzbFfvO37d9Gv38HH/7dTHH73se/fNROJRCKRSLxokpCQSCQSiUQikUgkLstiMHD/5943f/G9oTNhYRd3X9RFKLyL+QheCXQnFFRNHb3l6ToFhB52f/eCxMExiC50OQoWrbPUdT3s4hfd8b2IYKNKMeQRKCmx3nZ5BAoQgyVTP+Y8z1k/dIgsy6iqCikleZ7TNA11XQFxXGVdDQHGVVlTtg2NbfFSoIU+MH7vYwZCpvVgvbMoehzIduiL8J2w0L82xtC283yFAMP3nHMoacjzHK00QgaMMSAFHknwU1zTDufv56jv9sjzvMtlcOzPKjIt0Ep0QkhAmrkAYFuH1ZbJZIJSikOHDrG+eoidZ56j6roX4rFu6A7pn4/rnnUUKPLunlpALnSHRAsh5zmwxsqyZGU0Ic/zYSxZlh1Yc4ssvr9YvO+7O/rQ8H59gSM4i/DzboS+7eXCcxz8++HAe4SzBJGBswQFoA6c/+IQ51cm1tvv/0VfjmsmEolEIpF40SQhIZFIJBKJRCKRSFyWeQBtt/v/goLohUXcxfeVUvgQaJoGbx1NbVFakIlYRJ/NZog8G2x8nLUIrfGELsy4PbArP/hwoODufDxGa01uMqzoOgWEQEiJB1wX6myMicJG68hNFq+xUOD13iN8YFyMWFpaQohYSM/zHIiF7Koqh0L/rCrxLhbWZ1XJft1QNTWjpQlKKNq2xVo77IxXSjHqiuBCxLDjfud8P1/9n3vxYDGUOcsy6rqMn7cWlBzmxTpHkY0xXceBEAGZKZT3eKnwraemwtlquL5rPVJEsae3UKrrkqpqmGlBoTMa0+CcQ4eYPTB0YDQKs5qR5Ybl5WVefeVhzp+bUdc13rpubv0w9n4dKWW659eQZTmZKfCuxHuHlAJnPQSBkAEfxDA3QgjKsuSqQ+sYE8+nlEJoMQgC/XUW12xcJ7JfmAfClIVQiADBd75X3fwvCgiCuQjwfOu870oIzoOwBC1j6HKQhD5T5HmyEH6wLI8SiUQikUj8YyUJCYlEIpFIJBKJROJF0IUQC0nAsVgPPWC9c4md38poPIKqrLDWUzUtxklq1e1Mb2LheTSKOQA2dIX3Lhy535EPHqUFbe1xzqKUpGlarI87/rVUGKOQEpxrEVpRtw6lBN53dkgq2t/IVpApTeMsNngkYriWFILJKKfIclzbDp0E1lrKqsJaN+QGVFVF6zx1XbNf1ZR1S9W0jFc0vnt/sXistEApgXMepAIVA5SVUjGQ2Xusd+QLBfG+o0FKSTAaD0gRaH2L6Yry/XOINkXxvLnJ8NZRtw2BQD4eobWmngV8aDDe0LTzbgnhVLfT31FWDbOqZly05G1DJjQqqFh4F6ITRzQgUTIKED/ymtfw/z21w165F7s0pMB539lStSivcb5FKT3kQihpYkeFVrjaEXwAEXDOxvuQmqLI4y1pTQgOk8UxSAVGKqyP41FaomUUUPrzLwpa3QuUmnfWCCFARLFJevC0eNsSfOxi6bs9Ftd5dD/qhAYZ7Y8EInYl9D8+WmchwXMwnPzAeAApDgYyv7zscN/v3s49T8c/bf7RR/gIcOwXf5sPHp4fZZ89xV1/chePPFli0Yxe+wZueu+t3PijowvOZ9l9+G7uuP8U20+XWAA94vBrr+em/+AWrr8i/jNg848/wmce7UZw7+185F44/O4P8+GfO8xF+C0++z9+mpP1MT74Wx/k2IXOUdt384lPPkB5w4f4jQ8c7Yaxy+Y9d3HP106zs2+hH/PPv48br1m+xP0f44O//UEOmiy90GeXZvfr9/H5Lz7AN56M967XjnD83bdxy9vWDxZjptuc/MKd3PPX20wbQGrWjxzn5oU5AmJOxe/eA+/+MP/FNVt89v/8AptP2Xj8tTdx2203cSTf5dSf38HdD51hakGvHuHE+3+RW65bPjg4P+X0V+7i7vu/wfYLzkkikUgkEhH1sY997GMv9yASiUQikUgkEonExZRlNbwejYqX9fpP/s2XBwscCAe6Arz3BAJeG1BF7CJoGlrrEcqgjcYGwX7ZUDcNqhMJRADvA3Vj8c6ipEJIFYuygIMDu+09AaU0PgS8D+RZVyiva6x1XW6BG7IRAKQQeOeRIloaKRmtjrz3BCloraW19kB48mgy4XWvew1LywW2tV2gsebsc+dw3lHVNbaNXQ+zqqSqWsqyoqobnI+FZSUVErBti+h21MccgDgOAETswJBaoYzB24B3AR8cuutEgLm1T7Q/0jRNG0ONvcdIRT4e4QMgJEJrlNKE4OP8OEdZVTgXKEYFS+NJJwTFUGDZCRF9J0RRFFjraJuWtnWEIMiNZmkyJtMSpQ1GZyhpMFozKgoE4KwjM4rze3vsPHOWqu7yCUQY7iEQOgEq/m6aBpMZvA+0rqH1Hi/isU3bUhQFRismJmd5eYXJ6oQ81yyvLDPuOkQgFvVzY5BSoLWgGEW7pB4BaN2JD11XTb+u4hx3r6VHeIsrnyPYGhE68UZEAa1/Br1IgVz4rhBRKBCANAQh8VLTffkF/5713Q8XdiscWnk5irmeZjqlbM7x7NSy/qPXc/THXs3rrz3G6/Q3efDB0+zvf5OTX3qYv2ODN7zx9Rw2U7b/7kkef+hR6p94Bz+x2p+rZPOPf5vfv/+bnLPrXPuWa3nda64k29th+6kzbP7l3zK54TivK8DOnqGuGr7zXMlo4yjHrn0dV//4T3LNVfnFQxRXku/+BQ8/uU19xT/lra85qCSc+Xd/ypfO5Jx4/z+PYyk3ueN3fp97Hn+WOns1177pGl63YvnOE99k62sP8Dfizfz0j026b+/zzQcf5PTsMG/+Z2/moIzxQp9dzM4XP8nv/Nkpdvbgyp94M9devYr9u/+XrUf/gm8sXvOp+/jk7f87X31yil85wk/+5Os5nE359rdO89dfeZDvvOanefPhbj3P4jMoqyd44P6H2Vm6ljcffQ3Z/jN859uPc/I7NfWX/4TPn855/Zuu5TX5Ps889TTf+qvHqH/yHfxEv6T8Dvf93if406/tMBVXcvQt1/K6dc25Jx5n86EH+Rt1jJ9+/eSS95VIJBKJ757vx3/T13X9D3LeRVJHQiKRSCQSiUQikXhRSCkRMhDswV3e0as/IIXCi87nP4DWGcookArhPUhBY1uWR2O8dbQuFsitDzjnUSruVieD2rYYkw0BxH0BVymN1p4cgVaGpm6HToLQ7X7vMwe89xhjuh39cghH7gvBve2Q66x6+h39a2uHWF1dxdoGZ+M5m7plf38frXW0aPIebx1VVTGrYmeC6wrPEvDW4vscBCHijvduTL4bp5ASITVegheSIGKeQvBi6EJYJAQxtyRaKIaHEECA7PIWvPd4F7MJ+rEiFUVRsLKyhJAO59r4TI2irmtms70YPExnwWMddd2gtWbWthxyDucE9IJLF1jcNA1ZpuMz0oL1Kw6R54a9/Zos0wfEkDjHM1ywKBmfi3OW1re0wQMB5xjyHnpLpDzLKLKcyajAaEmwbsjH6C2sVJYBMfeitzcabIcWrIwWmVsfdUJH8F1gsjvweV/ef1G5BsERfEPoAqOjvLDwnHgeK6NXTEfCMkffcxtr+na2tks2bryN297YfdR1KbA/ZfnnfpVfe/fGUFDYufd2bv/iDg89dJpbjlwT39y+j88/WsLGzXz4V27i8EK9/8znPsGnvnyGkw/vcuJn19n4mdu4bfkznPrWLstvvIXbLtWJsMA1P3MD6199gK1HN7Fvu36hsHGak1+bwtqNvPUIgGXzzz7LqSlsvPOX+aX3HmHomZie4jP/yx1s3vv7fPbIb3Drtd/TxB1k+27+8N5tmBzjtv/yg1zfF/D/vU0+8zufYfPeO3jghl/lxtUd7vvMPWzbEUc/8C/50A3rwyns9j186vfuY/OPP82Dv/bLnFidn366vc2R9/4rfvmd3fH+DHf960/x4NYDPLBxMx/+2Hy+p1/+JB//3DaPPbbDLRtxXs98/g+5ZxvWb/gQ//IDR+dzUp7h7j/4FA984TPcd+zD3HTVSzgniUQikfiB58ImwEQikUgkEolEIpG4iAuLn4thyovHzIu20a5GZ2YIFo4FYo8nCg1Na2lai/MB6wNVGzsW6qZlVlbdzn8f/esvIDcZuckwxsQidicOZFk2Fx2EwChFpjWZ0mghUQiMVPMQYxcQISCCQ+IxSnDl+iFGoxzX+ig2NJbZbBaDnduYx9C2LVVVdUJCjQt9ULRCCzUIDZLYxaGlREvZ2fB3IdS6E1lQOBsQQuFc7Ayw1mOtJzYjSESXJ9E2vX+/7CyMNNaDUgZpMhACT6BpbeySaBpCAKEkSmvGSxMmy8sUxRijRxSjCVk+gqCRUuNdbycFzgWauqWuWvbLiqax+NbjmgapAB+wTQshkHXPYXV5iSvWVhmPDEIuVMeFx3tL29Y0VU3bVBAcbd1QVSVt23TF/GhFZZSMcyckKo+C0lIxYlKMCM53IkQUEyRdt0cXRi2EiFZBPqCEPFDEj8jhpxdnIIoJPtgDYdQhBGQA4cOBZ7e49hdfCx/AO0RwCO8uOv67+XnFsnoj718QEQAOX389h4kZIj2739qmzTTHfu6giABw5PUbwPcQ6rzxVt64Bnz9ER5pFt7fOsVmCRvveBcbAM0jnHy0hNFx3vMLCyICwPL13HbLUaDk5Fc3/37jeB5O/+VD7AJHb7ltLiIAjI7xvp/dQE+mfPuMhTMnefBp4LU38YEFEQFAb9zMB965Dv4MDz60c/ACo+O8550Lx8sjXHMkvjz2Tw7O9/K1b2Ad2N3pz3Gak1/bhdFx3vcvjh6ck9ERbvm5Y8AOD/4/Z76HGUgkEonEDyOpIyGRSCQSiUQikUhclr646Zy/qIgqhBisWXr7IyFlV9zXB6xzXAhUXSZCsG4eYItH1JI6c4RQDzv3RZAURTHYKEEs5Oe5xhiDMYYsy2ga24UXm2FXft+N0AsYfaeCUgoVPNJJpIxWQn0ng9aSKw8tozzUXRZCcAHrHMYY9vaioDCbzbBNG0OJZzUrKyvRgql1Qyi1tRbVFbd7e6ID8yYlQUmED3hroetYaNv2wHz2wkjbtrSN6+YlRK9+GUUWpTVSGZAM3RbTruOjFzKGsOfRiNF4iaq0SK26jgWB0WbYGd8LQk3TUNYV0/2YP1Dkk9gtYC1e+aFzoBeLRuOcjddcSdu2PHv2HNZ1+RZiHlbctrH13hhDWe0TkKD78GTNaDRCOI9CIAOgFVmRs5SPYkcCMbFDwQGRKsvmYdAXdgAMhfkFQaxfk4vE+4l5HCHIA+cafl/4HBfOOYQ4hwAyHAhtvrAj4YA4N0Q4HDzfK5K1ddae77Nnd9gF1oH1t/8Sv/52AEs5LTn7ndPsPPVtvvH4abZOb3+Pg9jgXe/Y4IHPbXHyoSnH3x6r9ZsPnaTkCDe/pavef2eHbYAfP8rRS2yj1MeOcfTfbLH1nR124LJ2RS+OXZ54sgQ2uPrqi0suy+/8VX7rnfG1fWiHKXD4uqNcyshq49gbWf7SA+x854LRra09zzM4zMbGBW9JfbDw8/QTPFECo2/zlTvv4JELT1HuMgKmT36bKUcuOa5EIpFI/OMkCQmJRCKRSCQSiUTisixa1Hjvh0L3gWLtwrFCG2QIeCDrLHfa1tI6j6otwXtc08Zd5QIUgZAZstoijOqKtp6yLGNxVcUCeVVVNE0DSPKsiDvRtSbLYncCQVLXdRQzepGiG6NSMZPAGIMrA1RVDNRF4IjnH4/HjApD8A7ddQE0TQNCEEL0n62qirKsaOuGsixpO/FAKUVdNd0csJApwRDW3AsiWZYhTYYTsVjez2vTNDhnkd3YVTd3ANbaLguis3ISAplphNKgdCcKOMqyZH9/n6Io0FKhzNzup2kaWmfReQFSdkHUFu8tSuW4LvtBqdi14XCUdcv5c1MKnbNcOLRqCN4igbDQGZBlGZlSXLW2SlO1lE1NfX7WCQke27bDc2mapgtt9gipUSIjeI8SCqM0o3FOVca5lFl8vsvjCU1TRZFKSoL3w3qLlkbzArz3/kCHzNwC6oIOBB+DrntBIYT+94XdBvNMENEJPkKGA/EHUQQAicMHB6GNIkknSLygSLAg4LyiuxEAlpefv7jcwrzHoOTMF+/gj+7fYrrYeKBHbKytUz69+70N4y3HOfK5uzjz8Cmmb7+R5eYUJx8Drns7x/sBTs8yfaGTZCPMC33+98JCC7DO4Ste+Mjdc2df+IDRKBb1L3z/isOsX+Lw74pym62HX0DQ2S8pIQkJiUQikRhIQkIikUgkEolEIpF4UQRct7M++tnT7Q2P9dmYjxAICBF3/QvrYhBvV2h2zkW7IO9QQuKRuBDtbKy3SAR1FiuO2sgYumxbpFVID17EQnj02q9xEzuICCHEYnLbtigjKcbRAqexliAEqJgjILRAIFBViDY0C1kDSglWV5bw1mH7DgrrccEhEMxmFbPZjP39fZqmC2jurgudgCLngbzB2ZgfYBSuD6hWGUIphIqdE8E5go/CAD4MQdXetSglkRpUkCgp8SEQBN1vBTJ2YGhjYki1UJSzc+zt7TGbzRCs4rOcjAy651BVFU1VDaKKDX7olnCuxXo7CCBaa7TS6MxQ2YZZWVOOK5TQ1OU+UmqUDFT7fdDxKlJKlpeXWataVs4+x6yssb4ldPfWixRDUb7ruLBtixYSJxrwLgoZEkymCDaGS9dtg/OO8bgY8ib6bggh+iDnbq12xf/YXSC6H3DdQbITY4DhPFKK2NXR4XAQQAaJQg1CBCF0AkGA4Lvryk5U6DsZXLQ4wuGEwAkZc5j9ZXIbeIV3I3wX7Nz/B3zq3m244hg3/5MTvOG6w6zly4wy4LHP8JE/+t6EBJaP8/br7uLM1x/h1LkbOXH6EbY8HLthITNheY1lLlGI72nKWPN/SdFEdWKXnWeBFxAT1lfXgJ3nP6CMxfx/EI7eym996HgqCiUSiUTiRZMyEhKJRCKRSCQSicSL5sKd2v0Oai8kHg1BDkVSKWPQcNtYvA3gY4hvvzO/3/UupQTnsd7R1C2NdVgfxYfGWVrvaFzMJ7DWDvY/1lpUljMaTRiPxxijUCoW9ieTCfmoQGo1BPDKbif74r3EP8eCdpEbDq0s07bR0qhxdhBBmqZiOp2yv7/P/n7JbDaLooVSnZAREMGjpaDIDFln1ZNl0d8fiDvptUJrgxAS31p8E/MW8PPOibZtqWb7tHVJ29Z439slLfj9SzHcjzEGpMZ7y/70HM898zTl9DnKsow5C2Ju4xM7OiwygMlzvIt5CL0dUh8E3VsyFUVBlhe0PrBX1ezNZtR1zd75c5TllKraY382ZTqdUtc1Qismkwkrq0usLE/IMz3YDclOPOgL+MBcCOoClPv8ieDc0D0irMc7y97+Pi503RwLa9IYQwhuOHffsXFhR8rinwfrrEXbIhk7aaBb08ER8ARiR0XAEUU0EF1uQjx3fDYHLL9wiODxwdF6hwtzwWLx+r3ANow76g/4i7O2f8DYYfPhbWCDW/6zD3LTT13DxnInIkBn1fO9ojn2pqPANo88usMjf7UFo+Mcv27hkFcfjlkJf7vFlr/4DHZzk63uuIO2Ri1lc8HBzRM88TQvgnWufu0I2Gb7O5f4eOuz/OZHf5Pbv3AGffgwy8DO17cuKXZsbz4WrY9e/dKYLgFwxeGYofD4JpsX3iNgH/40H/nob/KJPz/90l0zkUgkEj8UJCEhkUgkEolEIpFIXJY+Q8B7e0BMWCzchhBwCKyb7/ZunWdWN1FM6DIPvA0IpQlC4mN/ADH0VlDXNbOqpGldLOEGQWs9rfX4IHAevIfgoW0sxhgm42WKfDyMczQasbS0xHi8hDGGfFQglMQTEErObWyIv/sd8murK4yLPO7Mt/E+XYDGtpzf22c6nTLbK2lqi3cgUChlyLRBiVjU1xJWlyfkRqGEIDcxbNoNVjsxOBniOOq6xrV2yCmQWsV8g/0ZZd0O1k591oNSpgtldkjRBSSLGDJd1xXnd5/j/HPnmO3v45qW4OYWP9456rIZgpu11njv0VqT92JIJ/BkWUae5+R5TmYMwcdnU5Yle+WMs9M99ss9qqbk/P55zp57jun+HkIIjMlYXVpmaWlMnmdkXQCyVhlKaPqie59rMMoLJPOAZNu0zGaz+OzynHFRoIVkf38/dmCorFuDHq0lxiistYMQsrgme+Fpcb1eKGbMhS+NIHZ6hBAQzsafLjQZ4v9AC+9iRsWF9l5BIoIEH+K9dF0JOIu3LSEEbPAHfhzxvSE8Otjh5+VEy7hPvS2/13FM2b3Avcdu38MdX7yEkNBdsyyrF312ff3bOT6C7VN3cvJxWD9+4mAWQvZWjr9pBOVJvvD5Mwd3909PccfdW8CI4z91rHvzMIdfDbDF5l8vHl1y5v9+IIoOL4JrbriBdWDzzz7D5uJp/A73feEkpYWrf+wIHDnOiauAJ+/jzocOdmjY7Xu488u7II9w4oaXUEiQxzhxwwj8Fnf96SmmiwJLuRnnxMI1113z0l0zkUgkEj8UpC62RCKRSCQSiUQicVnmxdbOUqYLL+6RUkZroxCw3Y5+6wLOC/bKhv3uzxAL94se9j6EIZDYA7ZskSIeIznocd8XoL2b7+TWOuYj1E3nnR8sSsXshN52qK7ruLtdzK2IRqMRs6rB/f/svX2MZed93/d5Xs7bvXN3dofiSh0pSztrYshq2KwIrWEKpgtTFQWLqmmYakrAFBKhVf4QXP2htLIDqVWdmIlD1GqiGEphBZAB0zCRiqppmHZFQRQiupbrlalNOYJ3QG8sLqixOEvO7s6de8/b89I/nnPOvbPcFem60irW8wEGXN6597w8zxly9vf9/b5fa0l0yEcQOITQOB+mHoLVkGE+n9M0Bmv8MOHQW/X0UwFKCbKVlS7ceeG175YsfQbbI+/xLK2fDtMZWZbhvKBpDFo3ZEWOtQ7TBoue5e76ITg6y7DesX/lEpcvXw75A9IPeQdYF8KtvccjoBMQevsiXMLKykpnD+TBW0zddDkOEqEkozzH1hVlWaITiWGOLFKcUmTGc+RIGuyUvEAW4dpWJ0eYjMbMywrpg62Q1hrf5Uf0RX4hBKurq1RVNWRdFEVBlmXD+vT7HqYPDj93xhiapqHI8+G91lmsXWRM9Hu1HA6+CPBmManS2UV5qeltr/p1H77wQC8uvLo3T4TQC1BdlogzWMQQunytcOaQyfz9E7S89qbjwA7bf/BpHv0Pxzn5jge5K3vNjy1xnM0713nqCzt89dc/zvlbN1kfQ/mtLbZfMhQ3rVG8snc4RPh4mB7Y+aPH+Mz8BLfccR/33v4aDv1yg1N3FJz5kwtcYI27T12dNKzZ/NkHOPXNRzn7h5/m4a+vc3LjOMVsh63ndzEO1n70Qd5z6+ITmz96muK5M2x/7mEe/tptnFxr2d0+z059Cyffssv5F1/H7Z+4j7//rvN88otbPPrww5zYOMlaVrKztc1uA5M7H+jOeZx7HrqXrX/1FNufe4SPf+kEt/3wGuyd59w3pxgKTv70+7hr9fWu++vj5Hs/wN0vfppnnnuMh7efZmNznaLe4/z2BaZm+foikUgkElkQhYRIJBKJRCKRSCTyuuiL130Bv7fBgUVHt/Ei2BG1LdZB3TpmZUXTBgsdCAXT3t5o6PSWmqaphm5yAOs0Ski8F4cKwn1nv7Wh4K1zje5Cl/sCebguOxT8BwsgwFs32O0czCucs4yLnCJLcc4gZDhXXddY62kaQ101IRhYCJI0Q8pQ8JUItJAoBFpKxkU+dMb39EXsvkg82EF1RXSlFFIplExAh/sNNj8hXNkaj1OLAOf+GMNnk5S6adjfv8zBfNaJFp2YYUPIsdcpbddZn+TZcAylFCJJUHKEtUE48dahVBlsjYo0WA0VBfO2oWpqVKlpXYq8UmKtYjKRFLmhKmsSldCo4F8zGo2YrIz4y5d3u/vvsjOUPFTcBxiPxwDkeT5YKvWCUz8dshxevWxLVNc1IQ9h6cuFfITl9y9/RnLYpqsXeBASlWY4k+GM6DIRHILezsvhRcjM8P7aiQbCeYSwCKcAh3ACjwnWX1fRT/r0P0PfN0HLG/fywB0XeOIbO2w9u8P+W+7jrr9iYfn4T36QDyWP8ztfPsfO9ll20RRvuY173/8efuL2HR77+KNsvfgCO2wG+6Gb7uJnfuIcn/2jC5x/do8dffq1hQTg5I+9nbU/eYa9t9zFT1ytIwAUmzz4Cx/ltt97jKef6wKGpWayvslP/NT93H3yqnPc+gAf+eBxnviDpzn3zS3OXtCsnbiLD/zcfbS/+4uvT0gAjr/zw3x0/Ume+P2vcf4bZ7kA6GMnuOtnHuS+O9cWT8Mb7+HDv3ALz/zuk3xl+wJbz14AXXD8h+7inv/qPk7d9F0o26QnuO/nP8Ztf/QET/67c6feeVwAACAASURBVGw/GyZE9LET3PWuq64vEolEIpEO4b9vflOJRCKRSCQSiUQiy+ztXR7+vLZ29Iae/8znH8F5M9j+2DZ0gQsVrHqkzrH5GpXxzGYzDg4O8N4zLVt2XznAWEHdGtq6wlp7qDvfWovwMJ8eLIJvFWRZ1+WfZUPOgDHBzkhrTZZl5PmIPM9DQdnUGGOo6hbvBfP5nIODA+o6vJ6moShelxVtZ9Pz8t4e3nveePMx3vLmN6GkQ8mMtrXMZnPmrePK/iX29/dxrUOKhNFohLUhbFkqgrWRUmRZwuqRFQ4ODpjNK+ZtzU033URrHPOm7iYZUtIkDzkP1iClJlEaqRWoDGct57fPsb9/mSRRrK6u8oY3vIHxeBICrbvCetu2ZGnBTTe/AbmywuXLe7zw/DfY/ctdJII01bzp+Js5srrGeDLmyJFVhPeoRHPk2FGUDMHUBwcHIRRYeA5m+1TzEm8d5ewKKysrrK6ucmX/MuVszvTKJepyjspy8jxnXBSMRiNuuukYx99wM0ePHuXIkSOsjCZBKDENL+7scObfP8f+dI7UaZgSydMgAjUt4/GE8WhCMR5RlxWj0QgpJWtrawDILkPhjW88zuTohDe+8WbyPMe2LVIu8hGklEGE6HIVvHVIKbpJEXVo+sDhkRzOT8iyjCRVSO9w84uYcn8QuwQWXNNZc/Vh2gohNegErZPBFklKiRdgBTiZ0viEykpap/BS4AXgO2snFkKCostoWJpIuPP2//R784P+Hzs7T/LIp55h5ac/xofe8drCQyQSiUQi32u+F7/T7+/vf1eOu0wUmSORSCQSiUQikchrEgqqYrAbcl1HvMUDHoWnNTVVC6VpqI3FO4Y8gVCwPWwn45wbLI1M01KbNkw2+OCTXjUNaaZpnSX3IZjXeULh24qhoN52YcShyz8UhkOXOoNY0Qc7z+fzoRN+Nj1AAk56siwL0xYOjDU0dZiomM1mlFVF07YkQpNlKUpJlApFcY8F3wscarDZ6Tvo67rGut46Z8nWyHuEWIRNC6UwSY4xB1jbDvkMy3Y8fYe+UiFHAbp8B2MwswOasiKEASukEOAM1tS0jcI0I3QXPJ2kGVKkNKZFa01TtWRZwmQyYTY9QOAYj8fBXihPSasgwOhOiJnP50gpyTqrqJD10GKMC9MjiQ7TEE5zZHyEcZozFeVgK9WHU7ciTJFIKamqilFRDM+bdS3eCcZFQZGPmUyOcPToKlmWDRMxEKY98jynquZLORIKvEfrZHh2++fNWhsyEDqLLggTKr2NkgCEnqBygcaE/A4swrc0TY1pS7w1SC9QkuF5llc5HAlA+Ra8QHgNHqwNQoLzQZAQLCYrBALPIvj5+8Xi6PseN+XMF55hT25w79ujiBCJRCKRyHeTKCREIpFIJBKJRCKR1yT4yndZCC50gIcQ4S7M1lqcdLSNp21ssKNxMgQje4/tUpJ7j/vl0Nve6qifGlBS0s5bbNNgrMLaBGs9aZoOlkT0IcI6QbHIXGjblrppBnsg78Pn+jBbCMXntm4W9kJaUBRFmKyQMJ9XWOM4mM8wTYUxBpRGSz0U/kO4cY11DtVVkXvbpyG7Qcgur0DjBCgVCulSBF9/gRxCmp33pHmBmc+vskXyg7XPsj3SQlzQSMDUDW1TDR7+AgXO422LbU03BRKshdJkhFIpVVWhtcF0XfFa6y7E2TIejUmShKZpho7+/jlQQuC7+wzCiKAsS+q6pqqqYR2QwQprPF7BX748dP8rpSiKglpXZFlBmmSUdTUcv7eg6jMcJkfGrK4eYTQa4ZyjaRps2w7TKn1WRL8uzrnOEuuwcGVt91yKMMnQ75MScrGugFQaIQtkb0klATISmSPQGF/iXINa+tkI5+oEs14E8B7pXcjdcAK8XQSMd0LCIBp0sQr9PfT3E7kOf/Y4D//OOSinTBtYf/d9nEpv9EVFIpFIJPI3mygkRCKRSCQSiUQikddk2QYGQHS+8rhF8Tb4+oeg5aZ1eOcx1iGEwvtQxFdKhSJ8G6YPvBAgQ6Cv1KFIr2TIC7C26cSGMGHgLGSZwPmaVgSRovUMIcpSSqzx2DZ07fcF9OWOdG8dzphBVBBCkOlkEDh6+6C2bamqKkwXWEiVRicpQitQEqEVognnlF0hui9ah8kJi8BjQ4ouvg/l9ZJQmZadKKERInTH5zpFqQThg3WOd0EMccbjrUMkEi11mLbwcjifEBLT1oNFlOgK+FfvXb9/zoFSi079ICAEAcY5h9IiBC13ohHQCUcpWhlIJeBp25amacI/RUI5r1F6TmUsQiqccXipmKweIb2YDgKTMYY8LcAES6GV8YSsyIcJlZWVlW5CQJDojHw06jITFp36wjuEV2ipEB6y7nr7Ln+lFve/LCQ452hMO4hX3nuKrMA5j7Pd5IjS0LY4Z7v770QGoUGNUInAGhHEoeU17sOzfcjOAJDCo3G0gHceS3gWnPdhaoR+H8LxovPw62R1QjKdsofm+I+9nw/+5PEbfUWRSCQSifyNJwoJkUgkEolEIpFI5HWxXIw+FGzrAe+xxtO2hqZpaRuL9wJj3PD+vtivlMItvQYMljcQCqtpmoZMAsUQmNw0DUDokhfh2LJpu6yEHKUcftHMf2gKoZ98sNZiW4Pwi87vPM+HLnqtw1+R2rYNX3UThA2ddMV1PQQ/h8K1Gvz2e/I8R0hDaw3eWZZLw8YYtF7YLfUF/34ioLf6kZ2NVH/d3ntQkiTJqNpmEUhtLd6H3ITloGop5XDs5XBn7z1tWzMUx7vzNk3FdDod9qK/x/6zWuuQTdC0JElC3YQJhLIsybIMLRLm8zlOCQ6qkvF4jJUgtGJydJXRaMTlep+6rlFJmCpJZLj/lZUVkizlypUrpGnGsWNrJFlGXbfoNCfNErQO99JbVKkkQWmBkB6PXRKCunUTi+eu/+cgJHSCSdM0Yfoho5ugACkTlBBYD65tcb7GOwFegdcIkSG0REoPth2EnH4a4WpLIuE9SngEDmyw3nJC4gkmVP3PBB68FMOkjXdRUPiOrN/LR//pvTf6KiKRSCQS+YEiCgmRSCQSiUQikUjkNVl0szv8UnE7vB66qZ0DYxxV3TIra/AK74Mv/CAeCIHrCvhehKK1qINVjpQy2AV5CwpylSO77viDgwPauhqmBSShKI9WjEYjgCBEOH+o+N7bG4V8AQPOAA7nQnB0VuQURYExBiUTWhsEgLKuhhyCNNVInaDThCTJhnMkeYYzoSiN72xqpGQ0GpEZx6ypMLMZgmBnEwrZ9VA8FkpiXBssiIRESo1zYfqhYiEKIAXWu8H2ZxAx+uOIRbf9ckN7n6dAt1ZSBlGgquednVInSHQhv71dVZqmoCSutwJaElzKsgzF805omM/nTCYTLIa6bTBzuHjx4nA8mWiKyQqrR49y5fK0y1OouXLpMqsrE5yxVE3J0bVVtE5orWW0skKaphh3gOxFJNuQJQnOdfetFEmiDtlAheBiF4KYAWvVIER55/BYXLcW/ZdSCuMsxlmEE5gu70AIQWMbvCvxUiBFSlsbpE5IEoXUYyRzvGvxvYggXWcrJelnFZTwXbizxVmHswIrexmhz1gQaCERfpHzsTxREolEIpFIJPL9QBQSIpFIJBKJRCKRyGsjHEJ0HddChI5q53B4HBJnwClweNrW0zYGi0UKHbq7nUNqPeQYIAVahe773kt/2Yc/TVOEYrDY6S2GqiqICUkXOKyVHGyVmqbBmUXx23biRE//WQiF3yzLmIxXKIpiOH9V11RlTV2HbvPRygRU8M7vbZm890NAb11rJK7LTdA40yKlJh8pnBI0rcXisa3txA032B/1QoExhqRYAW8pZ5dobINdykRYDqfuRZLeBsp7R6JChoR3i/VzztHaYOEkTbAfUioINT5N0LahMQ5jW1KVcvSmNZJUUeUFWku0ChMTOk2wdR0soXQSchCaOhT6TYNta9q2piwlSiZI4bl8+TJ5nnN07RjpqGCsJDfffDMXX3qZ+XyOEiFcuUgzvJZcvnyZbGXE0SPHUCZMChTjgjxP8d2z0zSh6K+yYGWViAwh7SHRCOcxpsXYBqnAOolUyaG1M8YNAdFX23UFGyyJkwnWe+rmADO/HEQImeDJkWmOFxNSrRAqDaKBMyAdcNhOKmQfWHCECRjhsd5ijATpEd2phQhBy7LLquivNxKJRCKRSOT7iSgkRCKRSCQSiUQikdeN6ESEw4HJCutD1gGAd6EQaj14JTEmFHt1V6y31qKkRmo1BNP21kJSShLVdZ3rEKbrvacoxkgUTdMM9kiLwGE1XIttTchT6Ir1Og2F5LZtaeoav1RAzvOcPM8psnSwNKrrmnndUDY1SEFWFGFqQLjB3qcv1GdJ2l3vIvR3Pj8AIUiSjMwLsqyldZa6Md31ymGiwGCRPtx3KjymKZkdXMHYZrjGZbsiLEMBfJhG6L9lg5VU76zTT270dlBe1mitqKo5ssiGDIi2rsiyjLW1NYosoZqXgMM7g3HBGqp1gPZDGLYVnaDS1symV2jbFodEJTUax3w+H0KXdZowkglrx44xmUyG1/trNs5gnePKwZS1Y29ASU1rTZeRAGVZYbophixLhv3OdIJ1NXVdhwK8EzhnaNsW68yh56MXmYLVlRuEp+XJjiA8eZSwkCRhcgZP21TYuqG1Hus1ycoRhNR4MaJIMwQaZ2aIa2QbeB+SMbx3SJYCn4M6csgSy3E41+Jqi6RIJBKJRCKRG00UEiKRSCQSiUQikchrcnU+wkJECEVZ11vxeNkFCAvoQ5hNXwwXSKmw1qESgURije185kNxXkoZOs6TBKFC97lzsLKiSZQOXvbCoTqPf7Qiy7KlDAQ/WBKF3IRFeLK1tivs+i7cOEeJcD4lVSc2tJRVRWscRVEghCJJJKoTC/I8D/kNzvXuNEGMKAqapoJKY6wlAbROyfMRtixDR79zID1GBFHBGYMDrGlwpmF6+RXK2XS4FyFEsNxREiE1Fo9rLVg3ZD94LM6pYI+03F3vWmojKZsS4w2pV0jlcaJFZTnCQTmb07YVN62tMZlMSDWM8iDcOGupTctsNsOZkGcwmx6QpAVee4qiwLdVmEqwFmcNjWlBSIyxOBeyM7yHohgzHk1YO3qUy3t7aCnJOxHGmoakW0/nHHmag1zsXdMsgpGFUF1GRchwsG5h3+Scw3S5Fs6bcHzvwBqsMVTVHO8F1oZjuW4yQanwrIbjCwwiTEEg0UlBqzJawuTFbP8KI9MitcJqjUrGFEqDbfAsBB68Z5ABpEcSMhIEDu8spgsoV2LxLGohl4QEGa2NIpFIJBKJfN8RhYRIJBKJRICt3/pFHn3uOPf+w49wz839q4a9Zz/H14oHuff2G3l1kUgkcuNZ7o6/1hdikaPQhwg3VYlOskMhtL03feLToSvemBblGUQEIURX5A3d4lqrMF3QhfN6LLILS0YrlEoWxeZU4pxBa01RFCAF+/v7OOeCXZLz1GU1XEsf3ts0DWVZUpZluL4kGWyM8iwjz1OyrGAymVAURQganpUopSiKAq0187m5aopADPfSn6+1lkaaros/2PF456ibkM0wm+5jOpEAutBkrRFaDcfqjxesegzWeJQS9MpGb+HjvcX7EEScF+B8Q9UIynlNUYyxHrIidP73HftJkgzTALNyTtU25B6ctawcmZAfWWF6ENZvfGSFJM+4vPdK2MfWkiZd170xwcZIJoyKkGORZRmj0WgQjNI0RaSa8coKR48eHSYExvl4sPYJIk3OaFSgOjsrIQReLWdECJqmoanDs6STxZRBVVXDRELTGKwL++CtJ03TELiss+65MkPItRACZIZQmjTTKJ8jcsvs4BVq2bKaFNQiJS8KhM4Qrsb7V9sRCUB2lmCJB+nMMKFju2dYSonx7pCQECcSItfk4tN88lefYveOh/iVn9t8zbdf+/fb7xF/xWu9Fn/164+/u0cikch3kygkRCKRSCRyHfa+/Gke+cIOm+9/8EZfSiQSidxwlq12lnMGloWE5eLnMKngG6RIBouZvsjcNMG3vyxLcA4lROhy9x7nFvZDy8VzlaadtZJFuBAAjJLQ2QMZqfBJsLgZhIAu0NkYg9caUzdDoV9rjdYhp8E5KMuasqy7/IQ0FLoJExZpmnPkyBFGo1Hohrc2fF8wFMf7Inf/fSHUofswxlA3DYJQZBdCIIXoRJEprWlCzsOyP35XKB/Ci6U8lJngvQ8FcAUId2j9+wK7cRbnBW2bILRHMWMyWWVlfIRi7ShCCOq6RniH92ESwwvQWUqWZVgh8caSJIokL/BqD6E0R1YmHDm6GgSSxuAcwx63bct0OmU8WkWpZLCRGo1GlGU5BDsrpSmKMZOVVbTWJElCMSqGqZKiKDhyZELe2Rr1996HS0spu/NbrGkwpkXIJKx1HcQloHvWKqRKwme7Yr5QkiwtuswKMCLkSggp0UKjhEArhU1BrGTU05Lp5ZfR2VEyPaHNx6QyxdMg3EJMA9+JGUH0UkKhu8kEZxuMdQi/sLlSLAQiIdR340c4EvkbT/zdPRKJRL67RCEhEolEIpHrYJy50ZcQiUQi3zf0QcHeh3jlZZsjIGQdSIHUCu+DWGBtCJrNijwENHcByN57bBv+G+uMDb7+XQG+bWtM24bCuOynEyxKJUjCe6RSCGfRWiP0QqRoG91142foRKJ0KMymqaZtBabt7kOETv98VKASDUja1lK3hra1qK4rP0kSBJ1Nk9SoJAMp8b24oQSJTCnGObNZGQKk02QQD6QAocIkgU4TRKXwTmBdEFKEECgpkR6sDd7+zi6mGQCU9iAczhmELPCSLksi2Bp5JEqCVCp47guW9qXrrreim4CweCtIVSi+J1nKaDRCKkXdNqQy7EvTVkGkwYXzSIlMJONxQbG6gukmTkbZiLauOHJsrROGLE6Ac0FIOJjOmU8OmEwmSMWQMVGWZSe0CHQn+KRpxigvgn1UltGYGiHEIOggwTiLEkFIqWyLcyH/wRpDXTf4TryidmAdWsthuqRpDU1tyIpgj+VdeA5CToMnURqsweGw3qJZCDdCyhC4naXkbc7BfEZ5aZd6fDN1PkKlCiUUjgbhPd4HK6z+mQeBxKHxKG/xtsUaB11GgnACL7opCicQIv7+EbkON9/DR37lnht9Fa+PG3Ct8Xf3SCQS+e4ShYRIJBKJRCKRSCTymgSbHI8UAstSZoIVCOVxUuCVRqWL7vu2bUlSRZIkh/z7+yDcPjRZKUmqg+99XQe7HtkC3XFCt7hAeEjTFKWC7ZFSCpX2EwUJSrXBOskmQ8e7aw1aidAJ3nWwK6VASFZWVoZrK8syTBVYy3hUDBMNSoWwZsnCCinLsmBRZAxFlpCNCvYP5qRJgejcaYxp8N6S+pSqacg5QtNC01qaql5ME0jZCSxtFwTMIKwIIUiURAkHziG0wjqHdTVShL/KCSFRWqNUgkZg6SYgCEXyPkRaCIETkkQnZPmEvBiTr06GLIKwzkF4KMuSIstx1uBaAw6U1uR5xspkRDKZgBPQWvaaivFkFW8dly9dAoJAECYKJHu7LzEZZSQ6Dfunw3pWVdU9T364xtXJUbSWpGlCojzGMUx31F3I9kpWYK2lakoEhkQqvHO0Xai0c56mLZkZO+xtnue0NgQfQ7BxEl6Qp0XIZyCIHEiBdV2WhpAgFUJl2LbGUw/iyZGi4crBHrPpt0lGx0i0RCqBsw7pPEKCc314sgQEyluENGhhEcbh2wbvuu8rMN00iRDi0M9KJBKJRCKRyPcLUUiIRCKRSORV7PL0r36Spy6Gf9v6zV/kF4HN9/8KD731hl5YJBKJ3DBeNYFAsM+RgJcgtcQmmtR6lJYLoUHJIZy4bVuUCn75veVMn4GguokEAOcNbevxLPIWrA3d6FprhPRoGcKPUXIo2Pae90OR3li8NQjnB2sg400oCI8K8jwHQmG5bhvqNgTp9mLDaDQiSbJFtkHToFQQRiAU6ufzlrpqaZqWyWRC09bBdz9JsFaCbdFJhpA+2PYUY7RcBED3axDW9tXrniV66Iy33iE7cSVRwZYJLxEqRUoNQiEw+G6feqepPpBYZxlZllEUI4qVMUmWBrHFOdrWIl2YEAFQomFWzqnrmlRntG07TBQkMpyvPpjTti1HjhwhU5LZbMZ8to/Wmv39fUajFbxpeeWVVzh65ChJkqC1DlMPTYtzjizLEEIwnU7R/8nfIs9TnLckOkN4R9OENWpNTZZlNE0owFdtg7Ut4ywFCLkS3jOfz6mqGd62JEkQlOq6RSUpqVZU8xLTtCgV/ipsw3wNSIkz7SELLwQgFEgRpgYQJElKURTs71/mYO8ik2O3UGcjUj0CUYFbCFbL2SBhn33IYLA1bWsQKEK4iDj0meVn4oYyPc8zv/skX9neYRp0GvRkndv+8/u4/x0nmVyVB13unOGp3/0yZy7sYRzo8Tq3/eTh9wbP+00e/IUNtv63J9i6YtDHNrj/v/0Ap28CzB5bTz3BU396nt2ZATTFW27jnp+6n7tPTq55fU//2Q6lAaRmsn4bP/Gq9xr2nn2Sx754hguXwn939Pg463fcw4PvPcXa66yKTM8/wxN/8BXO7Uwx7jud79r09/7QP30P5ncf48mvXWBqwjq97acf4oG/s0b5zWd4/P/4AlsvGZCa42+9jwf/67tY76/xerkD5QWe+fzvDGuhV09w+j0PcsuhKzjP47/0Gc5wmg9+4gFOLq3Pmc9+nMe3YfLjH+Jj7z2xdNNf5dMPP8GF5fO5Kef/6Ame/PI5dr7THl03I6Hkwh8+zu/0n9cF66fu56G79/iN//U6mQpuyvkvfY7H/902ew2QrnHiznt58KdPsSYh/u4eiUQi3xuikBCJRCKRyKsoePPmKTa2t9neKVn7oVOcWINbVm/0dUUikciNY1HsXspF6Og74J0zKCVIkgSVJthpmC6omhoA6ywSMQQq92KClJK0KzJLqYdivfce01i8hSyTqERS13WwPUo1RaI7ISJ8TkqJ7vz827al7oviSqGFRDg/dOknSfDRdw7KOuQ1WA9eKIRQKKERQoWgY+/R3XlADPkG1lqqumZvb4+mMSR5Al7QNgahJU3bUNehYI5XJDqjKEK2Q2NC577rrJ6EUAjRry1IIRZTEUIi+nBpIYItVLbYlywfkWYjdDqiqWYIF0QYKTWpSvFSoHVKno0YjUaMVyasjENodL9/eI/WGcGe39GYlqZtg4ghBK0xzGZzivIIrW9ZXVldElYyWhnskISQVFWNMZ5U5TihqMuKKq3IdEKmwz5TNVRlyc3qZrIkpTW2Ey0krTOhuK8TjLd4E6YbHJLSNDgLZVXhXUPbBWe7uqVtLbPZFLyBLnA6iD41hVC0zmO8wwuB9Q7bCSgpAuegtQ5rGrRWSKHDLEE3ISAIQo8A8jQnTwum8wMOLr9MNl7DeI2UOdbNFnvV/+z4TjBDoIRDSQ+uwRiBQw52VMO5lgK1bxgvPc2n/uVT7DjN5Ic2ObWmYbbD1vM7bP3eZzi/+0E+8bOLUnT5jUd55De3KAnvP7kGe89vhfe+8BAf/blNiuHdOzz161vspxucuhN2vv1m3nwTUG7x2Ccf5ew0FNc37jxOMdth6/ktnvzMFl9/10f48DuPdyfc4tF/8ShbpWbtxCYbw/Vt8eRnzvOtv/cxHrw9lDt2v/RpPvnFncUxMeydP8eFP36MRy7s8ZEP38Px11iO3S99ik9+cQf0hBO3n2Itg/JbW2y/GM63+998ggdufT0Lu8vTv/YIO7sTTmyc4qQJa3rmt/8NfGudra+cQ//QbZy6s2Vna5vd557gU6bgl//eqesXb8otHv1fHmVrBvqNG5x6c0H5rS2++tuP8NVDYs9JNn4Ezjx3jnMX4OSgF7zAhQvhT9MXv8WUE/RygNk+xwVg4/bbwgtul6d/7ZM8tQOkx9m4c52i3uP89hZPfuYcX3/3h/nwT36n1SzZ+q1HePS5MqzlW0+yZnbYevYxHvmzYukZWWbKV//NP+epGRy/9RSnxiU7/8922L9LLZ/4wGmK+Lt7JBKJfE+IQkIkEolEIq9iwsa7H+SY/iTbOyXrdz/Ig7GbKRKJ/IDTFzeXJxMOiQreY12LEClpqknTFOMdrmmYzWbDZAFCdgVnsej8RpAlWbAq6rzitda0bUvbtoOlkNaaqqpQWqCUGIKNlwUIbzxZFmxijDHgFIn3QzEeCEKHUrRtS9MY5lVJ1TS07nA3eG+/JIQgTVPyPMc5T1mG7vi2NTR1y6VLl5FSk+lkCAG2jWFe1dSNDeKEC0VtIcMxq6pCCairauhGD2vsh8mEkB2QHiowL+dM9K+l+RidjcnyMXVbYTuf8D5MWmhFmqZdcPERRp2IUBQFwvcBv2FdEqVpmoaqKbEIitEI7WA+n3NwMCebzkAIxllOWzekOgg+/cRCmqbM53Pw4ThFltM0LfP5nESGiYgsyzg4mIeg7W4/nA1CQqIExoc1zHKB9wI32B8JWutpTMusnOOqOU1dIz3ddRuapiJNFFgHYjGJEkLCwXhHkqZBSCAIJM4F4cS0Lda0tK0Ox1iq5S8LA1p1UwnVZS5d+kuOrv9trM+RIsX6A3pDo6t/fiQCjUdL261Zg/XqmuLBjRUSDGf/z6fYcQWb7/8oD711qbxbnuGz/+Rxtr92hu2fPckGQHOWx35ri1Kuc8/Pf4h7+/b5vuj83OP8/vYmD2z0B9lj7/gDXQF4cc6tzz/O2Sms//iH+OB7Tyy+Nz3Lo//iMba++K95/EQo2O/98dNszWDjfR/jA29fur4LT/LIr3+N88+dw9y+iWabp7+0A8fu5h/8D/dxYtiYkjOffZgnds6x9dI93PPG77AczVme/NIOjDd56L9/iM3l5fjaZ/mlz21z5uvbPHDrxvWPMbDLTnmaD37sAU52xyn/5DP80ufPc+YrJZvv/9hivd+36JuasQAAIABJREFUzeP/5LOc+bMtttwpTl39UC2t29YM1peFFpbEjyU2T23Cc1tsP7/LfSe69144x7mS8NB+8zzn3V3duQxff24b2GBzM+zphd//DZ7agbW3f4D/7n0biz0qL/DkZz7NM194lKc3P8I9N1/n9rd/n8efK2H9Hj78oXsXkxaXzvDZTz3O9jU/VDJ1mzz4jx7iVK9w/JdnefSRx9jaPsPZ6WnumsTf3SORSOR7wTX/VxSJRCKRyA8KW+5GX0EkEon8x0VfUDWdhUtf1G7b4C3vCSG3qpsWaNuWsiyHonHbttR1PbzfOYcQYvDqF133u/Me0xflraW1zeLLmJCFYExnaxTCik3rhuJ/liVkWTIU4vuvLEvQWg4TBfP5nNlsFgrJxoAUw/301+a9RyWarMjxIoT+NqbtwoUlZdVQzmva1lK1DUmeUVU1VVVTd3Y51rUhAFop0iQnz0bBJqgTNYZgX9HlVivI8mTw7kcG0cR5g3NmEBQApE5QSU6+shrWUHqElGEfUkWe5+SjgslklWM3vYE8zweRYnFegRSaJMm6+w/2Qqurq4zGY6qqoqprpvszlJRU0xk4h5YS29aUZUmapqysHBlyJRrjKOuKsmqYz+cYb8hGQcBQWtO0oXgvcBRZhvCWeVVR1zXTgxkH5TzYCkmNdeCDCxBlXTGdleztXuTizrd5+aVv88orr3BwcNDtGzgHUijquqS1FuODvZPSi3vGS4wPtkizqqRuwxSGte2rJm4GuywXnofRaEySKF5+ZYe2neK8wIs07BUADrpQciE7QYOwzxqPcyGQ3JkG0xz+sm1LW9ffmx/oa3KeF3YK9M13c+9br+oRL27hlpsAZ2i7l6Zf+yO2Haz9+PsWIgKAPM497z5NkWpe2tk9dJiNO952uPu8+TpnniuhOM2733Pi8Pcmp3jwvg2g5MyfbAGLUN1Lr1ziULzuifv46C9/go/93c2ua7INNkTVJfZmh26E0x/4ZX75Yx/6ziICwF+8wE6hOf6Oew+JCGE5bgnTDG17rU9ekxN33zuICADFD58Mx7jprsPrLTc4+bcBdtl75ToHc+c4+40SVu/mZ955eBLg+Dvfx93Hrnr/rRtsALvPn2favTR98QWmnODed24A5zl/fnHs7eeBjU3elgKc58yf7kFxmvt/duPwHhUnuO+dm8AuX/2/L1znYg1n//gMJRPu/pklEQHg2Gne987163wONn7qwYWIAFCc4tSPAFR0Q0mRSCQS+R4QJxIikUgk8gPN7ivA9bqmIpFIJDLQW+4IJNjQxW2MoW4NUiVILVBCggSRSrIkResUIcUQfOy9p+4KpFkWvHnCxEFLVZU0TUNjWuq6BcrBUqYXC0zXPS6lHIQEYwx1XeNag0ozXGs6y6QgdNR1PVgoaS0RPggcAkHb2kPd/SDQUnXvDd38TRfyq5TGWEddteAl5UETsgqShGI0wjlQSpCKfChmeycYZRnWekx3jlDADvfvNHjncK1ZmvSw3fkFRZEhZRdULSVSK1y9KJsKIUBYTDUnH2smqwX1/Ah1JfHCkeUZeV4E0WJyhPGxY+SjCb4xCCVxJlTclVJ4oCxL1JJPv+q64rXW+G7PUq1JpKIxCyGo3x+tNc5axuMx81mFdTUHBw3j8bizvKoo8gmrx45yaXpAdTCjrOfsH0zJ8pyqGiOUIskSnIB5VSLkwoYKkXMwP+DKpcvM53OaWUlb13gsdePI85wsy9BCYoXHGEPTNuQjhrwO6QVCSaQImRO28cF+yloUHikW+R5BQOjXW+K9RQiJkGFiJktS1LxidjBlVDiSVCNJgGZpYqTPq5CgQWpNmiQoUQMSa90hQWz55+3GscH9/+gT3A/QlEynF9l58SW+9RfbnNs+x4VLh9+982IoHJ/44WsUgjce4BP/+OoX13jz37qqFPHtXXYAfmSDjWu0O+rNTTb+7Tbb395lFzj+n51i/UtPsfPlT/Hx/2vC+g9vsnnn2zh1+wnW0uVP3sbpOwu2nt3isYc/zhM3r3Py9ju469TbuWW9eH0FkY37+dj/eD8AZjZl/5UdLnz7W7ywfY7t5y+w93qOsXz3x66Tp7C+/iqLJf1arZ8Xd9hxwIlbOPGqb65z260Fz/zJ0kvp29jceJzt7XOca+7idGo4t30BbrqHzVOarS9uc/6bu3Drcfizs2w5OLFxW1iniy/wQgkU3+KPPvcYX7/6dOUeBa+2R1rwAue/CXALt7z6Ypncehtr7FxjPQuOrF5vp3bZfZn4u3wkEol8j4hCQiQSiUQikUgkEnlNlruyF1MCJgQAE4r9UgmsCMVTpRSZzmitQ2qFUioUdpsG0fn/9+HKxhjKsqSqqiAmNCHZNUkSpJBLUwd2OH8vIAC41tC2LVknNPTvs9YuJiW6Ir5SIVy4qVqqKgQz1/30QWeP1FsrOeewdc1oZSXY7zg68SIEJUuhSdKUfFTgTChce0EQL6w9ZE+zbEXU2wh5FYQSUzcYH6YfnGvxHopRRpalCBSexX33kxKhsB3OWdUHpJlmvDpmdrlASYcXjqLISZKUNCsoxhPGKxOK0Qq1nS6JMzZ06g9WT2F/cJ6qqrBNi9LZYO2UJEkn9CyEnf7+YGEDVZWL3ImyLMmysP9aa9aOvYHL+wf85fSA+XzOeFLjhWM+n5EWOV4LWmvAEgQLH84xPTjg2xd3me1P8c6hbXjuPH4QNXrCc2CGqQ2lw2SK8x4IhX3nwHm6Z0SSJopELo7lEcMxw2TK4udBKUWepiRKML3yCpOjt5BqjRZBSOjXRAiHEKrLrAiCWqI0WikkCu/toZ+tq/NHbhiXzvL4b3yOMy8d6vdHHzvOWrHLXrl4LTTjH+f4G17vwfWrC+TTS0OH/DVJC5Llf7/5Hj70D9d44ref4OsvTtnZ/io721/lKUC/8TTv+/sPcOpYONfG+z7CB2/qgnovXmDr4gW2vvIk6AkbP/l+Hnzniet48y/Y+/eP8xuPn2G3WXpRatZuXqN4aY/yup+8mr/KOr0OXt79jkLGZPXqcr7mto0TsL3N9vNw+q3nOf88FG8/yfGbEk6uPsUz588zfddxdrfPAyd42x1XHaPcYfvZHa7LrKSEawgJJWUJHDvO2rU+J/V1ClQTjh29/ulMnC6ORCKR7xlRSIhEIpFIJBKJRCKvifchkNZaP3RRO+eQhIkDJSTgcd7jbSiEJkmCFx6pw3vqusZ5gZIKhyfTehATqqoKX02wCAKDlDok1eLBGLzsfOTbFu8cs1mYYpAebGvwLIqx1lpsE+xj+sJwn6dQ13VnTdRirKe1wT8/SxRJF/TcTyN475l0n7NdAd9ai1CaREm0Tsmygla2lNMG4yzzssZaj5Qa04RCtrehMI0UCBEKyiGSQSK9pPC9R34QQkaj0bA2EArjrjGHphfwkqapkOUMXaSMRiPybIQS4KWhKIrOrihhlOVkozFZMaI5mIdwaqExZk6SaIQU2E7oSRI1WFCVKyuQhbDmfp+reRn21hK+Otsgay0IhVQgtaKez5A+5CtMJsXwzEwmE266+Q1cevkVmqbBuhZbmRCUrCTOg1cCJROcsbQuiDJNU7F36QpNXVPolHGWIWSKEB5jHGkShA4nwAnwUnTZGWG6pDWOyrQkIkVn4a/CAoEx4XkTaKQWtG0o7AsVArfxoeothMI7Dx6kCHkQeaI5mF6maeeY/AhWKJSXsDSNACGlOQhZagidlrJBCE+wQJLDPg+TKzeKZpvHfu0xzs4K1n/s3bz7zreyfqygmBRodnn6Vz/JU0uV8ySBv3Zn+OQYE7i+mNCUXG0epG86xQM/f4oHTMnOX2xx7htbnH12m92XzvDYr8HkYw9wUgJywsl3foCPvhPMpQuc/8ZznNk6y7lvTtn+4qf5bPExPvSO60wJAObPHuNf/fZZyvE6d937bt52+zrHRgWTQsPFp/nkrz71VxAS/n/mDaEofz0xoSpLuEommbz1DtZ/9wIv/MUFmPw55x2c3AjB2becgGe+cZ4X3HG2nyvhLXewefXSbDzAL3/g9P+HYlJBUQCXgvhxfSOjSCQSiXy/EoWESCQSifxAc/ymG30FkUgk8h8HoVveHQr7FUKQKh3EBEJuQms8TROK90mS4HBYH7qaQ3ZBNoQk9/+UUoLzNE3DwcHBUMB3ziF8sMxRuUbKIE4Y68CH9+d5Sp6kCA/ShCK/Uoq6rDCtHYrXzrkuLNkNEw8q0dS2Ge6lv748z0MgclMPkwkQisKhI79GqQQpg2e/ShLqtsU4y+XLl4fg4X5yAhg6/VWiUUkGSiK8wrUtOk3Jl4KshfBoHQrzumvD9t5jmxbhDwdfG2NoTYUmJdE5RTFCSYelCRkIIkWplDTNyNICr0LmglAK692wHomTWBMmO8ANmRb7+/u4UdjvqqpQKlncS5+F0LQURTFMiPSWTzPn8N4xnx/QNBOS3ioqzXjjm97E/uUrTC+9jG1avJIcTK+gdUqlDKtrq2R5gbUWU4ZMDSE9mdI40TLKC1ZGOVKFTA4pNUpowOGd6YSNFp+GiYzWOg4ODjDOkQrPSpqR6BRHP2XS4p3GKUhFujTBkuCExLM0VcLC8mmkEi7O9qmaOdYf68QHAVe9F4ImlqgQfD3OUq6oOZaFBVIfCt0/jzeM589wdgbF2x/kwz9zVYCw22XnKr/+9becgGcvsLOzC7dfZc5z5Rk+9c+/wPT2+/nI+09f/5xvOs46sP3n22y7zVfZG5mtrRDE+6bjHGePr372X/PU+XXe8z99gNNpwfqtp1m/9TT3/MyUZ37tYZ588QVeeAVOXn6CR/7tGfg7/4CPvvcE+tgJNn78BBs/fh9sP84vffYMF/7iBXjH5nUv7dyzZykpOP13P8z9V+cp7+6we81PfY+4eZ11CXvXXLcpL3xzytVCAqsbbN78JE9t/zlbxTZTTnCysxq6bWMDnjvP9pePca6E47dvLCYLbjrOcQm7z2+x1ZzmVHr4sObZz/Lxz19g7Ucf4qM/ffIaF3sLJ07Ame0XeOECbF5lbzTd3rqxaxmJRCKR1ySGLUcikUjkB5rN7/B/Qi27mL7SXP9NkUgk8gOCDy3eGBM65nubFq2DTYu1FtMGOxtvFhMJUkrSNCVJkuEry7JgSbNk5dK2LbPZjNlsRlVVlGXJ/v7+8NqVK1fY3z/g8uV99vf3mc/nvPzyy+zt7YWw5KbhYH9KOZtTzUtM09LUNaYNIcq9YDGfz4MFUW99ZA1tZ0OkuwmJ5YKutX03fAgMtkuWRUIIiqIgzbOhg//g4GAQDyAICP2x6roeRAml1CAc6DQhz0ekac5oNKIoxp2VkhsyCIQQaASp1sO1DvZLtrM78mFCIk1z0iR8aa2RUpPqLIg3SoHUIFWYMGkNbXdvvb1UWQb//qYxTPdnXL58mf39/cHLv7+XqqqG56APbu4tkMK/i24NKloTLKvabj9GoxFvetObSJKEiy/tMt3fZz6bUldzcILxaILwML2yz5VX9rjyyh6zy/vQ1EyylNWVosu6UAgRrJn6AOkkTSmKImQmFDnWO6rGUDUGL4Lo4L1HdUX/ZWut2WxGXdeDJRJe4f2rLaq896Q6IdcJvq1oTY2QGi80Thx+b/9nAC0ViQr5CmEqYTGp0O/zDRURligv7R/utHdTzv7242xdZSUzedtpNiTsfukxnn7p0BHY+r2n2XGGYydv+872QenbOH1HAeUZvvD7Fw6fd3qWx57cBgpO/+gmsMYtb0wozTbPfHnncNiy6UKV5THWVoFbbuHmmWHvT7/C2avGHaZXwv2tHbum0c7Vq8HelavmDqZnefTzW6/js99F5CZ3vf3a67b3tc/x9IvX+tBxbrt9DS5+jd//2i7cfBsnO7VA33ILxyn5+pe/ypQ1NpaFof5cbpsn/vezTJefg3Ir7JGBk7dfS0QA0LztRzcpmPLM7zzFzvLGTc/yxJe/g13S6yT+7h6JRCLfXeJEQiQSiUQi12HtTceBHbb/4NM8+h+Oc/IdD3LXW270VUUikciNweIx3mFci++LnT6EA1vbYp3He4nwEq18V+h2aG2QXfE7FOZrpFIkSYokTCQ456iaksbUOGdwzlDXLa2z6N4GCDlkLUjhUUoEi6LOnqjIU4RxSBWK7NY4fFeEV93567bhYD7rbJoc7VLQsg8VXframO86xIVSqCTBI7tO+wyhJCBI84ysKGjblqqqmFclrQ1Bxl6wKEYT/mxMg/eH23j7SQgvBDpNUF6GgF8vsD4IBMqHwvdQoBagtEYqcDasq7euy2XwIesBj0wL8KFArbIRQmlAIJSmbVvausI6A42gNvUgFDjv8UisA6lC5kOYEhGHOuatbUmSEdaGYnzbtqSpZjzJsd6QphlNU+OcoGpaBMG6ys2mpHnCaJQzmUy4ePEifhZEmlFZIuWIcrof9qic01Ql3loQKVIIdGc1hXVICQKFaR1ahukEpRJ0FyAdzKGC+KG1RmkNQlE3BqmabtImhG4bK2ldQ1nLzhLLE3Sf8FQ416KEwMFQ9FeJRmDBWUg0kiwICr7G45FeDFkJHoEQnlRL0kSQpYq00jSKEMa89DzcUG49zanxFmfPP87D/+wMt51cQ9d7nN++wNStsXasZO/SLrsXCVZGxWke/LltHvnNLZ76lx/n7K2brI8Ne+fPceGKQb/lXt73Y9e3DgpoNn/2AU5981HO/uGnefjr65zcOE4x22Hr+V2Mg7UffZD33Brevf5f3M+pP/0sZ7/8Kf7nZ08M13jh+QvsNbD+rvu6jvlT3Peur7D9hS0e+2cf5+lbN1kfQ7m7zfkXSxhv8p6f/M4mO7fdeYriubOc//zDPPzsbZxc05i985z75hRz0xprsz32+hDov/bi/9U5+d6HuOv8Z/jqH36ah58La9F+a4vtlwzFuIDZqz+zvvlWJl95hr1LMPnxH1lc9823cEsBu6WB1bdyx1VLc/K9H+DuFz/NM889xsPbT7OxuU7RPxsGJnc+MOzRtdBvfYAH7jjPo889zaf+8VlO3HqCNRP2OCkK+GuaRMXf3SORSOS7SxQSIpFIJBK5Hhv38sAdF3jiGztsPbvD/lvu4663vNZfhCORSORvJrYTEYw3qCVrHe89rqnx0uFlwf/L3tvHWHbWd56f5+283Fsv3WW7IW3TTuKwbZZi4yAc4WiMhBFmglGcjdmVoxhF1iyrxMpYOwQRNGSk7GqiZTMT7w47ItKwuxmEo3QSgmItJpNmaJQ4Itk0Az3jsnArMcEduzBld3V3Vd173p6X/eM559Sttk3bwcRM5vlIpbpd997z8pxz7arf9/f7fqVWZEb2YcodWa5B6L7wvF9Yz002Fneran9KYOh4d87R2Y42BIzL8QSU7YWEvs7ati3WCWyAts0QzqNln2fgXLSemUyiHVIfzly3vt8HeMK+KMJ+1zh9YV8oRZaVZKYgCHnAiklKQV6WZFnG3t4eXd+hP65XH/Ssdd8h2zUE9gOBo21TQCKIg+Khn0JQWAveBYSIBW7pFLG53+NCwCNRen8qIrgYON12Lb4vegup0WaCExqjFaIoCUISgkdIQzOb49pZLFoHxpBrY0y024kBDlHocQ6InfzR+mgoeMdJhMWg7CyXTFdWaZqOMivjtfSSpvX4YJlUFZ2P61IUBSuHVpnP5+zO9vACZrMZwUsCNVkWRRcRLCLqPGQ6G6+V0fsd/HVd9wJD1l+f/eeG6OI8N7j+/uo6C1QUWT7aaHnvcd4xb+qYReEEbsg4AAIOhxzFgeAFSucY4VHBg1YoX+CEITBHELNAGKZKZMyUkFJiFBSZJNcKaz0hMAo0w2frVSM7zt2/cDfl75zk9LlzbHzlHGRrHHvLXdz7jpvRf/EAD3x+iyf/xsI18f4u33gPH7r/NJ/7zEm++pdn2PKgp0dZf88d3PljN7D8UrSRcp27f+lD3PjZE5x6tA/0lZrlo+u87cfv5NYbFn4Hy45z9wfv49rP/AF/crY/RjTldevc/vZ387Y37k8ZHHn7/Xxo7SFO/PszbJ49E+1zsjWOvfXd/OQ7buboFZKW9Rvu5h//dMmJf3eac9/Y4Mw3QB8+xs0/dS+3vUVz+n9/gJPnn2SzhSPZt9/Wd4XsBu78Jx/i+s+e4ORX4lrEtf9J3tZ8mo9//gXec+xGbiwf4XQF1//AosfQDRz/ITj9KCy/6U0cu/x92THu+IWPcOOXHuLhP36cs1+JZkT68DFueefd3PHmtSsUmUrWf+ZD3Penv88ffPFxzj12hnN6mWP/4F7ed+1pfvW3N1heXfnbr0X63T2RSCS+q4jwqv6GkkgkEolEIpFIJF6M7e2L4+O1tUOv6v7//YO/Ql3v4V2H8AHbxkyAtm1prUdlJWblCF5Hm58Lu4Hz2ztUbYUgFncH25+st55xbcd8PmdezbA25iPM53NmsxnOORobO/K1yhBq30oJYiF+Pp9TFAVlkWGkQAUoMoMQgq7rmE6nvOY1r0EIwXweu+Ev7uwBks5F64t5XXPx4kW01pRlyaG1wxRFge7DCYp8wmu+7yh1b/9jlGI+nzOdTlk5tEbXdZw/f57dSxfY2dmh67qxkN1ULUVR4FzHfLZLCI58MqWcrsYCe9egQp81IAXBx87+tquxbRMnDkJA6wxjcqarK1TVjGeeeYbvP3YMJTS2D5LOyglt1+GadhRkysNHEMZQGsPSNUfICwMEup0580vnqfd2KMsc76F1NhbjtSbPc7SIeRFt25JpQwiB1x27dhSDQgiUZcny8pSLFy/yzW9+C+ccS8sZh1+7xoVvXuTZra0oPChN8AKtBIdWVplMC5bKJVZWVpjP57R1w18/+XVa16KUQeloj3T48GFWVlaw3o22SUJFy6fV1VXKLCd4T9M0zGYzVlZWmE7L/cwN2+0X5XVc46rpMHmOFPE8M6PonGVnZ4c8z3C+YrnQ3Hj9D7K6fIh2/iy+Og+uprNzRIhCwpAZUs0bzm09xWvfcCvf91/dzIr32OopRHsJESAIgRJ6FDaCF3TOcmHnEs9e3OOZ87vsVG0fZL6fPRJC4Jc++JG/0897IvGq8h8f5MO/vcHRd32I+9/+UuymEolE4j8f/i5+p9/Z2fmubHeRNJGQSCQSiUQikUgkroizIXrLOw/E6YHB8x6hDni7e+/pOtv79zsEbnw+Tiqo/jVdDNHtPf+LohhDfo0xoGIbs5IGqRVFUaCUGrvitdZMipIyN2gVyJTGqPgnjrWWsoytxk3T9IG6tu8+d2OOwfBdCBEL1f3UQZ7HTnWkwHqPC7Gr3NpYcF9aWqKqqjHDQEo55hoM21NK9RY5NmZMCDmGJocQ8MEjgkBF/53RNghAKYOQbgztHbY75FMM71dKYbuOqqpouw7R71sqGS2k8hJlFF3b4l2L0gLbtHgbbZCiJZFD9QLMYp/ZsK/l5WXyPB+DpqWU1HXNdDolhDA+N1z/Yb2zLCMvJnQBdnd3yfKc1nbkzlBVFUVRsDxdIkymVNWM8zsXo5WTUmgtadoZzudkuhztm4K38TitwylH009CDFkHs1mcsvDW0Y9xxPXygdaHGLZcTslMhnOOyrYIFTMKhvvBe4m1Lc43faC2wC9kHRxoxRM+rmM7BwJBAMJgfUAJj3iBP7mFEOTakGmD1sNnZz9sOZH4+8oTn/mf+c3Hlrnl7g9wx6IFkt3k5B9vAGvccDyJCIlEIvG9ShISEolEIpFIJBKJxBWJndIx2Nb5tvf8j2KB1PpAeHIsnsdOeWstUqgxUHYQFAZP/aHDXSlDngu03u3/rUD1IcMqI8/zUUhomoYQwigiFLmhMBqlJZnKxm5xYLSsGQJ1o5ggxuMbiuXDVwzhVaOo0LSWIKJoEZyn7sOTrbXU7R66z18YRJJBmFBKERx9cK/He6IdkQ/jvoO3BARZVoz2O0OAsFQi+uYHP67rUOjfLzgLjI75CbZp6Ww3BkYrrRFao0xOwNLOZ0gZKDJN27RY2yKI5++cQ/iDYtDiOcUA6BJj9IHrO/j5a62j8EO0HxqEBCUNusjwrQcZswVaG/MkZC73RQMhec3V1xDQ7M12kNLjfYe34K1FZhBCH4At4oTKYB01XNOyLMf7CsC2HUNGspQSJyROKKQpCL3wFQPCmxjQrDQI6LoO73Vv9VRhACH2g7EHIWHfhig+7poaERw+KDwSkHjh0Qu2WcOaRuFMkmk12jMN9kmvuq1RIvFd5Ia3vIWVLz/CI7/5yzx27EaOrWlYyFhYe+tdvOvbR1YkEolE4lUkCQmJRCKRSCQSiUTiykiJ6Julh+LzUExeDIh1wfcCQxinDpRWyCDRmYbewqVpGuquxbFfNBVKIXWGUjGU1mgzWtpMJ0tkvWChpRwFAK3BGEU5KRBCUGZlLOLjmc8q6rYBKWhtx2w2wxKthIYcBohFf6XU2Pmv+jBfpTVVZ6MAolXsiO9zHZqmoWq6voC9/74hQ6FfshhE7eK+lNKAjALCILIgAE8IAoRHKlBeIYUmBIf3XV9o3p90GISEIaAXiGHLNh4rQiC0QvTiTdfU+LpFyYALOU1T4boO4S2IgBBynPKIxx63LSVoHUOugwAh45RD0zTQd+lLLcAG8jJeN6kDNtgYOi0lShqE7MiyLIo4QjDzjjwrcf1UixewtLTEVU7FayIsu/MdpJR0tiGzZW9XFa+XzARtU+FdR13P8QRW80MYY+hsQ1s3WGdp27a/dwUuKHS5zCQ3hCDGCRXnHME6ghQEH7DW42yg7WraTiIEiCFDwdFPiBz8aAQcVT3H2ZZOaPABQbw2IXgCQ5iyjNdYBJSUqD4YXIiYviAQ+9tMYkLi7yPH7uADv3gtD//eKc48FfMmLs+2SEWqRCKR+N4l/Tc6kUgkEolEIpFIXJEhtHYQB4Yi7WhnFGzf1a8RMsO5GSE4nAf6on8s8Af29vZiUd/aPvcgdogPFjVZFjvOC5PFbvG+K97z7BJ6AAAgAElEQVR1HUqpUUSI3f4OqcCFEuFjp7/Wmq7rJx46z25Vs7M3p7WxM15rcaA7fBAArLWUl01WlFkeC9o+Fp2zLGM2m1HXNbZ1dKIvDvfiRpkXMefAdqN1U9yeY/jza7AwCiFA3xkfhBwFgiHgeLELPssykAIhFJLYOW+KbNzGYOPjvccLCFKijcLbGtt1BOfwLqBFzJ3onAUbgJYsKxA+INQw6bBvPQUwn8+BKNgYY6KllY8ZFnFiRLC0NBm7/FvXsqfm0TJJC1byKVIE9vZ2aOoaPZ3iCf0atmRasSw805WCa8Q1MbzZdnSu4cKFCzjb32dB472n1Q3GRLsr7z3GGLIsYzKZMJ8Lnts6HwURIXDWYhEIIxF9YLZ0gda2iADCh3idvCOIaOHlO4dvOnzb0GERtsHZGK7snI/hz0IgEbjO4qygrebU8xmmnCBdC7YjCIuUAlRvReUtIHvLrDj5kkuNNpI2uEErGqdOEom/j+irbuLOn7uJO1/tA0kkEonEyyYJCYlEIpFIJBKJROKKhBAIxO5t50LfES/Ggq33Fkns7hdEYcH5DkIYi+lDobyqKvb29qjrmpWVFZQqxsL9sM3YwR+zCrIsQ0uJ7TvDh8mB6NffF/EnDuEDrYjWQ87HLIOm6bh0aY+m6YhuR/vHvZ9HsD9JsGjT07YtWka7oqqpUD6M9jnT6ZSu7bMWhB/tlIzSUcDwbrSpGWxtrLWI3q5pFCucpWmaaJ2kepskGZBB9hMTEtGPgiixb70EUTQQfUZDCHEaQSGQUqGUifY/TQcu2ju1TY3wjiA8+NBPjtgoTkhJlmej3ZNz3X6gcJ9nMORXDN38TdfGDn4PRVGMgoe1lu1nt4EoHpVljsRT13Pq3mpqWF8rJSEowsxSTuJkQlZOUEXG+fPfYufSNlrN4/0jsjGQWGtNXk4gSMoyBmDHUO05bRtDrgHmVYM3mtWlFZTR/ZRDh7UNhTYYpWm6lqqp8cRpg6ZqsW2HllNwDd67/nrF9fA2BmqLEK2a2rbF1jXV3oxSSmTXIG2LVAGPB9wYtjwIb7KfSMiMItOaxnmC28/sSBMJiUQikUgkvtdIQkIikUgkEolEIpG4IrGjvcMH24sCOtrdCDmaEwVigVqIgBax8K2Uwls/FlGHQnXTtezO9hBKIrUk04PHvjwwKSCCxNtA5apY2Nd6tFWKBWnfPwaco6Ojc3F6oGpaqqqJ9jk+BieHwFiMDiFglEL1AdDGZEwmU7Q2feG9watA17R08xqUJlMZRT4hz0qaqiX0hXytNTvtDla2NF0di/xBHhASvPe4zo4ixtjB37ZxTYPvrW5Uf/4G71qE0IQgkFJHoYC4LnCwe91INa5fkAJvHb5zCAISQVdXVK5FZwbrOqyNoosSHVIrVBunFWxwY+7AEFDddR113WGM6S2tArZtuLS7S5ZrJnmB956yLAnOMy0ncYLDaCZFjlKKumpRqChI9aKDCx5HwLkoDE0mS0zyFZaWlwGPdx1SCpp5g/V2zOUwJgYaC6mx3mEuato2ijLexckC6y2dd8igECpeIy8EzsfMCg8Yk9HVDdYFWtuglcQKj3MB4eO6eSkJ2oB1COHGdQ8+HrfzAeEtbVPR2RztWkTw+1kKgfi5kL15kRQoITFak2tFnmmqrsP2wc2QchISiUQikUh875GEhEQikUgkEolEInFFgrfRS97FwrnQGtcHATMExDqLo0MRYpE0zyg6R/AOJSSS2JU/FNKreQNhL04cTA8GMo+ZC32eQtPFYntZls+bXhheG0OUA7aL/vhN09E29sD2Blum4RiMMeRlifeepaUlptMpUsSpAtt5nG+xbYtrWkQG02LK4cOHR1umtm3HiYamaei6ZiwCiyDHDnMt96cIhueHyYt47AGN6acNAoL+3HrBwHs/CgXeRhEl5igwThSM5znY4jgfi9ghgADbddi6IiszXNcSvMP3aykJ46TB4LGztLQExImN+XxO1wcTDwKMCIGLF3e4+shVsUjvYyFcasHK6lIfKC0oyxJlHNdco1hZWeG5557DucDy8ip12+Bch+ptlaSEpaUJymgCDUUu2dnZoatbmqqhrusowARLF+LUyryCEByzWRWvqw9UVc28bdBZFLw67zC9iCB1FBaCAPprEPqgZYKCXkiyXUduBMZkCCGxoUMHhwgxdNrjcQshyniHtx0EByLmXiyGV4/fRbSoypQmyxWFVmgpsOPr9t+XSCQSiUQi8b1CEhISiUQikUgkEonEFXGuI7gOJQaLogBhvzAulYAQEMGhtabIDM6DtYHW1gdyAYait3OO2WxGOclZmkzQOv55kuc51kZrIpHHIOCmaRBCMJlMoj1N16G1Rkof8wNg3KbzLgoB1hKkZDKZYK2jte3Y/S+EGLMXismEEAJFUcTivRiK2pJyMkEE6Jo2hkH34c+Dlc4gSrRtS9d1VFXVTzeYcWpiMY8hrqU78BjiOsb8Bo1SEjUGNstRfNFaE3prIO9igd/25zqsq1Iqdt07hzTRfse2Fh8cwjvqeg46ELo2iglSoaUZt1HXNVIyWj2VZYmUkkuXLiElo7WSUYJMKy7Oa6zdF0dmsxmCaHUUcw3iMRkhWbv2ara3t9nb26NtGpRSZHmJFAXBt+RaRdFBCYwRrF21SpbF9QvWUzXbtG28hsxizsCwLk3dURQTiqJAyxiGHZRkOVuOhXsp++kXjQBmdY0oc7RVVE2N9Y6qbfBOoaYFIoDvLEGB0HK0pOKya6mMjhMGSsXg7BAQMtpsif7P7UVRIIT4uREhiktGQ64kSoIXwzomESGRSCQSicT3HklISCQSiUQikUgkElfGR4sb631v2+J6f33wgRg8GyxSFCgJRWaw1lNoSaMVDAVw72NBVxmUMqNI0NqOoihQQqPzglDV0X7Ge3xvnjTkFwgRsFbivcP3Ybl10+Cdw3YeEQJ1awlCYIzCE/C9iNE5hwKUECitMXlOnue0bRuL+j4gjcSYvLdCCrS2i3ZDfaE9hDAWtIdzAsbpiKEIb303TgkMgsJACCFmSAiP7YWFLGi6ronbU/uWRUIIpFJjeLNzbrSYgthJPxS3bfAoIdBDsLCWdLXDdwsCilS0QmF9QMnel78vhgPjOUWroQkQrzfK4CQ0TUsZDDNZ42xgd2eGkh4ZPF3bouVgzaTIMkPb1WhTMm/mOBzaSGwneW77PEpritxgtCQrC2zwBNfhnSC4gPAKrQ0rKys4BAjP3u6cruvY6+a07RylJLUNmGoW7yHivbW8uoRzHu0F3oYofgFBQJZl5HmOMmbMVsB5pDGUhaHI4mQIfW6CCCBk/MmQcREXK+AF0NtRyRDvv2j7FfpsEY8QkkEgiNZTIFW0o8r6rAYh7DiRkKyNXiqW7a98mi+Xd3P7G17tY3kxtjj16w9w8tl17vnoPay/wluvvnGKE79zirMX4vTT0Xf/I9ZP/9/ftf0lEolE4r9ckpCQSCQSiUQikUgkrsho13OZ5YoIIC97jZSSTEsK3dFpRaU11geCjQV3rTKUUqM1UFtHy5qyLNFao1XWF9/BE2J3/QHbIzFOH8QidyzYOuew1kdRo+/0V0pRty3WutFffzgPk2cooxFK9lMC+4V7YwxBeKpqBjJaOg1TEtbaAxZJ0FsP6Ryf+/2cgtDuF+fdEIocFgrR+0LAYHPkvcfLQNBE0UQdnEwYMgsAnO/wIeC9RetoOdR2lmlZkmmDNBoZxHh8g4ijtelDouOxOedQUvcTHnLMoBimFIYphEEUaeoKGXq7oKxkVlf48w1agncduSn6bcV8g67zODq6forDGEMrO5577jmWl5fxLmNS5qOw1OkOL6LAIYhTEbk2mKJEKcXFfIe9vTnNjqO1DXXX0nrIgsMFAa5maeUQ9HZJ+IBr4zUUQqCMZpKZcdrCGENVVTH42CimZU6Wa6SCIIaA7+GO9wc/F85BkKA0SijEcD96QZCBIBwhyIXrHWDhs6SUwRhNpiVSapC2DwVPvBS2v/hxfu2PNll/392v9qG8OvizfO6TJzlbaY4cv4mjU7j+B1epTr/aB5ZIJBKJv48kISGRSCQSiUQikUhckaEIOxTDoZ9C8A6heguXvtiqJTglKExGpTuMkrS2xdtApjShkGgZi7bzEMOG67pBCDlOHWiV4XBYH+haizaxkB1tfhgL3CF4vHMEHzv7vY8hzzG/QSCsY97UWOtwzsbpBO8QSpIVOQhJZx2ttUgdbWoGG6YYMFzjgkNYMEGjhGY2m43FYq0NRseJhklZInuRoOuasSs/5g5EYSSE/XUUUsbcCetA9VY6IeC0662KQApD8NFTfz9fIWYJONfh6a2iAvjgD9gglVmObWOWQ7DqsqkIQZZlfY7BvlAwCB/RriieixQBrQReBLSWSBXXSHlBlsU8gUuXLpEbhZYKGVwMPPYdUkt8kDS7M4LwfV5CnALY29tjMplEmyj2j73rYuizUooiKynLKU3TMPWWwmTkOkfrSzjhCDjm9QwhFZmO0yW2asn7fQz3attUBGfRUjAtS1YmOVprrLUYk9PWDXk2Jc9N/DIapXpRAAgL2RYCRRincuI6SaVBxuuL78WC0IsQ/WQCBIblH+6BaBMVMxKkZD+zIU0kvCSst6/2IbwEjnDbL36U274bmz7/NE9WwPE7uf/em/sCzxanvhv7SiQSicR/8SQhIZFIJBKJRCKRSFyRRU//oYjvF1qnhRAEH+KEgpIIQV8k1UCN6xo8mqXlFWzToqQc7ZGs3S+aaq0pioLV1dXoXW/dGGYM9EVyOXaSh+CgtxrKsoyuc9i2Ayl68cDRtA1dZ5G9fY9SKtra9EX+4Wvoxh9sji7t7MTcg65CCs2yKJD9JEQIgdXVVSBODhhjmFeBpvf+B38gI2GwL/LejZ3/SgtcG7MeFo/H+1hUV0ohAihpAMb1HqYLrLXjxELbtgQBSqvx+RACXdOiEPg+tyEQz88YE22H2pbgYs6EEKJfw268DoNdU5zQiL7+r7v2GvACnRmQGfOqoms1S0vLeBunGHZ3d9GZQgjJbN5g8oJJWVJVFc45sixjaWmpL/b78byn0ylaabIsi/t0Hhd8f63jscxmMw65JYoiQ0vFzl6B1JqVlTW0MjRFg8my/l5R+GBp5pbs4g7TrGCydngMjR6stbquW7i/4jSClDKKCIMgcFlxf8iqCF6jVRE/ByGA8/h+ckEJSZAvLAoMwo3WEqUlIjjgoFiXSLwksjIVdxKJRCLxXSf9vyaRSCQSiUQikUhckVgE3y9QD0XtEAIC+o74gOzzEmL3dZ8P4Cy27QjCoaREi9iJrYXESIXs/z1sVykVi8xG0dQtvulQKhaz8z7TwJjeBqdrCM5DmMXgW2raukEpjRCCrrfo8T5gTBY99JVC9gV3QjwvbQxa69GyaD6f9wXyllZmaLVv6aR1tAEqy5KmacjzfFyL4fkQ3HhOw88X129YmyG8eTEwWvSF5LZtEcqTmfhva21v32THYj/BA9H2yBPIjB7fO+nFhsEOyZgYgD0EM2utRnumwTppON6yLMfjdC6ei1ASbQzXXH0Ybz1ZXtLZmDdgtObINVezu3ORC+e32dnZoZxOqOqW1nZMl1f60GtLU9VorZlOpxhjsDaMVkqLeRJxOsHi++wKpSQ6zyhyg+sKiszQVMsQNCbXTCZTQgAtJUEoZABtJK6fXKmrGW3TYNsOURZ0bUc9r8bcCYjigfMdQuQIMQwWXHa/95MO0U4rABJpMjyO4CTBewTDBEL8TAgfEGo/I2H4LmWczjEyhjW7795H+OVz4QwP/c5JTp/bxnpNed2PcOfP3IX+3Id58NEF//1nT/HAr59k60338NGfucyR/8Wes9uc+ewJTj26ydYsThXo6RGOvuk27n7PTayNlYo+X4Dbue+uis/+P49wrtWU1/0wb6z/A19+Lr5q41Mf5sPA+vs+yj1v7Hdx/gwP/95w/EC2xrE3337Z9oHHHuTDn9pg/ac/xPGN3+ChR3ex2RrH3/M/cO+Prr3I4gy5B99uAYc1eoGMhH5deOcH+PkbNvYzDnTJkRtu5c733sYNy99u25ft/9EH+fCHgWtu5wO/+OKpCC95TQD8Lk986SEe/uLjbM4soCmvu5HbfvxObn2hg6s2Of1Hf8AXv3KO7RbQJUffcBt3/MStzzuX3Sce4aE/PMXjT1VYQE+PcuPb7+DOH7uBZfn8TScSiUTiO+Nnf/ZnX/JrP/nJT77oc0lISCQSiUQikUgkEldk30povzC+mJsQQoghszgCGiU8Qez78zvXgTQ4FwNlyywnH7rOQxgzCKQUSIag3gwpFLZpkcRCuFIKk+dMJtHuhjl4ZVGtHju5fW8hExasbYbu70GEKLKczlmCj0XizMSu/6ZpcM7FLISuxdoOVcb3TCeTschveuscqRXKaGw1j939wSFEGAOXRxsjLWnb9sCaCiEQWvXhu/2xqtgR7+zQBW9RMk5WuM6OYkTXdeP6SMAHi++L3BCwbQxm7mxL17ZEOySJD2J8DcQJE6Oi8GFt208GuF4MCeN+dWYQCDItyTINWjCZLtF0lqyckBcFhw8fxlrLc89tM68bgoC9vRxhonhjjEFrSeitqIoyZh50rqWqW3Z2d5lOpwCozKCcwLqWpo5WR3meo83+VEnXefKsZGmiyIoMYzKcC2ip+oDuffFHikBT1VSzPaqqYnl5StvVtF1NEB6hwPdrFEUZjxAKguhtjKKlVBDgcXjRXwcX0KpAm6y/j23MrCAghCM8LzjZM4QpC6Gi0KDipIdWks5axiyFV5NvneJj/+okmx6Wj61zw9Ww/ZenOfEvnuboVd/htqsNHvyXD7IxA/2a49x0vIRmmyfOnuPcn5/g156p+MjP3cKB2nP7ZU78m22669a5aXmHc/J1/NdXO3bPnuXsZsXa99/EsTW4frXfxWMP8muf2qBCs/z969ywpqme3uDsn5/g1x57nHs+cDfr5cHD2vx3/xcbuyXH33wDPL3Ftde9mIgAUHLt+k3cdOkFTu9vNjj7rIWjRzlyhaWwmyf5xBc22Fo+xvqb1+ie3uDs2ZN84v94gjt/7v3ccs0V9v/MFme/tkl1+Bg3/cAarF5L+SLveFlr4rc49a8f4OQmkB3h+JuPUjbbPHF2g4c/8Thffdf93P/2hbNbvKarx1hfX4PnnmDj0Yf5xNef5J4P3jNue+sLH+OBz2+CHHIdLNtPPM7GZz/B42du5/77buNIEhMSiUTiFeWTn/zkSxITvp2IAElISCQSiUQikUgkEi+RRRFBCDF2VnvvCS4gvcNbh5Uy+r339j6xy9sihaRuG6Q25JOc5eVlZvM5s9mMvb09llaWcc6OVjsqNxRFgVuKEw2yzy8YRIEQAp1z4GPxvm1bqqqKYoLbnwCIAsO+bc3S0hLT6RK7uzu0rov5CtaOtjt5npNlGU1TY4xiqSwp8imHDx+maVuapiGEQFVVrBxaBSVpmoamaQ508A+d/3megxe9oLI/neDcfld60zRj8V5JgzTx9a2N3fLBedBEKx0RMytCCCihxykOSSydywABFy17XEvd1eBbVN9db4wZA5Wdc2TajJMOg8XTsG51XZPrhVBmIZnPZuRFgckUrQ9MpyXT5QlCa3SeYcpo81NVDbuzitWrp+MURegs9XwGSK5aXiVIhd3bZXd3l0Hs0FqTKY3webSYmu9FK6lMg5MEYgbGxVmNMhlLQpFNShiL9jlN18brbxeCuOuO2WwWRSIR6KxFajle79BP1ATfEZxFCEnwgsFuKE4lRKslvzDtkRVlFHUCON8gsQQCwWuCDONagu/zFfaFONl/VpRSZEpTE4WI/QjzV4MtTj14kk1fsv7TH+CeH+5L+n6XM7/9ACce/c62vvnFz7Exg6Pv/AD3v2OhGO3P8fC/+DiPfOM0p8/fwm2LgsWlbfgH9/GR9xxb+OFbuVo/wNnNiqO33s3d/SQC1WlO/NYGVXmMO37uPm59zf47tr/8m/yfnz7D739mnRt/Zv1AQWT70jXc9c/u5eYXq8QfYJnj77qb45f/+Fun+Ni/sjBd557333ZFIWH7sQ2O9uc17DYW2p/goc+d4eafvelFijb9/p89xQNf26S67m3c/d8Pkwhbz3/5y1yTc5/7t5zchLW33Ms/fu/xfXGiOsfDn/g4j/zRg5xa/wC3XQNgOfO7UUQ4+o77ue+dR8djjueywe8/fJb19x6Hcw/zbz+/CYdv5t777+L4/oY599lP8PE/PcmDX1znA++40solEolE4uVyJTHhSiICvLq/nSQSiUQikUgkEon/DFn0ix8eywBhwR5mmA4YcgIgdvvPZrsIAWVZUk4mY/G8qirquqaqKto2FoGLomA6nTKZTEa//qEgPZvNeksa34cYx/DeruuQRo9ButbHPINhQmCYdCiKYiyo13XNhQsX2Nra4uLFiwfCfpeWllhaWmJ1dZWVlRWWlpZQmaGu6zFTYFiDIbB4aWkpFpaHoniWHfg+iCFDIXmxKB1/psfitjFm3L5zDkRcy8X3uz5/IW7LjtvXWvfrXlFV0cJn2M8guiwGaA85AXmeR1uo3vJnmIBobYdSitl83ucHxD8nh4yH+XzOZGnK6173OlYPHYrTG2LfGuibTz/DpUu7+zZMZUGwjvnuHq6z7O3VPPfsDjuXai7u1FzYnlG3nvl8TlVV8XvbRBsoqQkCTJZRLkWhIsuy0fpqOp1y6NCh8T5o25bOxiyEQexBSbwL4/uklAg8uTYg+muqB8HMHxAAPKG/vzzFZEpusigguHoUsIbrFkKc01kU4hZRiGhvpHuxYUGke1V4doMzzwLX3cadP7wwFyCXuem/u5Pj31EVYZsnv9mh9Tq3vf2yYrE8xvXXAVjwl79vmTf+N8cu/+ELsvvV05z1cPQd7ztQMAdYe8sd3HoNVI+e5qvtZW98/To/8pJEhBeh2uDBf3OSTY5y+/94z/MmHl6Q8mbe9e5jB6YIjrzjvdx6GPjalzi9+x0czwIvb02e4PR/2IbyZu78qeMHJxzKY9zxjnVgiz/7/871Gz/Nl74GHL6V9y6ICABH3v4ubp5q9NbTbAFPfPnLbFNy808uiggAJcfefRvrErb+4jTnXpnTTiQSicRlvJhY8FJEBEgTCYlEIpFIJBKJROIlcHkRNJY8++ecx4vYDT8UQF9ocsHaFtpY0EdKVJGN9j/WWrqmBaORvYXRELCslEJnhtY7ur4QrrUZ7XIUAue6XsDQZKbojxeEiMHPprcu6rqOrmlxhUUEgbeOpqqjTRKxiN41La4PO55MlijzgiI3IAOmyJn6Kc08FuHn8znSxD+rolhQkOd5FBr6vAixUDsexBCI0wVaa5zvIMj+30PHukRKgZaB1sbjEYC3juAtznfPy6tYzLHItR5DoIUQtG2DzugtgTpsP+kwiAa+t+8ZrkcIoc9/MFGM8VGYaJoG5zuqqiXLKxBmLM4PYkmmDaurq1EYkfEaBi+Yz2tyI8iygsl0maKc0raWpaUltFLUTUfdNggluXhpB6UkS3ZCIApATWtpuw4pdbSlkgKkRCDx/mD4d55l5GUBUuL79Z93NRAnK7rWReui/l4ty5JJmVFmhjyT4CzOin6SIIz38SCeDEHLUmjybIoSAuktwreEYAlS4oMfr4kYbMFYnOoBIaNYkRuFMaoP3Pb4VzNseXOTLWDt+HGe54SfrbP+ejh79m+78TVu+Ucf4RYAW7E7u8DW17fYfPpx/urrZ3niqRd73/Vce91L28OTfx3L0PXGw5zYfP7z2xbgHOeehJtfv3Bk113/ty+Q2E1OfuJBNmYl6+97P7e95spvAeCHjr+AMHOUG19f8shfnOPJp+CWN/xtD2qfl7Umh57kyQoon+ZLnz7BVy9/cbVNCew+9TS7HGP5qSdj4f8Hfoijl79WHueuf/bP+39ssfHXFVDy9J+f4MR/fN6G2c6BS0/y9C4c+7YZEYlEIpH423L5ZMJLFREgCQmJRCKRSCQSiUTiJfJC3dTDz51zqIWO7eG1Sim03s8vsNbig0XpDJNlUYAQAu+HsF0xFr9jsTZ2yS9OOQyd/tGmJyfXCuu6PrA4WtUMNkNC9N3eShOCp6oqMm0oinIM+G2aphcndB/wG/dpsoyiKMlyjdRR7JBZTlbErnfXOXZ2dli75moghg4vLS31xed6DOaNxf1woFA/5kr0jwcrpEUxYJhwGKYOQnDjxMHlX3GfB+2cdC8mjNkRfc5AVdV478ZJBiEEBMb9Da8dJiSstQijMYVhNpshpWR3Z4ZUOcurh6Mtk1RMywnKaNq64fDhw3Q+sNfWqKBQIm47z0qMzlldO0xZTmiahqtfc4TZzi7PPbeNc9GS6dLOHoho7XRodZmiKOIURTNHq4yqbsf7rPN2nKAYGEK1p9MpSNHbNLXj5EXXOUwmUcpgraUoCg4dWmFaGgqtCb6la0IUWgCGdRICIRTeRyFGZYYsn0TByLcE24IIfT7I83NFhs/H4sSBlgqtJbmOwk/TdC/6Wfu7YOu5rf64XuhZTZl9hzuoznHqxKc4dXYXu7jl6VHWDldsXXjht73w8bw42984w/Y3XvQgqC6bSHj+9jd48MMPsnH5jy8PjvZbnPr4xzi1CUff+fPc88aXPtZw5LUvbOGzvLoMVDEQ+RXkZa1JtcnZr7yA6jAwq6iAZR+v4pGrDr/Eo6jY/NoZXnzLNVUNz1exEolEIvFKMYgJL0dEgCQkJBKJRCKRSCQSiZfBUBRd7JiOxWc3PhZC4AAvhi59TVmWVHVD61ratmaSF5gi2slIJcAHmq5BKTn69VdVhRQK3+cs5HkOwNLSEkVRMpvNYkFWaYTSKJNTGE2eFXRdtOGRXRyViIVbQVXXMf+ga6nbhqqp6ZxFSIHODFrrsbBfFAWZKdBao5Sgc44caNuWPM959tIWUimkBOe60TZpmG6AWArkj5YAABUeSURBVJxvuhbrPUJFG6O4PTVaEMUJDYGSMbjZBY/0HqkUyIDUAmScsHC+G9d6EHCECL3VUMT1FlPDMQ2igtAxbHpW1f2+Q/ySAS3iNEHnHY6AtXHioW1btJHkUlIUBVvnLzCZLDGbVUg1Y+XQ1eBiEPFkEidBau+5+uqrcULSnN8iz3PKsmR5aYUiMwgRKCdLoCRLh1cx+jAXnjvPpb1d5rt7dL6j6SzWdbSuYXV1GWMMnbXszed4KuZVg3M2ik4esiKKR4MAMwgSeVlSFAVVG6/JYHPkvUerkizrRlukQ6urLOcBowS+s7TOoo16ns2QJ062tM6SlyuYfIIMIHwNtsErDXKY2ZGoEMbpkUCABSFBIlBSkBmFNnJhIuQVriC/DGJxe+tFi9jfWXF7i1Of+Hj033/j7bz9rTdy42sPU05LtISN3/owD76IkPDyWObW+z7CHS/NDek7oGLjt3+Dk5tQvuke3v8yvf23zl+AF0hSuHB+Cyi/c9HmAC9xTZ7tvx+/i39+781XLhrJ+IoXO5fnc5y7/pd7ufkVPbdEIpFIvFxerogASUhIJBKJRCKRSCQSL5FFG53hcRQOohe+CwHvHUr0BXKt0LlkUmRkmUZI8F0sTi8RED6wvLzMfD6jcfvd71VVIaVkKgV5H2QbJwuixc2QHxCDlS1tW1NVczobi8XB17RtOwY9708weApRjHY+zsUCcvBROFhZXUKEgBASY2LQc57nhOBom4Z8ktNUNUpI6j6UeDqdYvKYuWC7LhaY2zZ28S9MHsSJgljwzwozWgwt/twY0x/nfm4B7FsWyb7D/aAH//5UgRACIQUCTzOfkxdLeO8xeUbWGKQWZEWJMjM6W6PEfs6F7KcRBuHBNpbGdlyc7eJdh9aaXa1xTtB1DucC2jTUdbQLmu91GKVQJlod6Txj9dAynXdMixIfHJnWuM5SLMdMAxMCQXiE1EgTxZWmrml9IPgZSoAWku1LOzTW4VyHUJqutVHwsA11laGFpq53xpDrPM97iyCLDh5HgH7SBaLQUjVztI5h0iE4lAysTAzLU40ULQSD6+2ftJb7WQdBABLrJZgpZnKov+c6HB3Ce2QfsDxYcx2YShAgAgufnYAg3qMqkxitkEoR3KuYkXDkKEfYYOvsWXbfeeRgY7g/yxNff5H3tRWWg0UG++STB6N/n93gzCZw3R38/PtuvazpfIutZ16Bw3/tEXh0i8c2Nrnj2OVmO5s8/L99jD+zx7njvnu55ds20a9zz0c/+m33tfWFT/DgoxUcvZ2f/+l1XnbEwl//FZscv8wSaJO/+muAYxy7/uVu8IV5WWty1RGOSNj6yw022pu56bKCv/3Kb/LLnznH2o/ew4d+4ga47nqOcYZzf/M0Wxy/TErY5ZF//av80aV17vyf7uHIa4Fnz7KxYbn5zZeVo9oz/OavfJpzqzdzzy/dyQ2vzKknEolE4hUkhS0nEolEIpFIJBKJK7JYDF0sZg82LUophNx/3RBsPNjrZL3/ewgBvCV4jxSCsizJivxAwb3rC/Jd143TCMP2jDEotT81kGuFEHFKYCji7+3tjYX84T1D1/8gDgw2RkVRMJlMmEwmY5iyMWYM4M1yjXOOtrGIBfFkPp9TFAXLy7EUGkORLVU1w7lunArw3o8TFoMIM4gEw/kO5zdMJwwWQwPee1zXvz9IhBcHBJ1hm4MIIITAWUs9n42h1YNIIdS+3dFQ0I6ByoziicmzMai5rmvqeUW9N+fSpV26Ltru1FUMa75w4cIYhHz+/HkuXbo0ToNMp1OuPrwWxRrr0HI/88ILDggixhgypem6jp1Lu/12a6rZnAsXLvDcc8+xvb09rqMLnsZ2tF1DCIF5XbM3n1M1DU29v/4oiSfgHeM6NF3LbDZjvrfHbHcPKQRaCYrMMJ0UY7aEFhLXdgQ7XEvwIeYkeCHQ5QrKTFBCQujwtsOF/c/F4mdn8TtEMeHAv4Ug05JcD9fwVfxT/ZpbuPU48NQpPvWnizKAZfMLf8Tp6rLX94Vn/nKDry4+V53j4T9+kTCF3W0uHJhssGx+/gQnn33hl78Yuu+G76p9k6Qjb7mFYxK2//TTnNy0B16/9YVP88gFsFfdyPpLdeJ5EarHHuQ3Pr8JR2/lvvffFtfg5XLhET79hcvW+PPxGMs33cyPvEJd+y9rTeQ6t7ylBH+Wh37vDLuL16na4MTDZ8HCDW/oS/3LN3HzceDZk5w4cC5QPfYQp54Ce9UN3DiF9R+9mRI4+/AJzhwIkq7Y+L2HOOstvH49iQiJRCLxPUqaSEgkEolEIpFIJBJXZNHn/XIRATjQfR9tYzQKMYYmK6NjIbsvoHZdh0SQ5zFvQMpo++NwY+HdWkvXtRijUULGTn0EOI9QAiMNMoNg4zF1XbTjsZ0fC+uDqBH6SYM8L8iyvBc4MqQwKBlfX+QTpAgIMSfLsuhdLxX4mOEQQsBIPQYRrx0+TF4YXNciZJ//0Gc1hN63Pxbp/SgYhCDGbIJF0cW5/TVVSkLYD65ezD1YzFVYDLaWUmKyLO6nL0JXVUUp1VgYpz8eJSQKgQ+B4C3WCoSM9lMqz/rpB0UXPJ1tcC7QdQ67NyO+U2FtQ9O0PPfseQ6vHaLMVRRX2pbpdDmurzBIFHt7e9QCTJ4RBCipYxix90CgbVuED0ijEaiYWeEdk6LAOcd8d4+2ipMPQWlCH3ockDjv8cIThKTpLB6BFnOKMgpBOE+w0dJoUi4RdAy7buuGVhuapon3oTZoHYUlOoegQ1pHVVVYGUOVnXO4IOmCAlVisglSGUTwYFtcqJHi+aIbAoSPEzhCLoQtAyHEzAUpZbzfjOzvwb/DD/fzKLn57ns4+y8fZOOzD/DLp4+zfq1h+4nHObdrKEuoFgWDvvC88Rdn+f1f/VVOH7+BNbvF2Sc26a6/gaPPPrHvh3/NOjcdPcnJzT/j47/yBMfXj1JSsblxlq22ZO2qku3zW2xuAddc+UjXXnsE2OTsH36cB79+hBt+7G5uue4W3vfex3ngd89y6mO/wunvv5Eb1jTV0xuc/ZYFfZTb/9tbvjML/m88zAO/tUGF5sjyLl/6f0/wpRd42fU/dje3fLuQ6GnJhc8/wC//p4U1vmRh+Sbu+qn1V65gs/ry1uSG99zLrU99nEcePcGvnj0Vr1OzzRNnz7FrYfnNd/HuMah64X4Zz6XEbj/B49/YxS5u+/V3cu/bnubjf7LBif/1lzn1+nWOTu3B8/7xJCMkEonE9ypJSEgkEolEIpFIJBJXZPR4vyw4drGY7b1HLHTdi+ARSiGNHrv8pZS0bct8PkerfCxyD2G5XrjxNbppxi57ozSouI+yLBGiG/e72NUPMJkUY8DxIDAopcjLIk5AZPttvovTDhADk2NxV8QOdO/j64fgZh275uMxiLFD31uHbTusaymKYj/7AA5MW4TgCEqP5zXYLnXOjjZHIQTCaH2zv18h9r32hyyH4WuYrmjbGCgstaZdECekUHg8XRuzA4L3BLffOS+EQOgoOgTZC0Bag40d+UopghDYzo77DyGwt7dHUeYsTw/Rti11XTOZLI32UW1re9uoVbwPaBtFI0fog62jbVQ3j0JBXhZMlqYIIZhOl9BKjgIRSmK9Q0iFzgoyneO6FusdRRHzGdq2Zd7U5FVF03V4oPVRfMnKgtbG+6bMcw6trBK6jnq+x6Qo+9BjjRQZ+BasJdTQdQ6JoGstVmQ0QYCZgor3kaIBXwMOxL6d0SIHPjuXhS0jBVpIMqGiPCJl3NarSbnOPR+8j0c+8wec+tpZznwL9GvWufNnb6P67Y9x8rKphBt+8gO8/8hDPPzFxzn32BnOZWsc+7F7ed8/7Hjony4ICRzhtvffh/nMH3Dqa5uc/coW6JKjb7ide/7h21h/5gQf/tQGm09uwhsvt+B5AY7fzl1vOsdDj22y8ZVNdq67g1uuW2b5zffykevP8PDvneLMUxuc+QZxP296F3f8xK3c8J0G+c4u9J36lq2zZw7aNy1g33gFIeEH7+QDb93m0797ijNfsZCtceytt3P3e25i7RWu1rysNcmOcccvfIQbv/QQD//x4/E6AfrwMW55593c8ea1g8Wkcp17Png/px/+NCf/U7xf4rbvuGzbmmPvvp+PHH+Eh/7wT3j8L8+w5fmunncikUgkXjlEuPw3nEQikUgkEolEIvE9wfb2xfHx2tqhV3X/n37g53rroHrBDsf39kUZUis6laPyFfLpKlplWB/onGNWNZzf3uaZrW2effY5pFZMlg4xnawwn8/ZfGaTp556KnbqB8ag48FqSOs4zaB6Z9arr76aPC+pqoq6ntPYlkuXLrG7dykKDcU02u/UzZhXYIzh8FVrrB06jNaxu3w2r2OnvY1iwfLylOWlCU3T0HUdxhgOHVqhrlsQApMXGJ1jrWVnZwfvHFlhCCGwtfkMe7MdpJSsrMTzahvLfD6namqqqumLxx6zYC802D/t7O2OgdJCxK5/KSXOR7umOMnh2Nvbo63nTFeWMVm0ZQJYWlphurREXddx2sNkCJ0jtQE87d4ck2uCN1w8/01sVxOcRWcGY3JMVjBdXaWYTkAKgnPkSqMJ2DaKJUIr5nsVr33tawGY1zV5WbJ6aIUjVx9ib28PnWWsrh7m6NGjZFnGbFbFrn4CTROFhkFAKcuSvdklvrX5zdG6ae/SHs/t7sS1X17BaEVnHa2LmRTFpMRLhVQ5U7OMszVdNTtgiRW85ciRq8e1ba1DKMWR117L3mxGkILXXft9HFm7mvPPfotLly7wmqtXOfp9a3zfNSsUykFTUTdzdnd34/k7T9tanCppdYFHoiWUSpJTI9we4FAq6y2kFMbErAYt9AFbLnr7KSEUQsXHbdextzfn6QuX+NaFPXb2Gj74T/7p3/En/qWwxalff4CTz65zz0fvYf3VPpz/XHn2FA/8+km23nQPH/2ZtIqJRCLx952/i9/pd3Z2vivbXSRpvYlEIpFIJBKJROKKLE4ijDkJBAj7IcDgCThgMNXe/y4VaCPRWmG9x7kOCEi5b3/Uti3B+dH6x1pLcB2d63CdREp9oBPfe0/rogXSUJwebICGjm/rHZ6AzgxlXozTCG3bxiPrxZDBXikAznsCxNBbJELH5+vWQoj++3mWUTcNWmvme7tU9Yy2sehMEdiflLjclmg4TjkWk+N5wr49lO/XEkS07hmnQfYnFny/ht7b3hoHfLCjJZRWmkwpfAhY2+GCJRMGRBj37ftwayEUPjTopkHnGVKKcVIiUzEE2lqL+v/bO7fduHEsii7y8CKpEqO7gen8Tz6p+yf6XwdIYqdcEsXbPFCi3B4M8jhpgAsw4CstqaSHOpt7b2OI+04lH8dY8bNHaU2uipjbzv1CJcS99zIYa6ml7bCPMWKUAmepR59AjLGJK96RUuGpZLQ13G43vLPEw2mgRLd7o1SUUUevgkblzPfHK1UL4iDH1qFgxCJi0SjEeyoKbS2FQikJdHNuOGexVlFyZE+BSQziPF4rUoFHufMIr9zXHTUtFBHEKISKIlFTOCQuBfVyobzlbZQV3QVyxoMZ5HSnaI3Vl5tlMBgMBoPB4GdhCAmDwWAwGAwGg8Hgh7wXEuAajvbBfS5QcitTPrLga85QC6IU3gjOOXLYUKWSS4uZEaVxzrWd68dQ/Yw3itG1AXopWDchcvvbMP4cuJ67z8+d6e87COZ5viKUcmINGym2YbxzCu8FkRZVFI5IJWhCgzItSme/fyHVdHRASBcgvn39Nykltj3i1VWCHGPscUXGmEPwUH3tc/3zeHvJcr2ud865FwfXWvr1rilTRY5YpyvC6fzAWNxxHCmlLmqcroeaWxRTyRmlEqSEfhiMaW4Q5IizsoIV24WF4BwhBPYYcfPSBZh939n3hPXt/EMILY6K9nc55N4TENKOq5VoLaVW/DLzYW7OipyO+wZ6HJYVzbLMFCov315IpaBLphJx1iLzwiNsh3NF87pWQsx4r7HzgtIaZS0B0M5SUuJ1DewpIk5z++DxXpHySgjCrhcW5/GTASWEvRC+PvN8X7H6F4wTrC44VTH1uOe1Rh2xRtTr81pVK0N49yyd96dCoeolIl0C0wgOGAwGg8Fg8HMxhITBYDAYDAaDwWDwQ0SkD/lP3vclVHIffqMjpdCH2EYEawzet2igc8BdasvfX5aF+/1OKNew/BzqG6PZ1pWYCtO09P9pjvXOIuTJL4gIj9ftb2XQZ3+AMabl+O+Bx+NxlCFXnHO9mPn79++s68qyLH2Af557zq1fwDnHtm2tQ0C3HfvnwD+lq3T6/F4bDLeBuoh6IyroLnzI0SNx0l0D70qtz3VTStjJ93VijD0m5/w6pXREG4EyQikF7y3Jz8S4Ux+VXDK1tg6CCnhjsUqTRDN5365Bzd1doLXm69evVOD3j0/dBfLy8tLcF5l+Htu2YYzDTL5FE1nD8vEDz1++sG0bVSvQ8OnTJ0xV3B+vTNOEVgqUwvsJpUAdcVEh7jweK/noXQhhY7o5br88sR+7+60VlFXkmMhV4W8z3k1o27ovtIZ1feX5cee3sGFEMS8WLwpTdlJ4YdWCFsdNLMYoqhL2UnleVyYfuN0+ttfnjfvmbdn4++fjf6UJdzFBK2ppvyPqEsYGg8FgMBgMfiaGkDAYDAaDwWAwGAx+yBWpc+yyPsNc1FXEfA7GSykI9J3WTgzVVaZpYvZ7G3LnSgotXmieZz7GyLP9xm4CNRXIlRgCu3OUXPuufmPaWxitW2dASolSKta6QyjwhC0ekUK5D+FPZ0AIgZhTPyfvW+FzKeVwQMQ+MC9ncbRqxcIignZNEFjXlcm1fgRK7T+f55mUShdL2oC+ohSHe+ISGN7GFKmjd6KVGBdqvdY4hQytr3Llt46LMz4p7bHtcFfSeyxELKI0hctJItZgnEeMQyOUlLtwcwos4poYIChyTkzT1EWRUgpaBHKh5EwFvr/ccc7h03VtY04obdBU9tRcF957Yoxs29aKmZ8WZtviprz3lAxx31v3Q1UUCvPSnA/OOWJMbCmjtKGEzPL0gdttYacdPxQW9UTad27LjY+//oZYRy6tqFlrcM4Qgz2uT2F2gqkbNbzwiBFdQSro3M45htbFcd8CNSYWRXeOnJRS0Mocr0t7PpQ6HCYoaoVSKlpX1JvYIlH6cCbIf5Vz/5z8zuc//+Lz//sw/un86zN//DWu4mAwGAz+WfwHuh2z57+x5/kAAAAASUVORK5CYII="},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"aec0942da913946fe8bc2c1bbd25a0fe","cid":"0-21","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:19:44.001Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-21","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T02:19:44.063Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\problem_user\\suite-0-0\\0-21\\report.html"}