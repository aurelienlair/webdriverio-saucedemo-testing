{"info":{"type":"runner","start":"2022-02-18T00:48:13.642Z","_duration":615039,"cid":"0-5","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir39244_70461436"},"goog:chromeOptions":{"debuggerAddress":"localhost:61481"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"1d2c55a714e10e14a2cad0126512409c"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/standard_user","filename":"report.html","reportTitle":"Sauce Demo Report for standard_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout14-checkout2-delay.e2e.js"],"sessionId":"1d2c55a714e10e14a2cad0126512409c","isMultiremote":false,"instanceOptions":{"1d2c55a714e10e14a2cad0126512409c":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/standard_user","filename":"report.html","reportTitle":"Sauce Demo Report for standard_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0,"end":"2022-02-18T00:58:28.681Z"},"metrics":{"passed":25,"skipped":0,"failed":2,"duration":643252,"start":"2022-02-18T00:48:13.650Z","end":"2022-02-18T00:58:56.902Z"},"title":"Master Report for standard_user","suites":[{"type":"suite:start","start":"2022-02-18T00:48:13.650Z","_duration":614980,"tests":[{"type":"test","start":"2022-02-18T00:48:13.651Z","_duration":614972,"uid":"test-00-0","cid":"0-5","title":"TestCase_14: (TestCase_2 modified) should be able to add one item to cart, delay on checkoutStep2 page, logged out, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_14: (TestCase_2 modified) should be able to add one item to cart, delay on checkoutStep2 page, logged out, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:28.623Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:13.651Z","_duration":614972,"uid":"test-00-0","cid":"0-5","title":"TestCase_14: (TestCase_2 modified) should be able to add one item to cart, delay on checkoutStep2 page, logged out, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_14: (TestCase_2 modified) should be able to add one item to cart, delay on checkoutStep2 page, logged out, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e18c87c7-d788-43bb-b84b-200595eaabd5"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e18c87c7-d788-43bb-b84b-200595eaabd5/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e18c87c7-d788-43bb-b84b-200595eaabd5/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e18c87c7-d788-43bb-b84b-200595eaabd5/value","body":{"text":"standard_user"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e18c87c7-d788-43bb-b84b-200595eaabd5/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eac70588-ee4d-4153-9f42-9a0c267b5f3c"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/eac70588-ee4d-4153-9f42-9a0c267b5f3c/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/eac70588-ee4d-4153-9f42-9a0c267b5f3c/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/eac70588-ee4d-4153-9f42-9a0c267b5f3c/value","body":{"text":"secret_sauce"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/eac70588-ee4d-4153-9f42-9a0c267b5f3c/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3aa523b2-a575-47f8-b0d9-13611c4bccd3"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3aa523b2-a575-47f8-b0d9-13611c4bccd3/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3aa523b2-a575-47f8-b0d9-13611c4bccd3/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"32f70427-6163-4160-b445-aa9a114c6540"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/32f70427-6163-4160-b445-aa9a114c6540/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/32f70427-6163-4160-b445-aa9a114c6540/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fca9aa58-30d1-4eec-b643-a2be0af00159"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fca9aa58-30d1-4eec-b643-a2be0af00159/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fca9aa58-30d1-4eec-b643-a2be0af00159/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4439f161-7d10-430d-9410-cf0a355ef36a"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4439f161-7d10-430d-9410-cf0a355ef36a"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4439f161-7d10-430d-9410-cf0a355ef36a/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4439f161-7d10-430d-9410-cf0a355ef36a/text","body":{},"result":{"value":"1"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"4439f161-7d10-430d-9410-cf0a355ef36a"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"345f6acd-6173-4ad1-a8d5-f0b7e1a5ae0b"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/345f6acd-6173-4ad1-a8d5-f0b7e1a5ae0b/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/345f6acd-6173-4ad1-a8d5-f0b7e1a5ae0b/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4ce22950-aa33-4ca6-a7f3-2cb4de0407b1"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4ce22950-aa33-4ca6-a7f3-2cb4de0407b1/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4ce22950-aa33-4ca6-a7f3-2cb4de0407b1/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b6833f3e-887c-417d-a7cc-91107f687e98"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b6833f3e-887c-417d-a7cc-91107f687e98/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b6833f3e-887c-417d-a7cc-91107f687e98/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"678410ad-87a2-48a1-98d6-629d55c9d940"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"678410ad-87a2-48a1-98d6-629d55c9d940"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/678410ad-87a2-48a1-98d6-629d55c9d940/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/678410ad-87a2-48a1-98d6-629d55c9d940/text","body":{},"result":{"value":"1"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"678410ad-87a2-48a1-98d6-629d55c9d940"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e7c5b5cd-9dd9-4cea-a8f5-2c657ea64f72"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e3b1b735-7c79-409a-bf4e-dc6e14e9ba72"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3fa5b0c4-0289-4510-9929-8b4efdc8f310"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e7c5b5cd-9dd9-4cea-a8f5-2c657ea64f72"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7c5b5cd-9dd9-4cea-a8f5-2c657ea64f72/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7c5b5cd-9dd9-4cea-a8f5-2c657ea64f72/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7c5b5cd-9dd9-4cea-a8f5-2c657ea64f72/value","body":{"text":"Jane"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7c5b5cd-9dd9-4cea-a8f5-2c657ea64f72/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e3b1b735-7c79-409a-bf4e-dc6e14e9ba72"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e3b1b735-7c79-409a-bf4e-dc6e14e9ba72/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e3b1b735-7c79-409a-bf4e-dc6e14e9ba72/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e3b1b735-7c79-409a-bf4e-dc6e14e9ba72/value","body":{"text":"Doe"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e3b1b735-7c79-409a-bf4e-dc6e14e9ba72/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3fa5b0c4-0289-4510-9929-8b4efdc8f310"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3fa5b0c4-0289-4510-9929-8b4efdc8f310/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3fa5b0c4-0289-4510-9929-8b4efdc8f310/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3fa5b0c4-0289-4510-9929-8b4efdc8f310/value","body":{"text":"90210"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3fa5b0c4-0289-4510-9929-8b4efdc8f310/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b5a9c1fc-fa00-4115-9e07-a9f07589c2ba"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b5a9c1fc-fa00-4115-9e07-a9f07589c2ba/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b5a9c1fc-fa00-4115-9e07-a9f07589c2ba/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d7bda82b-3224-4429-82e0-2e9499bd9f4f"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d7bda82b-3224-4429-82e0-2e9499bd9f4f/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d7bda82b-3224-4429-82e0-2e9499bd9f4f/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f70b031c-e906-40e3-9156-96da8d886138"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f70b031c-e906-40e3-9156-96da8d886138","ELEMENT":"f70b031c-e906-40e3-9156-96da8d886138"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f70b031c-e906-40e3-9156-96da8d886138","ELEMENT":"f70b031c-e906-40e3-9156-96da8d886138"}]},"result":{"value":true},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f70b031c-e906-40e3-9156-96da8d886138/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f70b031c-e906-40e3-9156-96da8d886138/text","body":{},"result":{"value":"Epic sadface: You can only access '/checkout-step-two.html' when you are logged in."},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c4a9aeaa-8adc-46bd-8191-330ef4a224d9"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c4a9aeaa-8adc-46bd-8191-330ef4a224d9/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c4a9aeaa-8adc-46bd-8191-330ef4a224d9/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c4a9aeaa-8adc-46bd-8191-330ef4a224d9/value","body":{"text":"standard_user"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c4a9aeaa-8adc-46bd-8191-330ef4a224d9/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"68f475cd-7d7f-48e8-a9d8-6c4761eb4cde"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/68f475cd-7d7f-48e8-a9d8-6c4761eb4cde/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/68f475cd-7d7f-48e8-a9d8-6c4761eb4cde/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/68f475cd-7d7f-48e8-a9d8-6c4761eb4cde/value","body":{"text":"secret_sauce"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/68f475cd-7d7f-48e8-a9d8-6c4761eb4cde/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f79369d8-9ca1-4c5a-8035-c0fb0105c29f"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f79369d8-9ca1-4c5a-8035-c0fb0105c29f/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f79369d8-9ca1-4c5a-8035-c0fb0105c29f/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9a1054a7-6bc5-4346-814a-84bec028df49"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a1054a7-6bc5-4346-814a-84bec028df49/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9a1054a7-6bc5-4346-814a-84bec028df49/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b971cc41-e503-4251-8dee-5b087fa22b77"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b971cc41-e503-4251-8dee-5b087fa22b77"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b971cc41-e503-4251-8dee-5b087fa22b77/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b971cc41-e503-4251-8dee-5b087fa22b77/text","body":{},"result":{"value":"1"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b971cc41-e503-4251-8dee-5b087fa22b77"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ce103786-0e70-42dd-bda8-7fda1c0f3ead"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ce103786-0e70-42dd-bda8-7fda1c0f3ead/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ce103786-0e70-42dd-bda8-7fda1c0f3ead/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfdccc6e-90d1-4a9d-ab05-98c33a16440f"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/cfdccc6e-90d1-4a9d-ab05-98c33a16440f/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/cfdccc6e-90d1-4a9d-ab05-98c33a16440f/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"43233ca5-9cfd-481e-b037-3bfb500fec58"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"43233ca5-9cfd-481e-b037-3bfb500fec58"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/43233ca5-9cfd-481e-b037-3bfb500fec58/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/43233ca5-9cfd-481e-b037-3bfb500fec58/text","body":{},"result":{"value":"1"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"43233ca5-9cfd-481e-b037-3bfb500fec58"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0a586e09-ddfd-4c2c-b656-06ec56e0dd9d"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0a586e09-ddfd-4c2c-b656-06ec56e0dd9d/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0a586e09-ddfd-4c2c-b656-06ec56e0dd9d/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b88f0fb4-be44-491b-895a-cbff9d5e6bd2"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b88f0fb4-be44-491b-895a-cbff9d5e6bd2/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b88f0fb4-be44-491b-895a-cbff9d5e6bd2/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0f334f7a-d1fa-493b-bb1f-947688fd2fb9"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0f334f7a-d1fa-493b-bb1f-947688fd2fb9"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0f334f7a-d1fa-493b-bb1f-947688fd2fb9"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0f334f7a-d1fa-493b-bb1f-947688fd2fb9/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0f334f7a-d1fa-493b-bb1f-947688fd2fb9/text","body":{},"result":{"value":"1"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0f334f7a-d1fa-493b-bb1f-947688fd2fb9"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6af7f8b1-9c2d-40dc-b7f5-218f10d8c0e3"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b55af636-2ef3-482a-9915-8955ca037fd7"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"060c1c0e-adca-4954-aea0-c1691adf4066"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6af7f8b1-9c2d-40dc-b7f5-218f10d8c0e3"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6af7f8b1-9c2d-40dc-b7f5-218f10d8c0e3/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6af7f8b1-9c2d-40dc-b7f5-218f10d8c0e3/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6af7f8b1-9c2d-40dc-b7f5-218f10d8c0e3/value","body":{"text":"Jane"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6af7f8b1-9c2d-40dc-b7f5-218f10d8c0e3/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b55af636-2ef3-482a-9915-8955ca037fd7"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b55af636-2ef3-482a-9915-8955ca037fd7/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b55af636-2ef3-482a-9915-8955ca037fd7/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b55af636-2ef3-482a-9915-8955ca037fd7/value","body":{"text":"Doe"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b55af636-2ef3-482a-9915-8955ca037fd7/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"060c1c0e-adca-4954-aea0-c1691adf4066"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/060c1c0e-adca-4954-aea0-c1691adf4066/clear","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/060c1c0e-adca-4954-aea0-c1691adf4066/clear","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/060c1c0e-adca-4954-aea0-c1691adf4066/value","body":{"text":"90210"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/060c1c0e-adca-4954-aea0-c1691adf4066/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"54a4957c-151c-4400-8f5c-b45b8e97e0c7"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/54a4957c-151c-4400-8f5c-b45b8e97e0c7/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/54a4957c-151c-4400-8f5c-b45b8e97e0c7/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"57359ec4-9018-4794-8cdc-56eec1a4f4b9"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/57359ec4-9018-4794-8cdc-56eec1a4f4b9/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/57359ec4-9018-4794-8cdc-56eec1a4f4b9/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9551be99-c936-42b6-8d00-74180b24306d"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9551be99-c936-42b6-8d00-74180b24306d"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9551be99-c936-42b6-8d00-74180b24306d/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9551be99-c936-42b6-8d00-74180b24306d/text","body":{},"result":{"value":"1"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9551be99-c936-42b6-8d00-74180b24306d"}]},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"78c2af2b-448b-48fc-8604-87b7d4c75f37"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/78c2af2b-448b-48fc-8604-87b7d4c75f37/click","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/78c2af2b-448b-48fc-8604-87b7d4c75f37/click","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1c90aa39-2596-4f5f-9944-47a607622e7b"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1c90aa39-2596-4f5f-9944-47a607622e7b/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1c90aa39-2596-4f5f-9944-47a607622e7b/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8e1a8379-d87c-4f4a-99af-fa54e1d0effd"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8e1a8379-d87c-4f4a-99af-fa54e1d0effd"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8e1a8379-d87c-4f4a-99af-fa54e1d0effd/text","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8e1a8379-d87c-4f4a-99af-fa54e1d0effd/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"1d2c55a714e10e14a2cad0126512409c","cid":"0-5","type":"result"}],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:28.623Z"}],"uid":"suite-0-0","cid":"0-5","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout14-checkout2-delay.e2e.js","title":"UserStory: Delay","fullTitle":"UserStory: Delay","parent":"","end":"2022-02-18T00:58:28.631Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.243Z","_duration":613816,"tests":[{"type":"test","start":"2022-02-18T00:48:14.244Z","_duration":613807,"uid":"test-00-0","cid":"0-1","title":"TestCase_10: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, delay, get kicked out, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_10: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, delay, get kicked out, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:28.051Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.244Z","_duration":613807,"uid":"test-00-0","cid":"0-1","title":"TestCase_10: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, delay, get kicked out, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_10: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, delay, get kicked out, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"884e934d-409c-4084-886a-2630251c2c57"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/884e934d-409c-4084-886a-2630251c2c57/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/884e934d-409c-4084-886a-2630251c2c57/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/884e934d-409c-4084-886a-2630251c2c57/value","body":{"text":"standard_user"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/884e934d-409c-4084-886a-2630251c2c57/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c2533b30-3691-4d92-b015-74087724ccfc"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c2533b30-3691-4d92-b015-74087724ccfc/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c2533b30-3691-4d92-b015-74087724ccfc/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c2533b30-3691-4d92-b015-74087724ccfc/value","body":{"text":"secret_sauce"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c2533b30-3691-4d92-b015-74087724ccfc/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8631b218-8f17-49c6-ad13-accee7c03360"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8631b218-8f17-49c6-ad13-accee7c03360/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8631b218-8f17-49c6-ad13-accee7c03360/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1d20beb6-a3d1-4bbd-9930-d5beb5295b14"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1d20beb6-a3d1-4bbd-9930-d5beb5295b14/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1d20beb6-a3d1-4bbd-9930-d5beb5295b14/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e73ad515-d85e-4640-80d0-4e7887def6cb"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e73ad515-d85e-4640-80d0-4e7887def6cb/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e73ad515-d85e-4640-80d0-4e7887def6cb/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c236f9d2-f60a-421e-9ef3-be076e8cb88d"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c236f9d2-f60a-421e-9ef3-be076e8cb88d"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c236f9d2-f60a-421e-9ef3-be076e8cb88d/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c236f9d2-f60a-421e-9ef3-be076e8cb88d/text","body":{},"result":{"value":"1"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c236f9d2-f60a-421e-9ef3-be076e8cb88d"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bdf4601e-0349-4fde-9280-04f8417c55c4"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bdf4601e-0349-4fde-9280-04f8417c55c4/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bdf4601e-0349-4fde-9280-04f8417c55c4/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c4432cf-6cc6-4fb0-abb9-41d7efae2f81"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7c4432cf-6cc6-4fb0-abb9-41d7efae2f81/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7c4432cf-6cc6-4fb0-abb9-41d7efae2f81/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c452193-66b9-4a5a-aaf5-4ab3d8f64695"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c452193-66b9-4a5a-aaf5-4ab3d8f64695"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5c452193-66b9-4a5a-aaf5-4ab3d8f64695"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5c452193-66b9-4a5a-aaf5-4ab3d8f64695/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5c452193-66b9-4a5a-aaf5-4ab3d8f64695/text","body":{},"result":{"value":"1"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5c452193-66b9-4a5a-aaf5-4ab3d8f64695"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a016018e-f3ab-475f-bcaa-082154777e90"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a016018e-f3ab-475f-bcaa-082154777e90","ELEMENT":"a016018e-f3ab-475f-bcaa-082154777e90"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a016018e-f3ab-475f-bcaa-082154777e90","ELEMENT":"a016018e-f3ab-475f-bcaa-082154777e90"}]},"result":{"value":true},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a016018e-f3ab-475f-bcaa-082154777e90/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a016018e-f3ab-475f-bcaa-082154777e90/text","body":{},"result":{"value":"Epic sadface: You can only access '/cart.html' when you are logged in."},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6415df22-3a05-4457-9684-230ffe7c2a1e"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6415df22-3a05-4457-9684-230ffe7c2a1e/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6415df22-3a05-4457-9684-230ffe7c2a1e/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6415df22-3a05-4457-9684-230ffe7c2a1e/value","body":{"text":"standard_user"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6415df22-3a05-4457-9684-230ffe7c2a1e/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c953958d-9544-431e-bac5-090d5905f27a"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c953958d-9544-431e-bac5-090d5905f27a/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c953958d-9544-431e-bac5-090d5905f27a/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c953958d-9544-431e-bac5-090d5905f27a/value","body":{"text":"secret_sauce"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c953958d-9544-431e-bac5-090d5905f27a/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4eab62f0-5828-40d7-837d-fceed53aef69"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4eab62f0-5828-40d7-837d-fceed53aef69/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4eab62f0-5828-40d7-837d-fceed53aef69/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a7aa11fa-0486-4199-ba16-f55c734aab76"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a7aa11fa-0486-4199-ba16-f55c734aab76/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a7aa11fa-0486-4199-ba16-f55c734aab76/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a7aa11fa-0486-4199-ba16-f55c734aab76"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a7aa11fa-0486-4199-ba16-f55c734aab76/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a7aa11fa-0486-4199-ba16-f55c734aab76/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07a4b84a-28c8-4848-83e4-e12cfbe25f81"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07a4b84a-28c8-4848-83e4-e12cfbe25f81"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/07a4b84a-28c8-4848-83e4-e12cfbe25f81/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/07a4b84a-28c8-4848-83e4-e12cfbe25f81/text","body":{},"result":{"value":"1"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"07a4b84a-28c8-4848-83e4-e12cfbe25f81"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"37640eb0-9162-4b83-b901-847062883f8d"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/37640eb0-9162-4b83-b901-847062883f8d/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/37640eb0-9162-4b83-b901-847062883f8d/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a282c73b-efba-46c3-95df-71aa37aa12b5"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a282c73b-efba-46c3-95df-71aa37aa12b5/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a282c73b-efba-46c3-95df-71aa37aa12b5/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4751e716-7882-4e8b-92c0-9e806fec8c4f"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4751e716-7882-4e8b-92c0-9e806fec8c4f/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4751e716-7882-4e8b-92c0-9e806fec8c4f/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"83bf3375-e64e-474a-aa08-d1d84a7b4b1c"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"83bf3375-e64e-474a-aa08-d1d84a7b4b1c"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/83bf3375-e64e-474a-aa08-d1d84a7b4b1c/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/83bf3375-e64e-474a-aa08-d1d84a7b4b1c/text","body":{},"result":{"value":"1"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"83bf3375-e64e-474a-aa08-d1d84a7b4b1c"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ec71c529-80a6-47df-a7e6-0d4dd680d568"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cdfa4828-8cb4-41ff-ab36-e42b37721bd4"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b44ad2d5-b2ea-4513-b34b-e48e2ef76100"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ec71c529-80a6-47df-a7e6-0d4dd680d568"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ec71c529-80a6-47df-a7e6-0d4dd680d568/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ec71c529-80a6-47df-a7e6-0d4dd680d568/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ec71c529-80a6-47df-a7e6-0d4dd680d568/value","body":{"text":"Jane"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ec71c529-80a6-47df-a7e6-0d4dd680d568/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cdfa4828-8cb4-41ff-ab36-e42b37721bd4"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cdfa4828-8cb4-41ff-ab36-e42b37721bd4/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cdfa4828-8cb4-41ff-ab36-e42b37721bd4/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cdfa4828-8cb4-41ff-ab36-e42b37721bd4/value","body":{"text":"Doe"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cdfa4828-8cb4-41ff-ab36-e42b37721bd4/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b44ad2d5-b2ea-4513-b34b-e48e2ef76100"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b44ad2d5-b2ea-4513-b34b-e48e2ef76100/clear","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b44ad2d5-b2ea-4513-b34b-e48e2ef76100/clear","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b44ad2d5-b2ea-4513-b34b-e48e2ef76100/value","body":{"text":"90210"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b44ad2d5-b2ea-4513-b34b-e48e2ef76100/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"10871527-2484-47cb-af44-798202ce3fec"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/10871527-2484-47cb-af44-798202ce3fec/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/10871527-2484-47cb-af44-798202ce3fec/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ac65fa19-8f64-4056-92b6-698a88364c0d"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ac65fa19-8f64-4056-92b6-698a88364c0d/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ac65fa19-8f64-4056-92b6-698a88364c0d/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5ad46c93-1823-4533-a790-505ebcc5f32c"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5ad46c93-1823-4533-a790-505ebcc5f32c"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5ad46c93-1823-4533-a790-505ebcc5f32c/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5ad46c93-1823-4533-a790-505ebcc5f32c/text","body":{},"result":{"value":"1"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5ad46c93-1823-4533-a790-505ebcc5f32c"}]},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"06faebb5-81df-48dc-a1bc-56d73e14f740"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/06faebb5-81df-48dc-a1bc-56d73e14f740/click","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/06faebb5-81df-48dc-a1bc-56d73e14f740/click","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"baefa794-80c6-438f-93cd-4e4bf462365a"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/baefa794-80c6-438f-93cd-4e4bf462365a/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/baefa794-80c6-438f-93cd-4e4bf462365a/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"87a23b89-9a91-4610-a505-1020d859d113"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"87a23b89-9a91-4610-a505-1020d859d113"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/87a23b89-9a91-4610-a505-1020d859d113/text","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/87a23b89-9a91-4610-a505-1020d859d113/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"679e73d384b660d1a591e16a3222158e","cid":"0-1","type":"result"}],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:28.051Z"}],"uid":"suite-0-0","cid":"0-1","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout10-cart-delay.e2e.js","title":"UserStory: Delay","fullTitle":"UserStory: Delay","parent":"","end":"2022-02-18T00:58:28.059Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.244Z","_duration":18418,"tests":[{"type":"test","start":"2022-02-18T00:48:14.245Z","_duration":18400,"uid":"test-00-0","cid":"0-6","title":"TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","fullTitle":"UserStory: Logout.TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","output":[],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T00:48:32.645Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.245Z","_duration":18400,"uid":"test-00-0","cid":"0-6","title":"TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","fullTitle":"UserStory: Logout.TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ca59a8c1-f6af-49e8-a0cb-7ded21a800cf"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/value","body":{"text":"standard_user"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d19adf09-ce86-4546-a376-04a0a56a9dbe"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/value","body":{"text":"secret_sauce"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"948a7646-ef9b-42ab-8ffc-ec4266ce5a56"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/948a7646-ef9b-42ab-8ffc-ec4266ce5a56/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/948a7646-ef9b-42ab-8ffc-ec4266ce5a56/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0be5f86d-d6f6-4261-a88d-30b2670baa19"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0be5f86d-d6f6-4261-a88d-30b2670baa19/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0be5f86d-d6f6-4261-a88d-30b2670baa19/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7ce3ed2d-c6ee-4309-84ae-976519349e1c"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7ce3ed2d-c6ee-4309-84ae-976519349e1c/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7ce3ed2d-c6ee-4309-84ae-976519349e1c/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c6d93c33-a5fc-4750-9ad7-724860eae37e/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c6d93c33-a5fc-4750-9ad7-724860eae37e/text","body":{},"result":{"value":"1"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"88952bf6-9cd6-4040-bcc5-02dfe4e11dfa"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/88952bf6-9cd6-4040-bcc5-02dfe4e11dfa/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/88952bf6-9cd6-4040-bcc5-02dfe4e11dfa/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"230ad796-8c9e-48f1-8807-6672ced548a0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/230ad796-8c9e-48f1-8807-6672ced548a0/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/230ad796-8c9e-48f1-8807-6672ced548a0/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f7747a52-e092-4169-bf98-cec7a4481dba"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f7747a52-e092-4169-bf98-cec7a4481dba/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f7747a52-e092-4169-bf98-cec7a4481dba/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2d736376-8f7b-48c7-a8aa-2feeb90554db/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2d736376-8f7b-48c7-a8aa-2feeb90554db/text","body":{},"result":{"value":"1"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9bffc254-7b02-40fe-8418-5d9127914039"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"196ec00b-9a46-411c-a465-af7e657b92af"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9bffc254-7b02-40fe-8418-5d9127914039"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/value","body":{"text":"Jane"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/value","body":{"text":"Doe"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"196ec00b-9a46-411c-a465-af7e657b92af"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/value","body":{"text":"90210"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba34c538-d7d8-472b-ad1d-50ef68b08582"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba34c538-d7d8-472b-ad1d-50ef68b08582/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba34c538-d7d8-472b-ad1d-50ef68b08582/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"01cbc2f8-4a6b-4612-9da8-ab6da7180d50"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3af51dbe-7391-4123-9cdc-7df9eaf3543a"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3af51dbe-7391-4123-9cdc-7df9eaf3543a/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3af51dbe-7391-4123-9cdc-7df9eaf3543a/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b254a4f3-9d07-4c40-9b87-ca4d394bb401"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b254a4f3-9d07-4c40-9b87-ca4d394bb401/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b254a4f3-9d07-4c40-9b87-ca4d394bb401/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f43ec3c0-583a-42c6-bf6d-70fc609ee0aa"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f43ec3c0-583a-42c6-bf6d-70fc609ee0aa/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f43ec3c0-583a-42c6-bf6d-70fc609ee0aa/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fa1df062-5b81-4642-b1a6-bc041fc93ed8"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fa1df062-5b81-4642-b1a6-bc041fc93ed8"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fa1df062-5b81-4642-b1a6-bc041fc93ed8/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fa1df062-5b81-4642-b1a6-bc041fc93ed8/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfcda905-ab95-498d-8475-7a60ebb43ba4"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfcda905-ab95-498d-8475-7a60ebb43ba4/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfcda905-ab95-498d-8475-7a60ebb43ba4/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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jhz/hXxbSlYwrySUo9l41VFA2sD/i7O/RHHvm6za34T3SwfbnnUEaYSFrBUbeWZO4AV1R3v+SOlyOan2AtE5WGeP/P27s+2k7f8VDV4XDlc+WY/ERLhFkRWp+xSKm9+XrewqeJxdoXx1/kaOLksZ4/lERERERERERETk2+7WnpEAgJmswmVkmABvK3sPRnLhZTMzFmzkN2XbWJtvJW1qDKZrn0VxhyWF7PyVlOzfyYZsyzDHuZncuI72L0R8d24OyaHsEvsg9of6/9rw4QkujFvbIuVG3advQ1+KiIiIiIiIiIiIDPU//vznP//5ZjdCRERERERERERERETC19PTA0BDQ0PEj52W1l8/5zaYkSAiIiIiIiIiIiIiIuNFiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQnqL292A4zm2R+/2U0QEZFxdNTx/s1uggDQTfUrz/DaqV5i7Rs5UJSCKdhX+1rZV7ieissx2DcXszzNfCMbOgG4cbywgt1nbLzqKCD1tj1nGNxOVheU0jJ/Ix8vS7nZrRl3jXseZ92RJJaXbsFugQl/f3racDg6yFhkJS7snW/etfn3863iBvVZgN/drfBs3vT7eqPfV31u6kprMRXZJ0T/i4iIiESKZiSIiIh8K8WQvTyfZBN0OXZQdib4N9s/2EPFZYidv5Il37okgsitpondS9eyu95zsxsi8i3UjePlFWx0uG92Q0REREQibsLNSBAREZEbxGJjzZMneLqklYq9Dn6yzU7cJMN3zley+XAHTLGxNj8FpRFEACzY33gf+81uRjDem90AGRcWG9sdtpvdirClLnufj5fdxAbc0H7zQt8NOpWIiIjIDTbh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BBERERERERERERERuagUSBARERERERERERERkXEpkCAiIiIiIiIiIiIiIuNSIEFERERERERERERERMalQIKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4FEgQEREREREREREREZFxKZAgIiIiIiIiIiIiIiLjUiBBRERERERERERERETGpUCCiIiIiIiIiIiIiIiMS4EEEREREREREREREREZlwIJIiIiIiIiIiIiIiIyLgUSRERERERERERERERkXAokiIiIiIiIiIiIiIjIuBRIEBERERERERERERGRcSmQICIiIiIiIiIiIiIi41IgQURERERERERERERExqVAgoiIiIiIiIiIiIiIjEuBBBERERERERERERERGZcCCSIiIiIiIiIiIiIiMi4FEkREREREREREREREZFwKJIiIiIiIiIiIiIiIyLgUSBARERERERERERERkXEpkCAiIiIiIiIiIiIiIuNSIEFERERERERERERERMalQIKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4Aq7ruhf7IERERERERERERERE5OwNDw9f8NdQRoKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4FEgQEREREREREREREZFxKZAgIiIiIiIiIiIiIiLjUiBBRERERERERERERETGpUCCiIiIiIiIiIiIiIiMS4EEEREREREREREREREZlwIJIiIiIiIiIiIiIiIyrtDFPgARERERkSuF6zi4joOTyeBk0hQyKZxMhkI6jZNJ4dg2TjaLY2dxbRsn5y/ncpDP4+YLuE5xcsB1cB0Xisuuv+z4y67rv7DrrXsrpW3FxZJAwJ8XVwNjV7zJMAgYhvdYwPDXxy4XpyAEQwRCIQwrjGFZBCzLXw4TsCyCkTKMSBlGJEKwLDq6blkEgsEL+EmIiIiIiMhkUiBBRERERARwXRc3n8fN2d6Af3Gw387i2DZuLutvH7PNnzs52/vZfA43l/OX8zj53Oj2fA63UPCC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"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T00:48:32.645Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-6","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T00:48:32.666Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.278Z","_duration":612711,"tests":[{"type":"test","start":"2022-02-18T00:48:14.279Z","_duration":612703,"uid":"test-00-0","cid":"0-7","title":"TestCase_16: (TestCase_2 modified) should be able to add one item to cart and go to checkoutComplete page, delay, logged out, log back in and check 0 items in cart","fullTitle":"UserStory: Delay.TestCase_16: (TestCase_2 modified) should be able to add one item to cart and go to checkoutComplete page, delay, logged out, log back in and check 0 items in cart","output":[],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:26.982Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.279Z","_duration":612703,"uid":"test-00-0","cid":"0-7","title":"TestCase_16: (TestCase_2 modified) should be able to add one item to cart and go to checkoutComplete page, delay, logged out, log back in and check 0 items in cart","fullTitle":"UserStory: Delay.TestCase_16: (TestCase_2 modified) should be able to add one item to cart and go to checkoutComplete page, delay, logged out, log back in and check 0 items in cart","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"105d1642-dcf2-4e2b-8d75-5ffa7ad7c7d1"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/105d1642-dcf2-4e2b-8d75-5ffa7ad7c7d1/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/105d1642-dcf2-4e2b-8d75-5ffa7ad7c7d1/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/105d1642-dcf2-4e2b-8d75-5ffa7ad7c7d1/value","body":{"text":"standard_user"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/105d1642-dcf2-4e2b-8d75-5ffa7ad7c7d1/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ff46dd0b-54d6-405e-a896-b1d30acedb2d"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ff46dd0b-54d6-405e-a896-b1d30acedb2d/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ff46dd0b-54d6-405e-a896-b1d30acedb2d/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ff46dd0b-54d6-405e-a896-b1d30acedb2d/value","body":{"text":"secret_sauce"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ff46dd0b-54d6-405e-a896-b1d30acedb2d/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"077be78c-302b-4490-bbd7-07f2ca82cf92"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/077be78c-302b-4490-bbd7-07f2ca82cf92/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/077be78c-302b-4490-bbd7-07f2ca82cf92/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b0801d9c-6f96-4da8-8f8c-e92d987892e7"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b0801d9c-6f96-4da8-8f8c-e92d987892e7/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b0801d9c-6f96-4da8-8f8c-e92d987892e7/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"728a2c1a-b26a-4b71-9a76-fcdcdc58fad5"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/728a2c1a-b26a-4b71-9a76-fcdcdc58fad5/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/728a2c1a-b26a-4b71-9a76-fcdcdc58fad5/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b81826b2-5cfb-4a75-afef-a4de81f8f978"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b81826b2-5cfb-4a75-afef-a4de81f8f978"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b81826b2-5cfb-4a75-afef-a4de81f8f978/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b81826b2-5cfb-4a75-afef-a4de81f8f978/text","body":{},"result":{"value":"1"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b54251f0-28f0-40a8-9e9e-1f592be98390"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b54251f0-28f0-40a8-9e9e-1f592be98390/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b54251f0-28f0-40a8-9e9e-1f592be98390/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5140094a-eef7-4dda-836e-18b7ad170351"}]},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ff69b161-b9c6-4113-b40b-3ade90135b00"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ff69b161-b9c6-4113-b40b-3ade90135b00/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ff69b161-b9c6-4113-b40b-3ade90135b00/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"df674cc0-acf3-4413-879b-4bef3a74ee9b"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/df674cc0-acf3-4413-879b-4bef3a74ee9b/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/df674cc0-acf3-4413-879b-4bef3a74ee9b/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fddc5590-917b-4898-a750-df44d33e2efc"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fddc5590-917b-4898-a750-df44d33e2efc"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fddc5590-917b-4898-a750-df44d33e2efc/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fddc5590-917b-4898-a750-df44d33e2efc"}]},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fddc5590-917b-4898-a750-df44d33e2efc/text","body":{},"result":{"value":"1"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d5c34e5a-a65d-427e-9e95-19872c0a7722"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cae36d5c-1438-463d-b66a-045542c774e6"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfe708b7-ca26-4fe0-90dc-f1d449b2789e"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d5c34e5a-a65d-427e-9e95-19872c0a7722"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d5c34e5a-a65d-427e-9e95-19872c0a7722/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d5c34e5a-a65d-427e-9e95-19872c0a7722/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d5c34e5a-a65d-427e-9e95-19872c0a7722/value","body":{"text":"Jane"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d5c34e5a-a65d-427e-9e95-19872c0a7722/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cae36d5c-1438-463d-b66a-045542c774e6"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cae36d5c-1438-463d-b66a-045542c774e6/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cae36d5c-1438-463d-b66a-045542c774e6/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cae36d5c-1438-463d-b66a-045542c774e6/value","body":{"text":"Doe"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cae36d5c-1438-463d-b66a-045542c774e6/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfe708b7-ca26-4fe0-90dc-f1d449b2789e"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfe708b7-ca26-4fe0-90dc-f1d449b2789e/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cfe708b7-ca26-4fe0-90dc-f1d449b2789e/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfe708b7-ca26-4fe0-90dc-f1d449b2789e/value","body":{"text":"90210"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cfe708b7-ca26-4fe0-90dc-f1d449b2789e/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c69af542-3e92-4d6e-a825-dd185e15812d"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c69af542-3e92-4d6e-a825-dd185e15812d/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c69af542-3e92-4d6e-a825-dd185e15812d/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e8bd3bc0-eb33-4b49-816a-d974d49c3bd1"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e8bd3bc0-eb33-4b49-816a-d974d49c3bd1/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e8bd3bc0-eb33-4b49-816a-d974d49c3bd1/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e5f33a31-ee74-4bbe-9efb-14ca1f7cde6c"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e5f33a31-ee74-4bbe-9efb-14ca1f7cde6c/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e5f33a31-ee74-4bbe-9efb-14ca1f7cde6c/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c78c7430-9c96-4a07-8c7d-85a0af44448f"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c78c7430-9c96-4a07-8c7d-85a0af44448f/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c78c7430-9c96-4a07-8c7d-85a0af44448f/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b57617a7-a2b5-40a1-9569-3fdf9eaa6731"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b57617a7-a2b5-40a1-9569-3fdf9eaa6731"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b57617a7-a2b5-40a1-9569-3fdf9eaa6731/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b57617a7-a2b5-40a1-9569-3fdf9eaa6731/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[]},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7458526b-5d00-4c33-a95e-c4de23e21bf2"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"7458526b-5d00-4c33-a95e-c4de23e21bf2","ELEMENT":"7458526b-5d00-4c33-a95e-c4de23e21bf2"}]},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"7458526b-5d00-4c33-a95e-c4de23e21bf2","ELEMENT":"7458526b-5d00-4c33-a95e-c4de23e21bf2"}]},"result":{"value":true},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7458526b-5d00-4c33-a95e-c4de23e21bf2/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7458526b-5d00-4c33-a95e-c4de23e21bf2/text","body":{},"result":{"value":"Epic sadface: You can only access '/checkout-complete.html' when you are logged in."},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8bbd96e7-6bf5-469f-96c3-b6b5ebd23d4a"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8bbd96e7-6bf5-469f-96c3-b6b5ebd23d4a/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8bbd96e7-6bf5-469f-96c3-b6b5ebd23d4a/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8bbd96e7-6bf5-469f-96c3-b6b5ebd23d4a/value","body":{"text":"standard_user"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8bbd96e7-6bf5-469f-96c3-b6b5ebd23d4a/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"822087ae-d0f8-4f65-8fb1-0a7a4f4a5d0c"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/822087ae-d0f8-4f65-8fb1-0a7a4f4a5d0c/clear","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/822087ae-d0f8-4f65-8fb1-0a7a4f4a5d0c/clear","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/822087ae-d0f8-4f65-8fb1-0a7a4f4a5d0c/value","body":{"text":"secret_sauce"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/822087ae-d0f8-4f65-8fb1-0a7a4f4a5d0c/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2e823d20-6cec-4aec-a4a9-5a124d403bea"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2e823d20-6cec-4aec-a4a9-5a124d403bea/click","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2e823d20-6cec-4aec-a4a9-5a124d403bea/click","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9998307a-c749-4add-a5b1-02bf8e12c65f"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9998307a-c749-4add-a5b1-02bf8e12c65f/text","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9998307a-c749-4add-a5b1-02bf8e12c65f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"51137867104aeeba4637ee44344810bf","cid":"0-7","type":"result"}],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:26.982Z"}],"uid":"suite-0-0","cid":"0-7","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout16-checkoutcomplete-delay.e2e.js","title":"UserStory: Delay","fullTitle":"UserStory: Delay","parent":"","end":"2022-02-18T00:58:26.990Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.304Z","_duration":15289,"tests":[{"type":"test","start":"2022-02-18T00:48:14.305Z","_duration":15273,"uid":"test-00-0","cid":"0-2","title":"TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:29.578Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.305Z","_duration":15273,"uid":"test-00-0","cid":"0-2","title":"TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba273e35-cb01-4173-9e77-7281ca326546"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba273e35-cb01-4173-9e77-7281ca326546/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba273e35-cb01-4173-9e77-7281ca326546/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba273e35-cb01-4173-9e77-7281ca326546/value","body":{"text":"standard_user"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba273e35-cb01-4173-9e77-7281ca326546/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c137ef7b-e284-4709-8fea-e2f9f82b868c"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c137ef7b-e284-4709-8fea-e2f9f82b868c/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c137ef7b-e284-4709-8fea-e2f9f82b868c/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c137ef7b-e284-4709-8fea-e2f9f82b868c/value","body":{"text":"secret_sauce"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c137ef7b-e284-4709-8fea-e2f9f82b868c/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0369ef7e-fa5a-4c24-b8c5-d9cd1ad9cbad"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0369ef7e-fa5a-4c24-b8c5-d9cd1ad9cbad/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0369ef7e-fa5a-4c24-b8c5-d9cd1ad9cbad/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d6562fbd-122d-4a7c-97bc-edaebc2bcef1"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d6562fbd-122d-4a7c-97bc-edaebc2bcef1/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d6562fbd-122d-4a7c-97bc-edaebc2bcef1/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4d181f48-3169-4af3-ae4b-162c215e3d21"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4d181f48-3169-4af3-ae4b-162c215e3d21/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4d181f48-3169-4af3-ae4b-162c215e3d21/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8dc089e5-4898-4d09-97d3-30db3f9fa00f"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8dc089e5-4898-4d09-97d3-30db3f9fa00f"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8dc089e5-4898-4d09-97d3-30db3f9fa00f/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8dc089e5-4898-4d09-97d3-30db3f9fa00f/text","body":{},"result":{"value":"1"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8dc089e5-4898-4d09-97d3-30db3f9fa00f"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b3e6d6f4-fd1b-4f45-8bb6-67eb8e8f9df5"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b3e6d6f4-fd1b-4f45-8bb6-67eb8e8f9df5/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b3e6d6f4-fd1b-4f45-8bb6-67eb8e8f9df5/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d3eabd4b-4e19-4bce-ac57-ef6be8eed0a6"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d3eabd4b-4e19-4bce-ac57-ef6be8eed0a6/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5e4b7223-b685-4ed9-a651-253cf68cdfe5"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d3eabd4b-4e19-4bce-ac57-ef6be8eed0a6/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"052a599d-95ea-4651-ad13-2a200765a32e"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/052a599d-95ea-4651-ad13-2a200765a32e/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/052a599d-95ea-4651-ad13-2a200765a32e/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f84a4af4-1286-4f89-8b1d-01e7f7ded895"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f84a4af4-1286-4f89-8b1d-01e7f7ded895/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f84a4af4-1286-4f89-8b1d-01e7f7ded895/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":true},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":false},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":true},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":false},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":true},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":false},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":true},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648","ELEMENT":"bfcfdea1-4fa0-4995-b42a-4d2bfef64648"}]},"result":{"value":true},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bfcfdea1-4fa0-4995-b42a-4d2bfef64648/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bfcfdea1-4fa0-4995-b42a-4d2bfef64648/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"62fc6f5c-db9d-4f20-8fe5-8677ef27173b"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/62fc6f5c-db9d-4f20-8fe5-8677ef27173b/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/62fc6f5c-db9d-4f20-8fe5-8677ef27173b/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/62fc6f5c-db9d-4f20-8fe5-8677ef27173b/value","body":{"text":"standard_user"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/62fc6f5c-db9d-4f20-8fe5-8677ef27173b/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6caf0a3f-46fc-4055-b5c6-48cee1e4cdce"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6caf0a3f-46fc-4055-b5c6-48cee1e4cdce/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6caf0a3f-46fc-4055-b5c6-48cee1e4cdce/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6caf0a3f-46fc-4055-b5c6-48cee1e4cdce/value","body":{"text":"secret_sauce"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6caf0a3f-46fc-4055-b5c6-48cee1e4cdce/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8ac3d08c-d86f-46a0-a818-2a9a14e4431a"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8ac3d08c-d86f-46a0-a818-2a9a14e4431a/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8ac3d08c-d86f-46a0-a818-2a9a14e4431a/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"47dda909-ef19-4ade-80ba-d07f0814a62d"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/47dda909-ef19-4ade-80ba-d07f0814a62d/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/47dda909-ef19-4ade-80ba-d07f0814a62d/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"517f5cf3-3b13-4792-b2d5-be32dc77f306"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"517f5cf3-3b13-4792-b2d5-be32dc77f306"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/517f5cf3-3b13-4792-b2d5-be32dc77f306/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/517f5cf3-3b13-4792-b2d5-be32dc77f306/text","body":{},"result":{"value":"1"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"530c9aec-33c7-4417-beb0-d5c54b8c5a97"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/530c9aec-33c7-4417-beb0-d5c54b8c5a97/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/530c9aec-33c7-4417-beb0-d5c54b8c5a97/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9353dd94-17b6-4660-a71d-c464619be13b"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"15e74966-c8ab-4f9c-ad0d-54c4af8e5a76"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/15e74966-c8ab-4f9c-ad0d-54c4af8e5a76/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/15e74966-c8ab-4f9c-ad0d-54c4af8e5a76/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9353dd94-17b6-4660-a71d-c464619be13b"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9353dd94-17b6-4660-a71d-c464619be13b"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9353dd94-17b6-4660-a71d-c464619be13b/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9353dd94-17b6-4660-a71d-c464619be13b/text","body":{},"result":{"value":"1"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9353dd94-17b6-4660-a71d-c464619be13b"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5bea2fd0-89a5-4027-b141-6c7c583ddf01"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5bea2fd0-89a5-4027-b141-6c7c583ddf01/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5bea2fd0-89a5-4027-b141-6c7c583ddf01/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a7456ea4-7dcd-4762-9ad4-39bd9e8c8aff"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a7456ea4-7dcd-4762-9ad4-39bd9e8c8aff/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a7456ea4-7dcd-4762-9ad4-39bd9e8c8aff/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"030e32e9-7cf6-417e-8f46-b6e46624fcc3"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"030e32e9-7cf6-417e-8f46-b6e46624fcc3"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/030e32e9-7cf6-417e-8f46-b6e46624fcc3/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/030e32e9-7cf6-417e-8f46-b6e46624fcc3/text","body":{},"result":{"value":"1"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"030e32e9-7cf6-417e-8f46-b6e46624fcc3"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb78a5b4-f118-45f7-8a8b-81caa9e1256b"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23620008-3cf3-4065-bea3-3cf81f7dbc4a"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"81ff4a10-d0ae-4b22-8eb4-8841e7ded482"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb78a5b4-f118-45f7-8a8b-81caa9e1256b"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb78a5b4-f118-45f7-8a8b-81caa9e1256b/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb78a5b4-f118-45f7-8a8b-81caa9e1256b/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb78a5b4-f118-45f7-8a8b-81caa9e1256b/value","body":{"text":"Jane"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb78a5b4-f118-45f7-8a8b-81caa9e1256b/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23620008-3cf3-4065-bea3-3cf81f7dbc4a"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/23620008-3cf3-4065-bea3-3cf81f7dbc4a/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/23620008-3cf3-4065-bea3-3cf81f7dbc4a/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/23620008-3cf3-4065-bea3-3cf81f7dbc4a/value","body":{"text":"Doe"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/23620008-3cf3-4065-bea3-3cf81f7dbc4a/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"81ff4a10-d0ae-4b22-8eb4-8841e7ded482"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/81ff4a10-d0ae-4b22-8eb4-8841e7ded482/clear","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/81ff4a10-d0ae-4b22-8eb4-8841e7ded482/clear","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/81ff4a10-d0ae-4b22-8eb4-8841e7ded482/value","body":{"text":"90210"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/81ff4a10-d0ae-4b22-8eb4-8841e7ded482/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4f2b6f08-0694-49bd-af8c-d20a77521d22"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4f2b6f08-0694-49bd-af8c-d20a77521d22/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4f2b6f08-0694-49bd-af8c-d20a77521d22/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"01336982-9fd2-40bc-bf08-d7e414eaca43"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/01336982-9fd2-40bc-bf08-d7e414eaca43/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/01336982-9fd2-40bc-bf08-d7e414eaca43/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2a58c23e-e5bf-40f5-aac7-29c59c953cbf"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2a58c23e-e5bf-40f5-aac7-29c59c953cbf"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2a58c23e-e5bf-40f5-aac7-29c59c953cbf/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2a58c23e-e5bf-40f5-aac7-29c59c953cbf/text","body":{},"result":{"value":"1"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2a58c23e-e5bf-40f5-aac7-29c59c953cbf"}]},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d38d2902-1e3a-4c1b-a8e3-dfebb0b34deb"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d38d2902-1e3a-4c1b-a8e3-dfebb0b34deb/click","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d38d2902-1e3a-4c1b-a8e3-dfebb0b34deb/click","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"67c530ff-1626-4147-8823-993797bc7df9"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/67c530ff-1626-4147-8823-993797bc7df9/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/67c530ff-1626-4147-8823-993797bc7df9/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e9a39730-53f1-4702-8b1e-fccbed9b601a"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e9a39730-53f1-4702-8b1e-fccbed9b601a"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e9a39730-53f1-4702-8b1e-fccbed9b601a/text","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e9a39730-53f1-4702-8b1e-fccbed9b601a/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"633f4912ded456e5c268aab3f7c201e8","cid":"0-2","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:29.578Z"}],"uid":"suite-0-0","cid":"0-2","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T00:48:29.595Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.425Z","_duration":8227,"tests":[{"type":"test","start":"2022-02-18T00:48:14.425Z","_duration":8216,"uid":"test-00-0","cid":"0-8","title":"TestCase_17: (TestCase_2 modified) should be able to add one item to cart and check it out successfully, click on cart icon and see 0 items in cart","fullTitle":"UserStory: Checkout.TestCase_17: (TestCase_2 modified) should be able to add one item to cart and check it out successfully, click on cart icon and see 0 items in cart","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:22.641Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.425Z","_duration":8216,"uid":"test-00-0","cid":"0-8","title":"TestCase_17: (TestCase_2 modified) should be able to add one item to cart and check it out successfully, click on cart icon and see 0 items in cart","fullTitle":"UserStory: Checkout.TestCase_17: (TestCase_2 modified) should be able to add one item to cart and check it out successfully, click on cart icon and see 0 items in cart","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6774ff50-75c9-45fe-ab02-b53a02e01b6d"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6774ff50-75c9-45fe-ab02-b53a02e01b6d/clear","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6774ff50-75c9-45fe-ab02-b53a02e01b6d/clear","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6774ff50-75c9-45fe-ab02-b53a02e01b6d/value","body":{"text":"standard_user"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6774ff50-75c9-45fe-ab02-b53a02e01b6d/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"844ba511-8dc9-4d11-aada-6dec59d1a11c"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/844ba511-8dc9-4d11-aada-6dec59d1a11c/clear","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/844ba511-8dc9-4d11-aada-6dec59d1a11c/clear","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/844ba511-8dc9-4d11-aada-6dec59d1a11c/value","body":{"text":"secret_sauce"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/844ba511-8dc9-4d11-aada-6dec59d1a11c/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"028ad254-9e2b-49c0-a24c-734f67672c94"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/028ad254-9e2b-49c0-a24c-734f67672c94/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/028ad254-9e2b-49c0-a24c-734f67672c94/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6fadd7d1-3209-44aa-b942-839fa2cb9d7c"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6fadd7d1-3209-44aa-b942-839fa2cb9d7c/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6fadd7d1-3209-44aa-b942-839fa2cb9d7c/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e2b9254f-3ec7-48fd-bf4c-1dac6f998be4"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e2b9254f-3ec7-48fd-bf4c-1dac6f998be4/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e2b9254f-3ec7-48fd-bf4c-1dac6f998be4/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c21d87f9-3c7e-4707-ad8b-211cff5f9560"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c21d87f9-3c7e-4707-ad8b-211cff5f9560"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c21d87f9-3c7e-4707-ad8b-211cff5f9560/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c21d87f9-3c7e-4707-ad8b-211cff5f9560/text","body":{},"result":{"value":"1"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"72d61e78-34c9-47c8-a9ee-c5a57015e6d0"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/72d61e78-34c9-47c8-a9ee-c5a57015e6d0/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c21d87f9-3c7e-4707-ad8b-211cff5f9560"}]},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/72d61e78-34c9-47c8-a9ee-c5a57015e6d0/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5d6814a2-3b50-4bbf-873a-55b0c50bf4e4"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5d6814a2-3b50-4bbf-873a-55b0c50bf4e4/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5d6814a2-3b50-4bbf-873a-55b0c50bf4e4/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05ef3174-e5df-4218-986e-5013251716f3"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05ef3174-e5df-4218-986e-5013251716f3"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"05ef3174-e5df-4218-986e-5013251716f3"}]},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/05ef3174-e5df-4218-986e-5013251716f3/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/05ef3174-e5df-4218-986e-5013251716f3/text","body":{},"result":{"value":"1"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"05ef3174-e5df-4218-986e-5013251716f3"}]},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"099a6301-185b-4c05-a7d7-196f1047a192"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/099a6301-185b-4c05-a7d7-196f1047a192/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/099a6301-185b-4c05-a7d7-196f1047a192/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"49091870-8714-4107-815f-67932a2a2bf3"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/49091870-8714-4107-815f-67932a2a2bf3/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/49091870-8714-4107-815f-67932a2a2bf3/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ef7eb646-9508-4d05-85b5-0dbbeca8b8d8"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ef7eb646-9508-4d05-85b5-0dbbeca8b8d8"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ef7eb646-9508-4d05-85b5-0dbbeca8b8d8/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ef7eb646-9508-4d05-85b5-0dbbeca8b8d8/text","body":{},"result":{"value":"1"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ef7eb646-9508-4d05-85b5-0dbbeca8b8d8"}]},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba4bd343-4d01-4498-a845-87ef18a2048b"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cae6c05f-d763-4853-bbe7-3c8011f60ceb"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e7a693a5-b01a-474e-b36b-da272b0d0e92"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba4bd343-4d01-4498-a845-87ef18a2048b"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba4bd343-4d01-4498-a845-87ef18a2048b/clear","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba4bd343-4d01-4498-a845-87ef18a2048b/clear","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba4bd343-4d01-4498-a845-87ef18a2048b/value","body":{"text":"Jane"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba4bd343-4d01-4498-a845-87ef18a2048b/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cae6c05f-d763-4853-bbe7-3c8011f60ceb"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cae6c05f-d763-4853-bbe7-3c8011f60ceb/clear","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cae6c05f-d763-4853-bbe7-3c8011f60ceb/clear","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cae6c05f-d763-4853-bbe7-3c8011f60ceb/value","body":{"text":"Doe"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cae6c05f-d763-4853-bbe7-3c8011f60ceb/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e7a693a5-b01a-474e-b36b-da272b0d0e92"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7a693a5-b01a-474e-b36b-da272b0d0e92/clear","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7a693a5-b01a-474e-b36b-da272b0d0e92/clear","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7a693a5-b01a-474e-b36b-da272b0d0e92/value","body":{"text":"90210"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7a693a5-b01a-474e-b36b-da272b0d0e92/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1fe5c33d-c729-402d-9fb8-1d5303bb2957"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1fe5c33d-c729-402d-9fb8-1d5303bb2957/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1fe5c33d-c729-402d-9fb8-1d5303bb2957/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cd701ae2-9b77-45da-b328-524705c43530"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/cd701ae2-9b77-45da-b328-524705c43530/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/cd701ae2-9b77-45da-b328-524705c43530/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9789843-a33b-4e69-b5af-7c8891792a27"}]},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9789843-a33b-4e69-b5af-7c8891792a27"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9789843-a33b-4e69-b5af-7c8891792a27"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9789843-a33b-4e69-b5af-7c8891792a27/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9789843-a33b-4e69-b5af-7c8891792a27/text","body":{},"result":{"value":"1"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9789843-a33b-4e69-b5af-7c8891792a27"}]},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cdfb7330-ae3d-4431-8a23-d3dfa66f9a8f"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cdfb7330-ae3d-4431-8a23-d3dfa66f9a8f/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cdfb7330-ae3d-4431-8a23-d3dfa66f9a8f/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"52d8e220-9df5-4702-9f6b-de10cc6a9bc9"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/52d8e220-9df5-4702-9f6b-de10cc6a9bc9/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/52d8e220-9df5-4702-9f6b-de10cc6a9bc9/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a45e2d07-b7b6-4299-b7f8-0799b3c61161"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a45e2d07-b7b6-4299-b7f8-0799b3c61161"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a45e2d07-b7b6-4299-b7f8-0799b3c61161/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a45e2d07-b7b6-4299-b7f8-0799b3c61161/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f0fb5272-ab74-44b8-bdd0-ef153ab1e5b4"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f0fb5272-ab74-44b8-bdd0-ef153ab1e5b4/click","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f0fb5272-ab74-44b8-bdd0-ef153ab1e5b4/click","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a0b57b45-fc61-4992-b5ab-1358bae2c003"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a0b57b45-fc61-4992-b5ab-1358bae2c003/text","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a0b57b45-fc61-4992-b5ab-1358bae2c003/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"bb074b6d5de4e2db7928c863335aaa1b","cid":"0-8","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:22.641Z"}],"uid":"suite-0-0","cid":"0-8","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout17.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:22.653Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.457Z","_duration":5798,"tests":[{"type":"test","start":"2022-02-18T00:48:14.458Z","_duration":5787,"uid":"test-00-0","cid":"0-0","title":"TestCase_1: Add one item to cart, remove it, add it again","fullTitle":"UserStory: Checkout.TestCase_1: Add one item to cart, remove it, add it again","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:20.245Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.458Z","_duration":5787,"uid":"test-00-0","cid":"0-0","title":"TestCase_1: Add one item to cart, remove it, add it again","fullTitle":"UserStory: Checkout.TestCase_1: Add one item to cart, remove it, add it again","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2e3fb1dd-4f0e-42b2-9b08-27d7cd13f0a3"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2e3fb1dd-4f0e-42b2-9b08-27d7cd13f0a3/clear","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2e3fb1dd-4f0e-42b2-9b08-27d7cd13f0a3/clear","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2e3fb1dd-4f0e-42b2-9b08-27d7cd13f0a3/value","body":{"text":"standard_user"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2e3fb1dd-4f0e-42b2-9b08-27d7cd13f0a3/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e80d19e1-e4b4-422f-bbd2-1475c1482309"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e80d19e1-e4b4-422f-bbd2-1475c1482309/clear","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e80d19e1-e4b4-422f-bbd2-1475c1482309/clear","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e80d19e1-e4b4-422f-bbd2-1475c1482309/value","body":{"text":"secret_sauce"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e80d19e1-e4b4-422f-bbd2-1475c1482309/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6c6b1058-579b-4643-aa38-4e695f360d66"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6c6b1058-579b-4643-aa38-4e695f360d66/click","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6c6b1058-579b-4643-aa38-4e695f360d66/click","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"39fa33c9-3aa9-4c18-89eb-e5c1f90189cc"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/39fa33c9-3aa9-4c18-89eb-e5c1f90189cc/text","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/39fa33c9-3aa9-4c18-89eb-e5c1f90189cc/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"70a36676-3173-4685-8099-92331c6e64bb"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/70a36676-3173-4685-8099-92331c6e64bb/click","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/70a36676-3173-4685-8099-92331c6e64bb/click","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c18409f4-cf0f-4b24-964f-8f9a94ace718"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c18409f4-cf0f-4b24-964f-8f9a94ace718"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c18409f4-cf0f-4b24-964f-8f9a94ace718/text","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c18409f4-cf0f-4b24-964f-8f9a94ace718/text","body":{},"result":{"value":"1"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#remove-sauce-labs-backpack"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#remove-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5653d945-3bea-499f-ba68-c54f4ec57611"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5653d945-3bea-499f-ba68-c54f4ec57611/click","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c18409f4-cf0f-4b24-964f-8f9a94ace718"}]},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5653d945-3bea-499f-ba68-c54f4ec57611/click","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ca1356de-a955-4b51-9586-c7af7be08cdc"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca1356de-a955-4b51-9586-c7af7be08cdc/click","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca1356de-a955-4b51-9586-c7af7be08cdc/click","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9714dacc-5466-4c36-95f4-833115ece299"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9714dacc-5466-4c36-95f4-833115ece299"}},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9714dacc-5466-4c36-95f4-833115ece299"}]},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9714dacc-5466-4c36-95f4-833115ece299/text","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9714dacc-5466-4c36-95f4-833115ece299/text","body":{},"result":{"value":"1"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9714dacc-5466-4c36-95f4-833115ece299"}]},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"55a3aab9220ccc38b72f8b4e017ca8c1","cid":"0-0","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:20.245Z"}],"uid":"suite-0-0","cid":"0-0","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout1.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:20.256Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.669Z","_duration":17544,"tests":[{"type":"test","start":"2022-02-18T00:48:14.670Z","_duration":17527,"uid":"test-00-0","cid":"0-4","title":"TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:32.197Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.670Z","_duration":17527,"uid":"test-00-0","cid":"0-4","title":"TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c74b8f29-1b6b-4744-b743-80c1ded46b6a"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c74b8f29-1b6b-4744-b743-80c1ded46b6a/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c74b8f29-1b6b-4744-b743-80c1ded46b6a/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c74b8f29-1b6b-4744-b743-80c1ded46b6a/value","body":{"text":"standard_user"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c74b8f29-1b6b-4744-b743-80c1ded46b6a/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4c913f90-62e7-4a76-8d27-a05e0f3b7cae"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4c913f90-62e7-4a76-8d27-a05e0f3b7cae/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4c913f90-62e7-4a76-8d27-a05e0f3b7cae/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4c913f90-62e7-4a76-8d27-a05e0f3b7cae/value","body":{"text":"secret_sauce"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4c913f90-62e7-4a76-8d27-a05e0f3b7cae/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"561bf683-6b2a-4bfd-af11-4ce2335e35b2"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/561bf683-6b2a-4bfd-af11-4ce2335e35b2/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/561bf683-6b2a-4bfd-af11-4ce2335e35b2/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fb89d6b3-5c4c-49b5-b56e-653013f7f622"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fb89d6b3-5c4c-49b5-b56e-653013f7f622/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fb89d6b3-5c4c-49b5-b56e-653013f7f622/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6007e196-1417-498e-b0f0-4af482a8903d"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6007e196-1417-498e-b0f0-4af482a8903d/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6007e196-1417-498e-b0f0-4af482a8903d/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0c64c3fe-b1e5-4904-940d-641e8e2badf6"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0c64c3fe-b1e5-4904-940d-641e8e2badf6"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0c64c3fe-b1e5-4904-940d-641e8e2badf6/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0c64c3fe-b1e5-4904-940d-641e8e2badf6/text","body":{},"result":{"value":"1"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0c2c6f8f-a660-4408-a008-82e904b337ad"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0c2c6f8f-a660-4408-a008-82e904b337ad/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0c64c3fe-b1e5-4904-940d-641e8e2badf6"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0c2c6f8f-a660-4408-a008-82e904b337ad/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ec2619e8-2d25-48ad-b32e-a54de590079f"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ec2619e8-2d25-48ad-b32e-a54de590079f/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ec2619e8-2d25-48ad-b32e-a54de590079f/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"20d83f43-4d69-40f2-9fea-a1fd8ef90613"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/20d83f43-4d69-40f2-9fea-a1fd8ef90613/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/20d83f43-4d69-40f2-9fea-a1fd8ef90613/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1fbb8c08-dbee-4050-8fe4-60ff84aab55b"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1fbb8c08-dbee-4050-8fe4-60ff84aab55b"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1fbb8c08-dbee-4050-8fe4-60ff84aab55b"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1fbb8c08-dbee-4050-8fe4-60ff84aab55b/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1fbb8c08-dbee-4050-8fe4-60ff84aab55b/text","body":{},"result":{"value":"1"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd26b6c1-307c-4a82-be20-a9e7123783e6"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1fbb8c08-dbee-4050-8fe4-60ff84aab55b"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7bf8d39d-5f52-49b8-a872-c586b46bb2b5"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c049ebc4-39f0-4134-b127-9391924bdb07"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd26b6c1-307c-4a82-be20-a9e7123783e6"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd26b6c1-307c-4a82-be20-a9e7123783e6/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd26b6c1-307c-4a82-be20-a9e7123783e6/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd26b6c1-307c-4a82-be20-a9e7123783e6/value","body":{"text":"Jane"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd26b6c1-307c-4a82-be20-a9e7123783e6/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7bf8d39d-5f52-49b8-a872-c586b46bb2b5"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7bf8d39d-5f52-49b8-a872-c586b46bb2b5/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7bf8d39d-5f52-49b8-a872-c586b46bb2b5/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7bf8d39d-5f52-49b8-a872-c586b46bb2b5/value","body":{"text":"Doe"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7bf8d39d-5f52-49b8-a872-c586b46bb2b5/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c049ebc4-39f0-4134-b127-9391924bdb07"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c049ebc4-39f0-4134-b127-9391924bdb07/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c049ebc4-39f0-4134-b127-9391924bdb07/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c049ebc4-39f0-4134-b127-9391924bdb07/value","body":{"text":"90210"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c049ebc4-39f0-4134-b127-9391924bdb07/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1a66d0be-9a30-4712-9838-6505a33b5416"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1a66d0be-9a30-4712-9838-6505a33b5416/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1a66d0be-9a30-4712-9838-6505a33b5416/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d9fef34c-ffe3-42b7-919c-25f4c59e96fd"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d9fef34c-ffe3-42b7-919c-25f4c59e96fd/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d9fef34c-ffe3-42b7-919c-25f4c59e96fd/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"83546c55-b811-4c67-8441-7413d01a9ec7"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/83546c55-b811-4c67-8441-7413d01a9ec7/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/83546c55-b811-4c67-8441-7413d01a9ec7/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":true},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":false},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":true},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":false},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":true},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":false},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":true},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":false},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":true},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d10dff6a-0142-40d5-856e-5caab4bea30f","ELEMENT":"d10dff6a-0142-40d5-856e-5caab4bea30f"}]},"result":{"value":true},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d10dff6a-0142-40d5-856e-5caab4bea30f/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d10dff6a-0142-40d5-856e-5caab4bea30f/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b4759823-7c23-4ab0-a796-3e26d73ccbef"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b4759823-7c23-4ab0-a796-3e26d73ccbef/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b4759823-7c23-4ab0-a796-3e26d73ccbef/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b4759823-7c23-4ab0-a796-3e26d73ccbef/value","body":{"text":"standard_user"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b4759823-7c23-4ab0-a796-3e26d73ccbef/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d9b2d1e5-746e-41c5-bbbe-2102caeed2b1"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d9b2d1e5-746e-41c5-bbbe-2102caeed2b1/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d9b2d1e5-746e-41c5-bbbe-2102caeed2b1/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d9b2d1e5-746e-41c5-bbbe-2102caeed2b1/value","body":{"text":"secret_sauce"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d9b2d1e5-746e-41c5-bbbe-2102caeed2b1/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"85dcf795-a61c-4563-b80b-39afbceb5359"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/85dcf795-a61c-4563-b80b-39afbceb5359/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/85dcf795-a61c-4563-b80b-39afbceb5359/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b1e46355-a146-4a11-96b8-c2f289e1b7a7"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b1e46355-a146-4a11-96b8-c2f289e1b7a7/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b1e46355-a146-4a11-96b8-c2f289e1b7a7/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"072a64f7-b6df-4c6d-9d74-a14ac599ddaf"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"072a64f7-b6df-4c6d-9d74-a14ac599ddaf"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/072a64f7-b6df-4c6d-9d74-a14ac599ddaf/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/072a64f7-b6df-4c6d-9d74-a14ac599ddaf/text","body":{},"result":{"value":"1"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"072a64f7-b6df-4c6d-9d74-a14ac599ddaf"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9c3eb304-84d8-434a-879f-a1739f70060c"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9c3eb304-84d8-434a-879f-a1739f70060c/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9c3eb304-84d8-434a-879f-a1739f70060c/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"574fa9fe-a9d4-45df-bab3-54e63a632200"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/574fa9fe-a9d4-45df-bab3-54e63a632200/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/574fa9fe-a9d4-45df-bab3-54e63a632200/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a481722e-b4fc-4f85-8344-291086703225"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a481722e-b4fc-4f85-8344-291086703225"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a481722e-b4fc-4f85-8344-291086703225/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a481722e-b4fc-4f85-8344-291086703225/text","body":{},"result":{"value":"1"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a481722e-b4fc-4f85-8344-291086703225"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b1c5d6b7-7d48-455b-95bd-7967d5c09d65"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b1c5d6b7-7d48-455b-95bd-7967d5c09d65/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b1c5d6b7-7d48-455b-95bd-7967d5c09d65/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b079d7c2-b562-4533-8969-30e74daae832"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b079d7c2-b562-4533-8969-30e74daae832/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b079d7c2-b562-4533-8969-30e74daae832/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"06795fa1-24b2-485f-a641-21a6670a3e3b"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"06795fa1-24b2-485f-a641-21a6670a3e3b"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/06795fa1-24b2-485f-a641-21a6670a3e3b/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/06795fa1-24b2-485f-a641-21a6670a3e3b/text","body":{},"result":{"value":"1"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"06795fa1-24b2-485f-a641-21a6670a3e3b"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"349cfac9-7a81-4a26-a3fd-14cc09933285"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"98814d3b-96b7-47ee-ba14-ad23f5266df9"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a38945d-bd51-4c0b-a39f-7071716f8e98"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"349cfac9-7a81-4a26-a3fd-14cc09933285"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/349cfac9-7a81-4a26-a3fd-14cc09933285/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/349cfac9-7a81-4a26-a3fd-14cc09933285/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/349cfac9-7a81-4a26-a3fd-14cc09933285/value","body":{"text":"Jane"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/349cfac9-7a81-4a26-a3fd-14cc09933285/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"98814d3b-96b7-47ee-ba14-ad23f5266df9"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/98814d3b-96b7-47ee-ba14-ad23f5266df9/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/98814d3b-96b7-47ee-ba14-ad23f5266df9/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/98814d3b-96b7-47ee-ba14-ad23f5266df9/value","body":{"text":"Doe"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/98814d3b-96b7-47ee-ba14-ad23f5266df9/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a38945d-bd51-4c0b-a39f-7071716f8e98"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8a38945d-bd51-4c0b-a39f-7071716f8e98/clear","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8a38945d-bd51-4c0b-a39f-7071716f8e98/clear","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8a38945d-bd51-4c0b-a39f-7071716f8e98/value","body":{"text":"90210"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8a38945d-bd51-4c0b-a39f-7071716f8e98/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fe5dc0ea-44c6-4918-91fd-7cf32e99a28e"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fe5dc0ea-44c6-4918-91fd-7cf32e99a28e/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fe5dc0ea-44c6-4918-91fd-7cf32e99a28e/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"451f3acb-d6af-4b75-9df8-4b453d9f6be5"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/451f3acb-d6af-4b75-9df8-4b453d9f6be5/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/451f3acb-d6af-4b75-9df8-4b453d9f6be5/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6928bf23-7db9-423e-8ff2-2fb890982d6f"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6928bf23-7db9-423e-8ff2-2fb890982d6f"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6928bf23-7db9-423e-8ff2-2fb890982d6f/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6928bf23-7db9-423e-8ff2-2fb890982d6f/text","body":{},"result":{"value":"1"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6928bf23-7db9-423e-8ff2-2fb890982d6f"}]},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"792231fb-0b69-46fa-8a16-bb192504eebf"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/792231fb-0b69-46fa-8a16-bb192504eebf/click","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/792231fb-0b69-46fa-8a16-bb192504eebf/click","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0d00cba9-4afd-47eb-b5d7-c303d786cb09"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0d00cba9-4afd-47eb-b5d7-c303d786cb09/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0d00cba9-4afd-47eb-b5d7-c303d786cb09/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ada44c64-9f64-4eff-b877-ddde6f62e20f"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ada44c64-9f64-4eff-b877-ddde6f62e20f"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ada44c64-9f64-4eff-b877-ddde6f62e20f/text","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ada44c64-9f64-4eff-b877-ddde6f62e20f/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"5d0b188845ec8d721f48a4aae228731d","cid":"0-4","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:32.197Z"}],"uid":"suite-0-0","cid":"0-4","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T00:48:32.216Z"},{"type":"suite:start","start":"2022-02-18T00:48:14.885Z","_duration":615193,"tests":[{"type":"test","start":"2022-02-18T00:48:14.886Z","_duration":615183,"uid":"test-00-0","cid":"0-3","title":"TestCase_12: (TestCase_2 modified) should be able to add one item to cart, delay on CheckoutStep1 page,logged out, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_12: (TestCase_2 modified) should be able to add one item to cart, delay on CheckoutStep1 page,logged out, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:30.069Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.886Z","_duration":615183,"uid":"test-00-0","cid":"0-3","title":"TestCase_12: (TestCase_2 modified) should be able to add one item to cart, delay on CheckoutStep1 page,logged out, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_12: (TestCase_2 modified) should be able to add one item to cart, delay on CheckoutStep1 page,logged out, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a6871bd-e7b3-4c3c-bb52-621b69c1003c"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8a6871bd-e7b3-4c3c-bb52-621b69c1003c/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8a6871bd-e7b3-4c3c-bb52-621b69c1003c/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8a6871bd-e7b3-4c3c-bb52-621b69c1003c/value","body":{"text":"standard_user"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8a6871bd-e7b3-4c3c-bb52-621b69c1003c/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a4b08278-d1f0-460a-b6cf-bdbbc0f84a11"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a4b08278-d1f0-460a-b6cf-bdbbc0f84a11/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a4b08278-d1f0-460a-b6cf-bdbbc0f84a11/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a4b08278-d1f0-460a-b6cf-bdbbc0f84a11/value","body":{"text":"secret_sauce"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a4b08278-d1f0-460a-b6cf-bdbbc0f84a11/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b7b162e6-d0a3-47e2-a069-ba123acb56bc"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b7b162e6-d0a3-47e2-a069-ba123acb56bc/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b7b162e6-d0a3-47e2-a069-ba123acb56bc/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"93ed56dd-078f-49ce-8a6d-3af0e8a51fd8"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/93ed56dd-078f-49ce-8a6d-3af0e8a51fd8/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/93ed56dd-078f-49ce-8a6d-3af0e8a51fd8/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c06cac8c-29ca-47cf-aac8-e74d2ae7a7f7"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c06cac8c-29ca-47cf-aac8-e74d2ae7a7f7/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c06cac8c-29ca-47cf-aac8-e74d2ae7a7f7/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8f77f690-2ce3-4ba7-857c-1830ce4fd121"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8f77f690-2ce3-4ba7-857c-1830ce4fd121"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8f77f690-2ce3-4ba7-857c-1830ce4fd121/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8f77f690-2ce3-4ba7-857c-1830ce4fd121/text","body":{},"result":{"value":"1"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8f77f690-2ce3-4ba7-857c-1830ce4fd121"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"094f2fb0-28c9-4b2f-99a8-0aa2b548f27e"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/094f2fb0-28c9-4b2f-99a8-0aa2b548f27e/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/094f2fb0-28c9-4b2f-99a8-0aa2b548f27e/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0c81ebdc-6f04-4033-9425-d38358c983cb"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0c81ebdc-6f04-4033-9425-d38358c983cb/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0c81ebdc-6f04-4033-9425-d38358c983cb/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6d5fbe09-808b-44f0-b743-bb498cc04485"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6d5fbe09-808b-44f0-b743-bb498cc04485/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6d5fbe09-808b-44f0-b743-bb498cc04485/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e66e2c91-b075-491f-90b0-5abfc03da1f4"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"933e761a-1c29-4c29-809c-f8b2b1bd1b5e"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9757da4f-80a5-417c-b068-9711383fffeb"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e66e2c91-b075-491f-90b0-5abfc03da1f4"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e66e2c91-b075-491f-90b0-5abfc03da1f4/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e66e2c91-b075-491f-90b0-5abfc03da1f4/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e66e2c91-b075-491f-90b0-5abfc03da1f4/value","body":{"text":"Jane"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e66e2c91-b075-491f-90b0-5abfc03da1f4/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"933e761a-1c29-4c29-809c-f8b2b1bd1b5e"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/933e761a-1c29-4c29-809c-f8b2b1bd1b5e/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/933e761a-1c29-4c29-809c-f8b2b1bd1b5e/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/933e761a-1c29-4c29-809c-f8b2b1bd1b5e/value","body":{"text":"Doe"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/933e761a-1c29-4c29-809c-f8b2b1bd1b5e/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9757da4f-80a5-417c-b068-9711383fffeb"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9757da4f-80a5-417c-b068-9711383fffeb/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9757da4f-80a5-417c-b068-9711383fffeb/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9757da4f-80a5-417c-b068-9711383fffeb/value","body":{"text":"90210"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9757da4f-80a5-417c-b068-9711383fffeb/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e231035f-0107-4d41-97fb-5aec4bd99a60"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e231035f-0107-4d41-97fb-5aec4bd99a60","ELEMENT":"e231035f-0107-4d41-97fb-5aec4bd99a60"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"e231035f-0107-4d41-97fb-5aec4bd99a60","ELEMENT":"e231035f-0107-4d41-97fb-5aec4bd99a60"}]},"result":{"value":true},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e231035f-0107-4d41-97fb-5aec4bd99a60/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e231035f-0107-4d41-97fb-5aec4bd99a60/text","body":{},"result":{"value":"Epic sadface: You can only access '/checkout-step-one.html' when you are logged in."},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"591bac1b-7a68-4ef0-ae3d-5a3fe45d0382"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/591bac1b-7a68-4ef0-ae3d-5a3fe45d0382/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/591bac1b-7a68-4ef0-ae3d-5a3fe45d0382/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/591bac1b-7a68-4ef0-ae3d-5a3fe45d0382/value","body":{"text":"standard_user"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/591bac1b-7a68-4ef0-ae3d-5a3fe45d0382/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d17accb-5ac1-4f44-8634-85e44b726b32"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2d17accb-5ac1-4f44-8634-85e44b726b32/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2d17accb-5ac1-4f44-8634-85e44b726b32/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2d17accb-5ac1-4f44-8634-85e44b726b32/value","body":{"text":"secret_sauce"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2d17accb-5ac1-4f44-8634-85e44b726b32/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"74976d2a-fb64-4508-af63-36b6f825b9a2"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/74976d2a-fb64-4508-af63-36b6f825b9a2/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/74976d2a-fb64-4508-af63-36b6f825b9a2/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6cfde738-50b2-4e9f-9bd5-d130bf14d0f8"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6cfde738-50b2-4e9f-9bd5-d130bf14d0f8/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6cfde738-50b2-4e9f-9bd5-d130bf14d0f8/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80fa5ae4-d1d9-470b-85a8-1523dbb65c40"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80fa5ae4-d1d9-470b-85a8-1523dbb65c40"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80fa5ae4-d1d9-470b-85a8-1523dbb65c40/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80fa5ae4-d1d9-470b-85a8-1523dbb65c40/text","body":{},"result":{"value":"1"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80fa5ae4-d1d9-470b-85a8-1523dbb65c40"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0da742e8-c1d1-462b-9382-82593aefbd14"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0da742e8-c1d1-462b-9382-82593aefbd14/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0da742e8-c1d1-462b-9382-82593aefbd14/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4ae0bcd-1b1d-4f4f-9e97-c26207941a53"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d4ae0bcd-1b1d-4f4f-9e97-c26207941a53/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d4ae0bcd-1b1d-4f4f-9e97-c26207941a53/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1e891ae6-38e2-416c-ae17-cb3273be504a"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1e891ae6-38e2-416c-ae17-cb3273be504a"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e891ae6-38e2-416c-ae17-cb3273be504a"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1e891ae6-38e2-416c-ae17-cb3273be504a/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1e891ae6-38e2-416c-ae17-cb3273be504a/text","body":{},"result":{"value":"1"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1e891ae6-38e2-416c-ae17-cb3273be504a"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9c448b0e-8acf-4043-998f-7514459bf310"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9c448b0e-8acf-4043-998f-7514459bf310/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9c448b0e-8acf-4043-998f-7514459bf310/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cce6a87a-f933-4fca-8809-63aa5b1f5a19"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/cce6a87a-f933-4fca-8809-63aa5b1f5a19/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/cce6a87a-f933-4fca-8809-63aa5b1f5a19/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"96c13fe4-51b9-4248-b234-b3b4b625f099"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"96c13fe4-51b9-4248-b234-b3b4b625f099"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/96c13fe4-51b9-4248-b234-b3b4b625f099/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"96c13fe4-51b9-4248-b234-b3b4b625f099"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/96c13fe4-51b9-4248-b234-b3b4b625f099/text","body":{},"result":{"value":"1"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"06e88bf6-0293-4bba-9a0a-88c9f0184faf"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc4ae6d5-046b-44ea-b0dd-60538c3fbf25"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b04da606-ab0f-4dc9-b508-dd0b7e711ca0"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"06e88bf6-0293-4bba-9a0a-88c9f0184faf"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/06e88bf6-0293-4bba-9a0a-88c9f0184faf/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/06e88bf6-0293-4bba-9a0a-88c9f0184faf/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/06e88bf6-0293-4bba-9a0a-88c9f0184faf/value","body":{"text":"Jane"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/06e88bf6-0293-4bba-9a0a-88c9f0184faf/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc4ae6d5-046b-44ea-b0dd-60538c3fbf25"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cc4ae6d5-046b-44ea-b0dd-60538c3fbf25/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cc4ae6d5-046b-44ea-b0dd-60538c3fbf25/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cc4ae6d5-046b-44ea-b0dd-60538c3fbf25/value","body":{"text":"Doe"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cc4ae6d5-046b-44ea-b0dd-60538c3fbf25/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b04da606-ab0f-4dc9-b508-dd0b7e711ca0"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b04da606-ab0f-4dc9-b508-dd0b7e711ca0/clear","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b04da606-ab0f-4dc9-b508-dd0b7e711ca0/clear","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b04da606-ab0f-4dc9-b508-dd0b7e711ca0/value","body":{"text":"90210"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b04da606-ab0f-4dc9-b508-dd0b7e711ca0/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95047f15-5dfe-4f3b-877d-2474d1edbce0"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/95047f15-5dfe-4f3b-877d-2474d1edbce0/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/95047f15-5dfe-4f3b-877d-2474d1edbce0/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1c8b7f78-1d45-4419-b9cb-9a3707c13d0c"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1c8b7f78-1d45-4419-b9cb-9a3707c13d0c/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1c8b7f78-1d45-4419-b9cb-9a3707c13d0c/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bdae7d74-9cc2-4d8a-949e-fb7fd9b61be7"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bdae7d74-9cc2-4d8a-949e-fb7fd9b61be7"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bdae7d74-9cc2-4d8a-949e-fb7fd9b61be7/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"bdae7d74-9cc2-4d8a-949e-fb7fd9b61be7"}]},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bdae7d74-9cc2-4d8a-949e-fb7fd9b61be7/text","body":{},"result":{"value":"1"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf4190d9-82dd-44a6-847d-0cd28dc2db22"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cf4190d9-82dd-44a6-847d-0cd28dc2db22/click","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cf4190d9-82dd-44a6-847d-0cd28dc2db22/click","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"39aa9be2-7022-40da-a265-d92ee312c5e1"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/39aa9be2-7022-40da-a265-d92ee312c5e1/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/39aa9be2-7022-40da-a265-d92ee312c5e1/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"21954eab-7701-4394-8b7a-5dcffd181fda"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"21954eab-7701-4394-8b7a-5dcffd181fda"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/21954eab-7701-4394-8b7a-5dcffd181fda/text","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/21954eab-7701-4394-8b7a-5dcffd181fda/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"e69f780f43a82eb2c258cceefa89d93a","cid":"0-3","type":"result"}],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:30.069Z"}],"uid":"suite-0-0","cid":"0-3","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout12-checkout1-delay.e2e.js","title":"UserStory: Delay","fullTitle":"UserStory: Delay","parent":"","end":"2022-02-18T00:58:30.078Z"},{"type":"suite:start","start":"2022-02-18T00:48:15.427Z","_duration":7670,"tests":[{"type":"test","start":"2022-02-18T00:48:15.428Z","_duration":7658,"uid":"test-00-0","cid":"0-9","title":"TestCase_2: Add one item to cart and check it out successfully","fullTitle":"UserStory: Checkout.TestCase_2: Add one item to cart and check it out successfully","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:23.086Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:15.428Z","_duration":7658,"uid":"test-00-0","cid":"0-9","title":"TestCase_2: Add one item to cart and check it out successfully","fullTitle":"UserStory: Checkout.TestCase_2: Add one item to cart and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f2a55907-8532-4ef4-a991-f420a37c8873"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f2a55907-8532-4ef4-a991-f420a37c8873/clear","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f2a55907-8532-4ef4-a991-f420a37c8873/clear","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f2a55907-8532-4ef4-a991-f420a37c8873/value","body":{"text":"standard_user"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f2a55907-8532-4ef4-a991-f420a37c8873/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fee8a859-04c1-4573-8c30-ebba8d3ea764"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fee8a859-04c1-4573-8c30-ebba8d3ea764/clear","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fee8a859-04c1-4573-8c30-ebba8d3ea764/clear","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fee8a859-04c1-4573-8c30-ebba8d3ea764/value","body":{"text":"secret_sauce"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fee8a859-04c1-4573-8c30-ebba8d3ea764/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bfa2dd5b-e192-4fd8-b54b-0d898713402b"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bfa2dd5b-e192-4fd8-b54b-0d898713402b/click","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bfa2dd5b-e192-4fd8-b54b-0d898713402b/click","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ffba90b0-7767-4d10-b56b-2e18c7c8a727"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ffba90b0-7767-4d10-b56b-2e18c7c8a727/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ffba90b0-7767-4d10-b56b-2e18c7c8a727/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"340fba76-6296-4528-bda5-123db5e4f951"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/340fba76-6296-4528-bda5-123db5e4f951/click","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/340fba76-6296-4528-bda5-123db5e4f951/click","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"74a13f90-35d4-4eee-84bf-d2d005a1bc05"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"74a13f90-35d4-4eee-84bf-d2d005a1bc05"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/74a13f90-35d4-4eee-84bf-d2d005a1bc05/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/74a13f90-35d4-4eee-84bf-d2d005a1bc05/text","body":{},"result":{"value":"1"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"74a13f90-35d4-4eee-84bf-d2d005a1bc05"}]},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"72c21a59-eb73-44a3-ad3a-72cba90b4349"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/72c21a59-eb73-44a3-ad3a-72cba90b4349/click","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/72c21a59-eb73-44a3-ad3a-72cba90b4349/click","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"36c47c1b-de77-4cb3-abe4-2e6209a7e9e3"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/36c47c1b-de77-4cb3-abe4-2e6209a7e9e3/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/36c47c1b-de77-4cb3-abe4-2e6209a7e9e3/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a7c8e5e1-8c64-4c80-ba1b-d4a7e772ecbf"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a7c8e5e1-8c64-4c80-ba1b-d4a7e772ecbf"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a7c8e5e1-8c64-4c80-ba1b-d4a7e772ecbf/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a7c8e5e1-8c64-4c80-ba1b-d4a7e772ecbf/text","body":{},"result":{"value":"1"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a7c8e5e1-8c64-4c80-ba1b-d4a7e772ecbf"}]},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"970da718-ab65-4f60-b012-420e6ff66127"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/970da718-ab65-4f60-b012-420e6ff66127/click","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/970da718-ab65-4f60-b012-420e6ff66127/click","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3f04e989-cf80-4b29-afa3-7712e28dbe05"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3f04e989-cf80-4b29-afa3-7712e28dbe05/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3f04e989-cf80-4b29-afa3-7712e28dbe05/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e350e0fa-c175-42b9-96c6-08db01684b6c"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e350e0fa-c175-42b9-96c6-08db01684b6c"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e350e0fa-c175-42b9-96c6-08db01684b6c/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e350e0fa-c175-42b9-96c6-08db01684b6c/text","body":{},"result":{"value":"1"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e350e0fa-c175-42b9-96c6-08db01684b6c"}]},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30b26988-1f99-4945-93a1-fedcb0c7e3db"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d0b75037-52b8-49b6-b80e-a05eb1ae91c3"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5f618f99-d15e-4737-b630-2b49d3e3da46"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30b26988-1f99-4945-93a1-fedcb0c7e3db"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/30b26988-1f99-4945-93a1-fedcb0c7e3db/clear","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/30b26988-1f99-4945-93a1-fedcb0c7e3db/clear","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/30b26988-1f99-4945-93a1-fedcb0c7e3db/value","body":{"text":"Jane"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/30b26988-1f99-4945-93a1-fedcb0c7e3db/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d0b75037-52b8-49b6-b80e-a05eb1ae91c3"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d0b75037-52b8-49b6-b80e-a05eb1ae91c3/clear","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d0b75037-52b8-49b6-b80e-a05eb1ae91c3/clear","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d0b75037-52b8-49b6-b80e-a05eb1ae91c3/value","body":{"text":"Doe"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d0b75037-52b8-49b6-b80e-a05eb1ae91c3/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5f618f99-d15e-4737-b630-2b49d3e3da46"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5f618f99-d15e-4737-b630-2b49d3e3da46/clear","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5f618f99-d15e-4737-b630-2b49d3e3da46/clear","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5f618f99-d15e-4737-b630-2b49d3e3da46/value","body":{"text":"90210"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5f618f99-d15e-4737-b630-2b49d3e3da46/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30b26988-1f99-4945-93a1-fedcb0c7e3db"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/30b26988-1f99-4945-93a1-fedcb0c7e3db/property/value","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/30b26988-1f99-4945-93a1-fedcb0c7e3db/property/value","body":{},"result":{"value":"Jane"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d0b75037-52b8-49b6-b80e-a05eb1ae91c3"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d0b75037-52b8-49b6-b80e-a05eb1ae91c3/property/value","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d0b75037-52b8-49b6-b80e-a05eb1ae91c3/property/value","body":{},"result":{"value":"Doe"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5f618f99-d15e-4737-b630-2b49d3e3da46"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5f618f99-d15e-4737-b630-2b49d3e3da46/property/value","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5f618f99-d15e-4737-b630-2b49d3e3da46/property/value","body":{},"result":{"value":"90210"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cafd1ce8-fa16-4bf3-b250-ebe5be95f646"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cafd1ce8-fa16-4bf3-b250-ebe5be95f646/click","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cafd1ce8-fa16-4bf3-b250-ebe5be95f646/click","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7d11e973-28bd-4af7-939b-c248f4e2b3db"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7d11e973-28bd-4af7-939b-c248f4e2b3db/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7d11e973-28bd-4af7-939b-c248f4e2b3db/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"39b55fa0-4b4a-416c-aebc-feb5d49525b6"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"39b55fa0-4b4a-416c-aebc-feb5d49525b6"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/39b55fa0-4b4a-416c-aebc-feb5d49525b6/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/39b55fa0-4b4a-416c-aebc-feb5d49525b6/text","body":{},"result":{"value":"1"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"39b55fa0-4b4a-416c-aebc-feb5d49525b6"}]},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"83f7ce1d-c92a-4637-880a-9580d30c4ff6"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/83f7ce1d-c92a-4637-880a-9580d30c4ff6/click","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/83f7ce1d-c92a-4637-880a-9580d30c4ff6/click","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1965f4bc-d19a-4ad6-a345-756fdc28ecb5"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1965f4bc-d19a-4ad6-a345-756fdc28ecb5/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1965f4bc-d19a-4ad6-a345-756fdc28ecb5/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"309421a1-ccd7-4b8c-bc8b-4cf8557d048e"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"309421a1-ccd7-4b8c-bc8b-4cf8557d048e"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/309421a1-ccd7-4b8c-bc8b-4cf8557d048e/text","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/309421a1-ccd7-4b8c-bc8b-4cf8557d048e/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"1fef8cab1c6cee748608f526b2238625","cid":"0-9","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:23.086Z"}],"uid":"suite-0-0","cid":"0-9","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout2.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:23.098Z"},{"type":"suite:start","start":"2022-02-18T00:48:25.210Z","_duration":10805,"tests":[{"type":"test","start":"2022-02-18T00:48:25.211Z","_duration":10793,"uid":"test-00-0","cid":"0-10","title":"TestCase_3: Add multiple items to cart, Continue shopping from cart and remove 1 item, Cancel from Checkout1, to successful checkout","fullTitle":"UserStory: Checkout.TestCase_3: Add multiple items to cart, Continue shopping from cart and remove 1 item, Cancel from Checkout1, to successful checkout","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:36.004Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:25.211Z","_duration":10793,"uid":"test-00-0","cid":"0-10","title":"TestCase_3: Add multiple items to cart, Continue shopping from cart and remove 1 item, Cancel from Checkout1, to successful checkout","fullTitle":"UserStory: Checkout.TestCase_3: Add multiple items to cart, Continue shopping from cart and remove 1 item, Cancel from Checkout1, to successful checkout","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6dee9108-366c-45ae-95d0-f9a33c8eb5af"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6dee9108-366c-45ae-95d0-f9a33c8eb5af/clear","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6dee9108-366c-45ae-95d0-f9a33c8eb5af/clear","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6dee9108-366c-45ae-95d0-f9a33c8eb5af/value","body":{"text":"standard_user"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6dee9108-366c-45ae-95d0-f9a33c8eb5af/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7bfcb95b-45dc-49e6-9e8b-5f2923ee54b3"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7bfcb95b-45dc-49e6-9e8b-5f2923ee54b3/clear","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7bfcb95b-45dc-49e6-9e8b-5f2923ee54b3/clear","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7bfcb95b-45dc-49e6-9e8b-5f2923ee54b3/value","body":{"text":"secret_sauce"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7bfcb95b-45dc-49e6-9e8b-5f2923ee54b3/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"58b372f7-032a-4821-813c-6b0e4c032744"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/58b372f7-032a-4821-813c-6b0e4c032744/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/58b372f7-032a-4821-813c-6b0e4c032744/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1a19573e-0345-4110-8a60-e5aec884f38e"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1a19573e-0345-4110-8a60-e5aec884f38e/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1a19573e-0345-4110-8a60-e5aec884f38e/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fdfd4ded-686b-4054-82b6-1ec3ff6b9c7c"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fdfd4ded-686b-4054-82b6-1ec3ff6b9c7c/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fdfd4ded-686b-4054-82b6-1ec3ff6b9c7c/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"215e3449-626b-4546-84fc-03e4382efafa"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/215e3449-626b-4546-84fc-03e4382efafa/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/215e3449-626b-4546-84fc-03e4382efafa/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bolt-t-shirt"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bolt-t-shirt"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"90fcb98c-661c-43ab-af83-90a9cb3cf267"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/90fcb98c-661c-43ab-af83-90a9cb3cf267/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/90fcb98c-661c-43ab-af83-90a9cb3cf267/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"33128493-e86d-44d0-bb54-0ac3a4ae3d96"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"33128493-e86d-44d0-bb54-0ac3a4ae3d96"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/33128493-e86d-44d0-bb54-0ac3a4ae3d96/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/33128493-e86d-44d0-bb54-0ac3a4ae3d96/text","body":{},"result":{"value":"3"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8e481b0-69e8-491d-9eb8-5faa4ed9e5e0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d8e481b0-69e8-491d-9eb8-5faa4ed9e5e0/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d8e481b0-69e8-491d-9eb8-5faa4ed9e5e0/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a8879cf7-5e9b-4f56-a67a-2dca651f6f67"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ee264473-8058-458c-b441-3760b6a4c983"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ee264473-8058-458c-b441-3760b6a4c983/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ee264473-8058-458c-b441-3760b6a4c983/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a8879cf7-5e9b-4f56-a67a-2dca651f6f67"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a8879cf7-5e9b-4f56-a67a-2dca651f6f67"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a8879cf7-5e9b-4f56-a67a-2dca651f6f67/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a8879cf7-5e9b-4f56-a67a-2dca651f6f67/text","body":{},"result":{"value":"3"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#continue-shopping"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a8879cf7-5e9b-4f56-a67a-2dca651f6f67"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#continue-shopping"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"00d6901b-a6f1-4550-929f-1c0be56f760f"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/00d6901b-a6f1-4550-929f-1c0be56f760f/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/00d6901b-a6f1-4550-929f-1c0be56f760f/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9e7341e3-92d8-4076-a0b9-5783e3a991d3"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9e7341e3-92d8-4076-a0b9-5783e3a991d3/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9e7341e3-92d8-4076-a0b9-5783e3a991d3/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#remove-sauce-labs-bolt-t-shirt"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#remove-sauce-labs-bolt-t-shirt"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ad761353-eac4-4ab6-bf3b-c7688080f0aa"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ad761353-eac4-4ab6-bf3b-c7688080f0aa/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ad761353-eac4-4ab6-bf3b-c7688080f0aa/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e908c58d-9973-4e42-a7e2-0c95c094eff0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e908c58d-9973-4e42-a7e2-0c95c094eff0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e908c58d-9973-4e42-a7e2-0c95c094eff0/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e908c58d-9973-4e42-a7e2-0c95c094eff0/text","body":{},"result":{"value":"2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e908c58d-9973-4e42-a7e2-0c95c094eff0"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f31a039c-1430-4b19-8a70-7724b6e2d313"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f31a039c-1430-4b19-8a70-7724b6e2d313/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f31a039c-1430-4b19-8a70-7724b6e2d313/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"526d5f83-e307-469f-b002-31c9dd28c2b3"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/526d5f83-e307-469f-b002-31c9dd28c2b3/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/526d5f83-e307-469f-b002-31c9dd28c2b3/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1740d476-a842-4a5b-b4ff-090dcb09928d"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1740d476-a842-4a5b-b4ff-090dcb09928d"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1740d476-a842-4a5b-b4ff-090dcb09928d/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1740d476-a842-4a5b-b4ff-090dcb09928d/text","body":{},"result":{"value":"2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1740d476-a842-4a5b-b4ff-090dcb09928d"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f044cb99-170a-402b-9409-5850a1ac7cd0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f044cb99-170a-402b-9409-5850a1ac7cd0/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f044cb99-170a-402b-9409-5850a1ac7cd0/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4f611af9-fa7e-47da-ac42-64fed4800150"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4f611af9-fa7e-47da-ac42-64fed4800150/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4f611af9-fa7e-47da-ac42-64fed4800150/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95a4ec1c-587a-4a5d-9477-61dca639e8e2"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95a4ec1c-587a-4a5d-9477-61dca639e8e2"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/95a4ec1c-587a-4a5d-9477-61dca639e8e2/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/95a4ec1c-587a-4a5d-9477-61dca639e8e2/text","body":{},"result":{"value":"2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#cancel"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"95a4ec1c-587a-4a5d-9477-61dca639e8e2"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#cancel"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3f18cee2-ed47-461d-9f0c-f1d7a3be88ca"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3f18cee2-ed47-461d-9f0c-f1d7a3be88ca/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3f18cee2-ed47-461d-9f0c-f1d7a3be88ca/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5bc4943d-ebab-42a2-bf81-8b8d5f7322a0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5bc4943d-ebab-42a2-bf81-8b8d5f7322a0/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5bc4943d-ebab-42a2-bf81-8b8d5f7322a0/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f607dcde-f4bd-4d00-aa4d-c0906b5d2689"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f607dcde-f4bd-4d00-aa4d-c0906b5d2689"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f607dcde-f4bd-4d00-aa4d-c0906b5d2689/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f607dcde-f4bd-4d00-aa4d-c0906b5d2689/text","body":{},"result":{"value":"2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f607dcde-f4bd-4d00-aa4d-c0906b5d2689"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"93ac7642-7b83-48f6-8ff8-a5eeacf80457"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/93ac7642-7b83-48f6-8ff8-a5eeacf80457/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/93ac7642-7b83-48f6-8ff8-a5eeacf80457/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b33d0512-a45b-49b4-858e-ac0edf93d85e"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b33d0512-a45b-49b4-858e-ac0edf93d85e/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b33d0512-a45b-49b4-858e-ac0edf93d85e/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf90fda7-97b6-45e2-8717-acf173cf62d0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf90fda7-97b6-45e2-8717-acf173cf62d0"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/cf90fda7-97b6-45e2-8717-acf173cf62d0/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/cf90fda7-97b6-45e2-8717-acf173cf62d0/text","body":{},"result":{"value":"2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"cf90fda7-97b6-45e2-8717-acf173cf62d0"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d42046d-6604-44dc-ba4b-2f9385dcff22"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d50e4394-a0b7-4ee0-bf43-501ba02432f1"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"017fc4b4-6a7d-4938-b932-ec5223b3a0b5"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d42046d-6604-44dc-ba4b-2f9385dcff22"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2d42046d-6604-44dc-ba4b-2f9385dcff22/clear","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2d42046d-6604-44dc-ba4b-2f9385dcff22/clear","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2d42046d-6604-44dc-ba4b-2f9385dcff22/value","body":{"text":"Jane"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2d42046d-6604-44dc-ba4b-2f9385dcff22/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d50e4394-a0b7-4ee0-bf43-501ba02432f1"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d50e4394-a0b7-4ee0-bf43-501ba02432f1/clear","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d50e4394-a0b7-4ee0-bf43-501ba02432f1/clear","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d50e4394-a0b7-4ee0-bf43-501ba02432f1/value","body":{"text":"Doe"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d50e4394-a0b7-4ee0-bf43-501ba02432f1/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"cf90fda7-97b6-45e2-8717-acf173cf62d0"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"017fc4b4-6a7d-4938-b932-ec5223b3a0b5"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/017fc4b4-6a7d-4938-b932-ec5223b3a0b5/clear","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/017fc4b4-6a7d-4938-b932-ec5223b3a0b5/clear","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/017fc4b4-6a7d-4938-b932-ec5223b3a0b5/value","body":{"text":"90210"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/017fc4b4-6a7d-4938-b932-ec5223b3a0b5/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d42046d-6604-44dc-ba4b-2f9385dcff22"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2d42046d-6604-44dc-ba4b-2f9385dcff22/property/value","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2d42046d-6604-44dc-ba4b-2f9385dcff22/property/value","body":{},"result":{"value":"Jane"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d50e4394-a0b7-4ee0-bf43-501ba02432f1"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d50e4394-a0b7-4ee0-bf43-501ba02432f1/property/value","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d50e4394-a0b7-4ee0-bf43-501ba02432f1/property/value","body":{},"result":{"value":"Doe"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"017fc4b4-6a7d-4938-b932-ec5223b3a0b5"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/017fc4b4-6a7d-4938-b932-ec5223b3a0b5/property/value","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/017fc4b4-6a7d-4938-b932-ec5223b3a0b5/property/value","body":{},"result":{"value":"90210"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fae8fef-0f38-4cf5-80f4-0aa1127adc09"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fae8fef-0f38-4cf5-80f4-0aa1127adc09/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fae8fef-0f38-4cf5-80f4-0aa1127adc09/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fc0ca70-7a2e-446f-b45c-82ed3f57d3cc"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5fc0ca70-7a2e-446f-b45c-82ed3f57d3cc/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5fc0ca70-7a2e-446f-b45c-82ed3f57d3cc/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e42115a1-7a3b-4928-b802-4030a3edc6f1"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e42115a1-7a3b-4928-b802-4030a3edc6f1"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e42115a1-7a3b-4928-b802-4030a3edc6f1/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e42115a1-7a3b-4928-b802-4030a3edc6f1/text","body":{},"result":{"value":"2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e42115a1-7a3b-4928-b802-4030a3edc6f1"}]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9d77541a-fe90-4e0a-82b9-f78b1f15b2ee"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9d77541a-fe90-4e0a-82b9-f78b1f15b2ee/click","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9d77541a-fe90-4e0a-82b9-f78b1f15b2ee/click","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[]},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc24d0b1-9261-42b9-a28a-f52dda2862a1"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fc24d0b1-9261-42b9-a28a-f52dda2862a1/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fc24d0b1-9261-42b9-a28a-f52dda2862a1/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"14a939b2-98fb-4004-889d-9bc2c1cd68c6"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"14a939b2-98fb-4004-889d-9bc2c1cd68c6"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/14a939b2-98fb-4004-889d-9bc2c1cd68c6/text","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/14a939b2-98fb-4004-889d-9bc2c1cd68c6/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"5ac58d446b31235072b087582bd939e5","cid":"0-10","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:36.004Z"}],"uid":"suite-0-0","cid":"0-10","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout3.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:36.016Z"},{"type":"suite:start","start":"2022-02-18T00:48:27.603Z","_duration":5850,"tests":[{"type":"test","start":"2022-02-18T00:48:27.604Z","_duration":5839,"uid":"test-00-0","cid":"0-11","title":"TestCase_4: Should error out when customer information is missing","fullTitle":"UserStory: Checkout.TestCase_4: Should error out when customer information is missing","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:33.443Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:27.604Z","_duration":5839,"uid":"test-00-0","cid":"0-11","title":"TestCase_4: Should error out when customer information is missing","fullTitle":"UserStory: Checkout.TestCase_4: Should error out when customer information is missing","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1ac307d2-a303-4385-ae09-5dad7640dcba"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1ac307d2-a303-4385-ae09-5dad7640dcba/clear","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1ac307d2-a303-4385-ae09-5dad7640dcba/clear","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1ac307d2-a303-4385-ae09-5dad7640dcba/value","body":{"text":"standard_user"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1ac307d2-a303-4385-ae09-5dad7640dcba/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fac535a1-70a4-47c4-a3c1-23f5db345b65"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fac535a1-70a4-47c4-a3c1-23f5db345b65/clear","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fac535a1-70a4-47c4-a3c1-23f5db345b65/clear","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fac535a1-70a4-47c4-a3c1-23f5db345b65/value","body":{"text":"secret_sauce"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fac535a1-70a4-47c4-a3c1-23f5db345b65/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1152afec-6c37-4811-b50f-d119781964c3"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1152afec-6c37-4811-b50f-d119781964c3/click","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1152afec-6c37-4811-b50f-d119781964c3/click","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b9af672b-5209-463f-bf04-16be4307467f"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b9af672b-5209-463f-bf04-16be4307467f/text","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b9af672b-5209-463f-bf04-16be4307467f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c28252e-9810-48c3-b8ac-89b35165cbf5"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5c28252e-9810-48c3-b8ac-89b35165cbf5/click","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5c28252e-9810-48c3-b8ac-89b35165cbf5/click","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b63fc78f-dd86-4da0-b197-1cdc25a4531a"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b63fc78f-dd86-4da0-b197-1cdc25a4531a"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b63fc78f-dd86-4da0-b197-1cdc25a4531a/text","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b63fc78f-dd86-4da0-b197-1cdc25a4531a/text","body":{},"result":{"value":"1"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"b63fc78f-dd86-4da0-b197-1cdc25a4531a"}]},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5af634f6-111f-45c2-a49a-79605326d91f"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5af634f6-111f-45c2-a49a-79605326d91f/click","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5af634f6-111f-45c2-a49a-79605326d91f/click","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3cdc1c47-cd99-4ea7-a814-e0ec5f123dc4"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3cdc1c47-cd99-4ea7-a814-e0ec5f123dc4/text","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3cdc1c47-cd99-4ea7-a814-e0ec5f123dc4/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e480826d-bcfe-4158-9dab-a382a4c05a7e"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e480826d-bcfe-4158-9dab-a382a4c05a7e"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e480826d-bcfe-4158-9dab-a382a4c05a7e/text","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e480826d-bcfe-4158-9dab-a382a4c05a7e/text","body":{},"result":{"value":"1"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e480826d-bcfe-4158-9dab-a382a4c05a7e"}]},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9f32594d-94ae-4ad5-b05c-30d9eb0a3d99"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9f32594d-94ae-4ad5-b05c-30d9eb0a3d99/click","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9f32594d-94ae-4ad5-b05c-30d9eb0a3d99/click","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f5ee6702-4418-4ee6-a0d1-91c7b030dd53"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f5ee6702-4418-4ee6-a0d1-91c7b030dd53/text","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f5ee6702-4418-4ee6-a0d1-91c7b030dd53/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7bd2d46a-a38b-4ca1-99a9-218696fb0227"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7bd2d46a-a38b-4ca1-99a9-218696fb0227"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7bd2d46a-a38b-4ca1-99a9-218696fb0227/text","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7bd2d46a-a38b-4ca1-99a9-218696fb0227/text","body":{},"result":{"value":"1"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"7bd2d46a-a38b-4ca1-99a9-218696fb0227"}]},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"87296ac4-e215-4b73-a9cd-0a27204ea181"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e4c3ace5-17ef-431e-909b-b3c2d7a95d9f"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e252368-652e-4592-bad4-9cbb8af9fea8"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"87296ac4-e215-4b73-a9cd-0a27204ea181"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/87296ac4-e215-4b73-a9cd-0a27204ea181/clear","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/87296ac4-e215-4b73-a9cd-0a27204ea181/clear","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/87296ac4-e215-4b73-a9cd-0a27204ea181/value","body":{"text":""},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/87296ac4-e215-4b73-a9cd-0a27204ea181/value","body":{"text":""},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e4c3ace5-17ef-431e-909b-b3c2d7a95d9f"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e4c3ace5-17ef-431e-909b-b3c2d7a95d9f/clear","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e4c3ace5-17ef-431e-909b-b3c2d7a95d9f/clear","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e4c3ace5-17ef-431e-909b-b3c2d7a95d9f/value","body":{"text":"Doe"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e4c3ace5-17ef-431e-909b-b3c2d7a95d9f/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e252368-652e-4592-bad4-9cbb8af9fea8"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6e252368-652e-4592-bad4-9cbb8af9fea8/clear","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6e252368-652e-4592-bad4-9cbb8af9fea8/clear","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6e252368-652e-4592-bad4-9cbb8af9fea8/value","body":{"text":"90210"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6e252368-652e-4592-bad4-9cbb8af9fea8/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"87296ac4-e215-4b73-a9cd-0a27204ea181"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/87296ac4-e215-4b73-a9cd-0a27204ea181/property/value","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/87296ac4-e215-4b73-a9cd-0a27204ea181/property/value","body":{},"result":{"value":""},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e4c3ace5-17ef-431e-909b-b3c2d7a95d9f"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4c3ace5-17ef-431e-909b-b3c2d7a95d9f/property/value","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4c3ace5-17ef-431e-909b-b3c2d7a95d9f/property/value","body":{},"result":{"value":"Doe"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e252368-652e-4592-bad4-9cbb8af9fea8"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6e252368-652e-4592-bad4-9cbb8af9fea8/property/value","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6e252368-652e-4592-bad4-9cbb8af9fea8/property/value","body":{},"result":{"value":"90210"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"01546015-4c7f-4a39-9785-7c1b5aabc5f6"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/01546015-4c7f-4a39-9785-7c1b5aabc5f6/click","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/01546015-4c7f-4a39-9785-7c1b5aabc5f6/click","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3099b513-0afe-4b60-8a35-8afd6ab146c1"}},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3099b513-0afe-4b60-8a35-8afd6ab146c1","ELEMENT":"3099b513-0afe-4b60-8a35-8afd6ab146c1"}]},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3099b513-0afe-4b60-8a35-8afd6ab146c1","ELEMENT":"3099b513-0afe-4b60-8a35-8afd6ab146c1"}]},"result":{"value":true},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"c81542a9ba12dba9cfbf692ff3a302b7","cid":"0-11","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:33.443Z"}],"uid":"suite-0-0","cid":"0-11","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout4.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:33.454Z"},{"type":"suite:start","start":"2022-02-18T00:48:31.147Z","_duration":8940,"tests":[{"type":"test","start":"2022-02-18T00:48:31.148Z","_duration":8928,"uid":"test-00-0","cid":"0-12","title":"TestCase_5: Add 5 items to cart, got to CheckoutStep1, don't fill in customer info, go Back to Cart, Remove an item, continue to checkout, go Back Home","fullTitle":"UserStory: Checkout.TestCase_5: Add 5 items to cart, got to CheckoutStep1, don't fill in customer info, go Back to Cart, Remove an item, continue to checkout, go Back Home","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:40.076Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:31.148Z","_duration":8928,"uid":"test-00-0","cid":"0-12","title":"TestCase_5: Add 5 items to cart, got to CheckoutStep1, don't fill in customer info, go Back to Cart, Remove an item, continue to checkout, go Back Home","fullTitle":"UserStory: Checkout.TestCase_5: Add 5 items to cart, got to CheckoutStep1, don't fill in customer info, go Back to Cart, Remove an item, continue to checkout, go Back Home","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"dd788789-087f-4dba-ad69-5fd274f7d52b"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/dd788789-087f-4dba-ad69-5fd274f7d52b/clear","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/dd788789-087f-4dba-ad69-5fd274f7d52b/clear","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/dd788789-087f-4dba-ad69-5fd274f7d52b/value","body":{"text":"standard_user"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/dd788789-087f-4dba-ad69-5fd274f7d52b/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"78b53962-a670-40e4-a94f-9566d5f2307e"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/78b53962-a670-40e4-a94f-9566d5f2307e/clear","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/78b53962-a670-40e4-a94f-9566d5f2307e/clear","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/78b53962-a670-40e4-a94f-9566d5f2307e/value","body":{"text":"secret_sauce"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/78b53962-a670-40e4-a94f-9566d5f2307e/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb252684-ab9b-494f-93d3-d05554aba4c6"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb252684-ab9b-494f-93d3-d05554aba4c6/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb252684-ab9b-494f-93d3-d05554aba4c6/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"729553d5-e653-4da4-88dd-99a6cefe8402"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/729553d5-e653-4da4-88dd-99a6cefe8402/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/729553d5-e653-4da4-88dd-99a6cefe8402/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b157760-a262-41a1-9fda-05014803c196"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9b157760-a262-41a1-9fda-05014803c196/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9b157760-a262-41a1-9fda-05014803c196/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5103d811-19aa-46b5-9321-3ca037e0c2ad"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5103d811-19aa-46b5-9321-3ca037e0c2ad/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5103d811-19aa-46b5-9321-3ca037e0c2ad/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bolt-t-shirt"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bolt-t-shirt"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2e13e487-7387-4051-a2b5-ea5bc272a680"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2e13e487-7387-4051-a2b5-ea5bc272a680/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2e13e487-7387-4051-a2b5-ea5bc272a680/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-fleece-jacket"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-fleece-jacket"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a74b83b3-b12b-4d58-84d9-af0a5e874a48"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a74b83b3-b12b-4d58-84d9-af0a5e874a48/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a74b83b3-b12b-4d58-84d9-af0a5e874a48/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-onesie"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-onesie"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f89379bc-6db0-4280-9376-84c90186503c"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f89379bc-6db0-4280-9376-84c90186503c/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f89379bc-6db0-4280-9376-84c90186503c/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"33ce53c9-8ff4-498a-8e64-b0f27a9314c4"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"33ce53c9-8ff4-498a-8e64-b0f27a9314c4"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/33ce53c9-8ff4-498a-8e64-b0f27a9314c4/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/33ce53c9-8ff4-498a-8e64-b0f27a9314c4/text","body":{},"result":{"value":"5"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"33ce53c9-8ff4-498a-8e64-b0f27a9314c4"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b2dfbcf8-c7ba-49f7-a05f-76feea4c9c77"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b2dfbcf8-c7ba-49f7-a05f-76feea4c9c77/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b2dfbcf8-c7ba-49f7-a05f-76feea4c9c77/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"25989271-9bb9-4ff2-9fe4-e4410cb37f67"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/25989271-9bb9-4ff2-9fe4-e4410cb37f67/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/25989271-9bb9-4ff2-9fe4-e4410cb37f67/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e521794-e62e-4033-8502-f1614e3b407a"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e521794-e62e-4033-8502-f1614e3b407a"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6e521794-e62e-4033-8502-f1614e3b407a/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6e521794-e62e-4033-8502-f1614e3b407a/text","body":{},"result":{"value":"5"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6e521794-e62e-4033-8502-f1614e3b407a"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a38c2d56-803a-4c08-9398-7639d86b77ce"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a38c2d56-803a-4c08-9398-7639d86b77ce/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a38c2d56-803a-4c08-9398-7639d86b77ce/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9f564e22-1862-46ee-a197-ea255c15f15b"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9f564e22-1862-46ee-a197-ea255c15f15b/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9f564e22-1862-46ee-a197-ea255c15f15b/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a9c6b95b-730c-483c-a6f7-04965f271bb5"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a9c6b95b-730c-483c-a6f7-04965f271bb5/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a9c6b95b-730c-483c-a6f7-04965f271bb5/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fde791a0-02df-46bd-a34c-c9014923a697"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fde791a0-02df-46bd-a34c-c9014923a697/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fde791a0-02df-46bd-a34c-c9014923a697/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ebe62677-a03a-4e70-831f-e57beb012933"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ebe62677-a03a-4e70-831f-e57beb012933"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ebe62677-a03a-4e70-831f-e57beb012933/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ebe62677-a03a-4e70-831f-e57beb012933/text","body":{},"result":{"value":"5"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#remove-sauce-labs-onesie"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ebe62677-a03a-4e70-831f-e57beb012933"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#remove-sauce-labs-onesie"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"074b9632-812a-4708-93e8-0f3f2561e1f7"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/074b9632-812a-4708-93e8-0f3f2561e1f7/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/074b9632-812a-4708-93e8-0f3f2561e1f7/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ebe62677-a03a-4e70-831f-e57beb012933"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ebe62677-a03a-4e70-831f-e57beb012933"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ebe62677-a03a-4e70-831f-e57beb012933/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ebe62677-a03a-4e70-831f-e57beb012933/text","body":{},"result":{"value":"4"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ebe62677-a03a-4e70-831f-e57beb012933"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"60b07e0c-91be-4fd2-a96b-77135641999f"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/60b07e0c-91be-4fd2-a96b-77135641999f/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/60b07e0c-91be-4fd2-a96b-77135641999f/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bbad9dd4-e9ed-485b-a8df-2beb2c5feafa"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bbad9dd4-e9ed-485b-a8df-2beb2c5feafa/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bbad9dd4-e9ed-485b-a8df-2beb2c5feafa/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8ee31990-771e-46ac-b0ac-556e08690337"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8ee31990-771e-46ac-b0ac-556e08690337"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8ee31990-771e-46ac-b0ac-556e08690337/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8ee31990-771e-46ac-b0ac-556e08690337/text","body":{},"result":{"value":"4"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8ee31990-771e-46ac-b0ac-556e08690337"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ca9085f-b284-4e8c-b295-93f18900bb0e"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ed9306e2-ac33-4330-bf2d-10fa6df39363"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e36b2d6-af02-48f0-8e64-ff1f051f49cf"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ca9085f-b284-4e8c-b295-93f18900bb0e"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0ca9085f-b284-4e8c-b295-93f18900bb0e/clear","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0ca9085f-b284-4e8c-b295-93f18900bb0e/clear","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0ca9085f-b284-4e8c-b295-93f18900bb0e/value","body":{"text":"Jane"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0ca9085f-b284-4e8c-b295-93f18900bb0e/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ed9306e2-ac33-4330-bf2d-10fa6df39363"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ed9306e2-ac33-4330-bf2d-10fa6df39363/clear","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ed9306e2-ac33-4330-bf2d-10fa6df39363/clear","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ed9306e2-ac33-4330-bf2d-10fa6df39363/value","body":{"text":"Doe"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ed9306e2-ac33-4330-bf2d-10fa6df39363/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6e36b2d6-af02-48f0-8e64-ff1f051f49cf"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6e36b2d6-af02-48f0-8e64-ff1f051f49cf/clear","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6e36b2d6-af02-48f0-8e64-ff1f051f49cf/clear","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6e36b2d6-af02-48f0-8e64-ff1f051f49cf/value","body":{"text":"90210"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6e36b2d6-af02-48f0-8e64-ff1f051f49cf/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc81da9d-b886-46b9-a11c-906a61438508"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc81da9d-b886-46b9-a11c-906a61438508/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc81da9d-b886-46b9-a11c-906a61438508/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8db272e0-9f0f-4cb6-8066-ad52b4d5319a"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8db272e0-9f0f-4cb6-8066-ad52b4d5319a/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8db272e0-9f0f-4cb6-8066-ad52b4d5319a/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51381ce8-b412-416b-b438-0947dbf38764"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51381ce8-b412-416b-b438-0947dbf38764"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51381ce8-b412-416b-b438-0947dbf38764"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/51381ce8-b412-416b-b438-0947dbf38764/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/51381ce8-b412-416b-b438-0947dbf38764/text","body":{},"result":{"value":"4"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e855b1f7-420d-4c3d-858b-d4a64499656e"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e855b1f7-420d-4c3d-858b-d4a64499656e/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"51381ce8-b412-416b-b438-0947dbf38764"}]},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e855b1f7-420d-4c3d-858b-d4a64499656e/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f319001a-1cfd-480f-925c-b7a8899654df"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f319001a-1cfd-480f-925c-b7a8899654df/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f319001a-1cfd-480f-925c-b7a8899654df/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bd3e64fe-b377-44df-b025-27fcbe46bbd5"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bd3e64fe-b377-44df-b025-27fcbe46bbd5"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/bd3e64fe-b377-44df-b025-27fcbe46bbd5/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/bd3e64fe-b377-44df-b025-27fcbe46bbd5/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"back-to-products\""},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"back-to-products\""},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"12d08583-7c92-4f97-85b8-1a937c11dbc4"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/12d08583-7c92-4f97-85b8-1a937c11dbc4/click","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/12d08583-7c92-4f97-85b8-1a937c11dbc4/click","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"11826869-19d6-4f88-a502-30e9e79fe075"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/11826869-19d6-4f88-a502-30e9e79fe075/text","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/11826869-19d6-4f88-a502-30e9e79fe075/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"845503603e5dcf45ee88c6aacbd2a467","cid":"0-12","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:40.076Z"}],"uid":"suite-0-0","cid":"0-12","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout5.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:40.088Z"},{"type":"suite:start","start":"2022-02-18T00:48:35.715Z","_duration":10983,"tests":[{"type":"test","start":"2022-02-18T00:48:35.716Z","_duration":10972,"uid":"test-00-0","cid":"0-13","title":"TestCase_6: Testing CartIcon from CheckoutStep2, Cancel from CheckoutStep2","fullTitle":"UserStory: Checkout.TestCase_6: Testing CartIcon from CheckoutStep2, Cancel from CheckoutStep2","output":[],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:46.688Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:35.716Z","_duration":10972,"uid":"test-00-0","cid":"0-13","title":"TestCase_6: Testing CartIcon from CheckoutStep2, Cancel from CheckoutStep2","fullTitle":"UserStory: Checkout.TestCase_6: Testing CartIcon from CheckoutStep2, Cancel from CheckoutStep2","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0347124f-2227-4e8e-abf7-9cf432959f2c"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0347124f-2227-4e8e-abf7-9cf432959f2c/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0347124f-2227-4e8e-abf7-9cf432959f2c/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0347124f-2227-4e8e-abf7-9cf432959f2c/value","body":{"text":"standard_user"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0347124f-2227-4e8e-abf7-9cf432959f2c/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cc8f1b2c-5ee7-4a5a-afeb-b9b5146fde46"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cc8f1b2c-5ee7-4a5a-afeb-b9b5146fde46/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cc8f1b2c-5ee7-4a5a-afeb-b9b5146fde46/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cc8f1b2c-5ee7-4a5a-afeb-b9b5146fde46/value","body":{"text":"secret_sauce"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cc8f1b2c-5ee7-4a5a-afeb-b9b5146fde46/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"84ffb1e8-c536-46e9-a836-1423841f1560"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/84ffb1e8-c536-46e9-a836-1423841f1560/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/84ffb1e8-c536-46e9-a836-1423841f1560/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2394b9fe-e9fc-48e4-9bfd-2ba701078a1f"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2394b9fe-e9fc-48e4-9bfd-2ba701078a1f/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2394b9fe-e9fc-48e4-9bfd-2ba701078a1f/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bolt-t-shirt"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bolt-t-shirt"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3dfe40f5-b176-4843-b406-358b35565f96"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3dfe40f5-b176-4843-b406-358b35565f96/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3dfe40f5-b176-4843-b406-358b35565f96/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/983b1d2b-1096-407a-81b5-ef302c2f68c7/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/983b1d2b-1096-407a-81b5-ef302c2f68c7/text","body":{},"result":{"value":"1"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-fleece-jacket"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-fleece-jacket"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c8a5b5fb-dad6-4a5f-a312-2068d62831fa"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c8a5b5fb-dad6-4a5f-a312-2068d62831fa/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c8a5b5fb-dad6-4a5f-a312-2068d62831fa/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/983b1d2b-1096-407a-81b5-ef302c2f68c7/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/983b1d2b-1096-407a-81b5-ef302c2f68c7/text","body":{},"result":{"value":"2"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-onesie"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-onesie"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e38549af-4b97-47bc-8214-5c237d0f8823"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e38549af-4b97-47bc-8214-5c237d0f8823/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e38549af-4b97-47bc-8214-5c237d0f8823/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/983b1d2b-1096-407a-81b5-ef302c2f68c7/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/983b1d2b-1096-407a-81b5-ef302c2f68c7/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"983b1d2b-1096-407a-81b5-ef302c2f68c7"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46b62489-8626-4aa9-95be-306876fc60ed"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/46b62489-8626-4aa9-95be-306876fc60ed/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/46b62489-8626-4aa9-95be-306876fc60ed/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"be7be82e-2832-4e11-9f6f-09aa1c185f99"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/be7be82e-2832-4e11-9f6f-09aa1c185f99/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/be7be82e-2832-4e11-9f6f-09aa1c185f99/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fef96b-9de8-45ee-add7-a6297e8d84c9"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9fef96b-9de8-45ee-add7-a6297e8d84c9"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fef96b-9de8-45ee-add7-a6297e8d84c9"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fef96b-9de8-45ee-add7-a6297e8d84c9/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f9fef96b-9de8-45ee-add7-a6297e8d84c9/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f9fef96b-9de8-45ee-add7-a6297e8d84c9"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"04c55ef2-2fd0-4380-86d1-ab24ff04364a"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/04c55ef2-2fd0-4380-86d1-ab24ff04364a/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/04c55ef2-2fd0-4380-86d1-ab24ff04364a/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"73f5f596-0445-4f13-a88c-dbf2d98492f3"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/73f5f596-0445-4f13-a88c-dbf2d98492f3/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/73f5f596-0445-4f13-a88c-dbf2d98492f3/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"20d4254c-5ea4-446f-a9ff-340f51c78dad"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfdde361-e882-4d22-8ebc-eee24ef13535"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7b8ad350-5548-4531-b503-09fc8624fdf2"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"20d4254c-5ea4-446f-a9ff-340f51c78dad"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/20d4254c-5ea4-446f-a9ff-340f51c78dad/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/20d4254c-5ea4-446f-a9ff-340f51c78dad/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/20d4254c-5ea4-446f-a9ff-340f51c78dad/value","body":{"text":"Jane"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/20d4254c-5ea4-446f-a9ff-340f51c78dad/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfdde361-e882-4d22-8ebc-eee24ef13535"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfdde361-e882-4d22-8ebc-eee24ef13535/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cfdde361-e882-4d22-8ebc-eee24ef13535/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfdde361-e882-4d22-8ebc-eee24ef13535/value","body":{"text":"Doe"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cfdde361-e882-4d22-8ebc-eee24ef13535/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7b8ad350-5548-4531-b503-09fc8624fdf2"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7b8ad350-5548-4531-b503-09fc8624fdf2/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7b8ad350-5548-4531-b503-09fc8624fdf2/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7b8ad350-5548-4531-b503-09fc8624fdf2/value","body":{"text":"90210"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7b8ad350-5548-4531-b503-09fc8624fdf2/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9f7afac9-2a89-4d05-91e9-8c6e3151e3cb"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9f7afac9-2a89-4d05-91e9-8c6e3151e3cb/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9f7afac9-2a89-4d05-91e9-8c6e3151e3cb/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2728dfc0-e476-4dc4-94fb-4c84119f332c"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2728dfc0-e476-4dc4-94fb-4c84119f332c/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2728dfc0-e476-4dc4-94fb-4c84119f332c/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a2502b3c-a1a2-48ce-9b32-0fc787d34a32"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a2502b3c-a1a2-48ce-9b32-0fc787d34a32"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a2502b3c-a1a2-48ce-9b32-0fc787d34a32/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a2502b3c-a1a2-48ce-9b32-0fc787d34a32/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a2502b3c-a1a2-48ce-9b32-0fc787d34a32"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d1317d79-e749-4e5a-8de9-6a97c4366ed4"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d1317d79-e749-4e5a-8de9-6a97c4366ed4/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d1317d79-e749-4e5a-8de9-6a97c4366ed4/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5dca06ee-972b-4381-9184-1f52d3b541b6"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5dca06ee-972b-4381-9184-1f52d3b541b6/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5dca06ee-972b-4381-9184-1f52d3b541b6/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd06f95a-b317-4667-8f77-97c4fef5b53f"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd06f95a-b317-4667-8f77-97c4fef5b53f"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fd06f95a-b317-4667-8f77-97c4fef5b53f/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fd06f95a-b317-4667-8f77-97c4fef5b53f/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"fd06f95a-b317-4667-8f77-97c4fef5b53f"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8ab1df4-b894-4ec6-894d-99b5b2e65859"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d8ab1df4-b894-4ec6-894d-99b5b2e65859/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d8ab1df4-b894-4ec6-894d-99b5b2e65859/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"53fa5931-069b-411b-8539-d0708fd9f3ec"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/53fa5931-069b-411b-8539-d0708fd9f3ec/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/53fa5931-069b-411b-8539-d0708fd9f3ec/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30dbc31f-2020-4ca2-8196-6893e0563667"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30dbc31f-2020-4ca2-8196-6893e0563667"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/30dbc31f-2020-4ca2-8196-6893e0563667/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/30dbc31f-2020-4ca2-8196-6893e0563667/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"30dbc31f-2020-4ca2-8196-6893e0563667"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7a611a23-c558-4985-ab2d-d1b01323eb6a"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5a3c6777-7be8-4075-a8dd-2dcb1d2daf8b"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"50793731-9691-4b6e-bc7e-0f68a40e3b0d"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7a611a23-c558-4985-ab2d-d1b01323eb6a"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7a611a23-c558-4985-ab2d-d1b01323eb6a/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7a611a23-c558-4985-ab2d-d1b01323eb6a/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7a611a23-c558-4985-ab2d-d1b01323eb6a/value","body":{"text":"Jane"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7a611a23-c558-4985-ab2d-d1b01323eb6a/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5a3c6777-7be8-4075-a8dd-2dcb1d2daf8b"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5a3c6777-7be8-4075-a8dd-2dcb1d2daf8b/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5a3c6777-7be8-4075-a8dd-2dcb1d2daf8b/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5a3c6777-7be8-4075-a8dd-2dcb1d2daf8b/value","body":{"text":"Doe"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5a3c6777-7be8-4075-a8dd-2dcb1d2daf8b/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"50793731-9691-4b6e-bc7e-0f68a40e3b0d"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/50793731-9691-4b6e-bc7e-0f68a40e3b0d/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/50793731-9691-4b6e-bc7e-0f68a40e3b0d/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/50793731-9691-4b6e-bc7e-0f68a40e3b0d/value","body":{"text":"90210"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"30dbc31f-2020-4ca2-8196-6893e0563667"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/50793731-9691-4b6e-bc7e-0f68a40e3b0d/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6f1e59b2-d0b1-44f7-acb0-e1b401500abe"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6f1e59b2-d0b1-44f7-acb0-e1b401500abe/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6f1e59b2-d0b1-44f7-acb0-e1b401500abe/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d70f4de7-9f89-4b64-b59a-3c71f681aa41"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d70f4de7-9f89-4b64-b59a-3c71f681aa41/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d70f4de7-9f89-4b64-b59a-3c71f681aa41/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2ca5e290-f692-465d-a0fc-43ec4ae2cd0d"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2ca5e290-f692-465d-a0fc-43ec4ae2cd0d"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2ca5e290-f692-465d-a0fc-43ec4ae2cd0d/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2ca5e290-f692-465d-a0fc-43ec4ae2cd0d/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"cancel\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2ca5e290-f692-465d-a0fc-43ec4ae2cd0d"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"cancel\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ce1d056e-cd63-48dc-8665-ea0f5c92e33d"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ce1d056e-cd63-48dc-8665-ea0f5c92e33d/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ce1d056e-cd63-48dc-8665-ea0f5c92e33d/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0a97618e-b58c-4009-85cb-3142693640f3"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0a97618e-b58c-4009-85cb-3142693640f3/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0a97618e-b58c-4009-85cb-3142693640f3/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"db6aec91-ecfe-458b-95fe-5bb033405c5e"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/db6aec91-ecfe-458b-95fe-5bb033405c5e/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/db6aec91-ecfe-458b-95fe-5bb033405c5e/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"169f0e02-41f8-47db-b476-073b84b3b48b"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/169f0e02-41f8-47db-b476-073b84b3b48b/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/169f0e02-41f8-47db-b476-073b84b3b48b/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e129ef23-4240-4844-addc-c956317dd1e9"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e129ef23-4240-4844-addc-c956317dd1e9/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e129ef23-4240-4844-addc-c956317dd1e9/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1c68f4c9-ce88-47f5-b9fc-e63212209999"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1c68f4c9-ce88-47f5-b9fc-e63212209999/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1c68f4c9-ce88-47f5-b9fc-e63212209999/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"341f6cd0-4209-492c-8901-7560ebc1d0fe"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"341f6cd0-4209-492c-8901-7560ebc1d0fe"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"341f6cd0-4209-492c-8901-7560ebc1d0fe"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/341f6cd0-4209-492c-8901-7560ebc1d0fe/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/341f6cd0-4209-492c-8901-7560ebc1d0fe/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"341f6cd0-4209-492c-8901-7560ebc1d0fe"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"450836d6-4830-4b19-90cb-fb24cff7b00a"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd172a38-9749-4ec4-a5a4-ca9ef80b9b87"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b4bc33b2-6937-436b-a83b-00d7978ad29e"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"450836d6-4830-4b19-90cb-fb24cff7b00a"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/450836d6-4830-4b19-90cb-fb24cff7b00a/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/450836d6-4830-4b19-90cb-fb24cff7b00a/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/450836d6-4830-4b19-90cb-fb24cff7b00a/value","body":{"text":"Hello"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/450836d6-4830-4b19-90cb-fb24cff7b00a/value","body":{"text":"Hello"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd172a38-9749-4ec4-a5a4-ca9ef80b9b87"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd172a38-9749-4ec4-a5a4-ca9ef80b9b87/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd172a38-9749-4ec4-a5a4-ca9ef80b9b87/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd172a38-9749-4ec4-a5a4-ca9ef80b9b87/value","body":{"text":"World"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd172a38-9749-4ec4-a5a4-ca9ef80b9b87/value","body":{"text":"World"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b4bc33b2-6937-436b-a83b-00d7978ad29e"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b4bc33b2-6937-436b-a83b-00d7978ad29e/clear","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b4bc33b2-6937-436b-a83b-00d7978ad29e/clear","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b4bc33b2-6937-436b-a83b-00d7978ad29e/value","body":{"text":"90000"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b4bc33b2-6937-436b-a83b-00d7978ad29e/value","body":{"text":"90000"},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e558bb59-8519-49a8-9e00-cee7983a6cf9"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e558bb59-8519-49a8-9e00-cee7983a6cf9/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e558bb59-8519-49a8-9e00-cee7983a6cf9/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5961c409-5be8-40ca-b47a-d29cc400fad3"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5961c409-5be8-40ca-b47a-d29cc400fad3/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5961c409-5be8-40ca-b47a-d29cc400fad3/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"dfa94ce6-a4af-49e4-bd3f-d152ecf84e19"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"dfa94ce6-a4af-49e4-bd3f-d152ecf84e19"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/dfa94ce6-a4af-49e4-bd3f-d152ecf84e19/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/dfa94ce6-a4af-49e4-bd3f-d152ecf84e19/text","body":{},"result":{"value":"3"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"dfa94ce6-a4af-49e4-bd3f-d152ecf84e19"}]},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f8641e8f-78b9-4bf4-a24d-65cff986f173"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f8641e8f-78b9-4bf4-a24d-65cff986f173/click","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f8641e8f-78b9-4bf4-a24d-65cff986f173/click","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d72dfae-4158-4427-a027-7275976ccc2f"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2d72dfae-4158-4427-a027-7275976ccc2f/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2d72dfae-4158-4427-a027-7275976ccc2f/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"35395755-98e7-49cb-bb50-8f825a8a2f4f"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"35395755-98e7-49cb-bb50-8f825a8a2f4f"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/35395755-98e7-49cb-bb50-8f825a8a2f4f/text","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/35395755-98e7-49cb-bb50-8f825a8a2f4f/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"f028c22def4a27f6db8c6bed083b8cc9","cid":"0-13","type":"result"}],"retries":0,"parent":"UserStory: Checkout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:46.688Z"}],"uid":"suite-0-0","cid":"0-13","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout6.e2e.js","title":"UserStory: Checkout","fullTitle":"UserStory: Checkout","parent":"","end":"2022-02-18T00:48:46.700Z"},{"type":"suite:start","start":"2022-02-18T00:48:36.737Z","_duration":12323,"tests":[{"type":"test","start":"2022-02-18T00:48:36.738Z","_duration":12311,"uid":"test-00-0","cid":"0-14","title":"TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:49.049Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:36.738Z","_duration":12311,"uid":"test-00-0","cid":"0-14","title":"TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5473059b-9c2c-4b57-88ab-8917fa38aa51"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5473059b-9c2c-4b57-88ab-8917fa38aa51/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5473059b-9c2c-4b57-88ab-8917fa38aa51/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5473059b-9c2c-4b57-88ab-8917fa38aa51/value","body":{"text":"standard_user"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5473059b-9c2c-4b57-88ab-8917fa38aa51/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e8997b93-e0a9-49e8-b9c4-d0bf8b03f114"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e8997b93-e0a9-49e8-b9c4-d0bf8b03f114/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e8997b93-e0a9-49e8-b9c4-d0bf8b03f114/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e8997b93-e0a9-49e8-b9c4-d0bf8b03f114/value","body":{"text":"secret_sauce"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e8997b93-e0a9-49e8-b9c4-d0bf8b03f114/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1151edca-428c-47ca-9ea5-c3a2908b5e36"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1151edca-428c-47ca-9ea5-c3a2908b5e36/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1151edca-428c-47ca-9ea5-c3a2908b5e36/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b0b57f44-3a74-4652-9189-3fe8e1af53f8"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/b0b57f44-3a74-4652-9189-3fe8e1af53f8/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/b0b57f44-3a74-4652-9189-3fe8e1af53f8/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7d2e68e6-e70a-4451-9464-f365480d02ed"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7d2e68e6-e70a-4451-9464-f365480d02ed/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7d2e68e6-e70a-4451-9464-f365480d02ed/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"49f5f927-10a7-461e-b515-dfadc9f3d37a"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"49f5f927-10a7-461e-b515-dfadc9f3d37a"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/49f5f927-10a7-461e-b515-dfadc9f3d37a/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/49f5f927-10a7-461e-b515-dfadc9f3d37a/text","body":{},"result":{"value":"1"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"49f5f927-10a7-461e-b515-dfadc9f3d37a"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e985476a-fe4e-4fe2-b390-9da04234fff9"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e985476a-fe4e-4fe2-b390-9da04234fff9/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e985476a-fe4e-4fe2-b390-9da04234fff9/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d","ELEMENT":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d","ELEMENT":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d"}]},"result":{"value":true},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d","ELEMENT":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d","ELEMENT":"d8f037ca-9412-41a4-b8f7-8e35717d3b2d"}]},"result":{"value":true},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d8f037ca-9412-41a4-b8f7-8e35717d3b2d/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d8f037ca-9412-41a4-b8f7-8e35717d3b2d/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c3584c7-ff26-4df7-88a5-688b82e4ac18"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5c3584c7-ff26-4df7-88a5-688b82e4ac18/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5c3584c7-ff26-4df7-88a5-688b82e4ac18/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5c3584c7-ff26-4df7-88a5-688b82e4ac18/value","body":{"text":"standard_user"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5c3584c7-ff26-4df7-88a5-688b82e4ac18/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3f28eca9-c246-48a7-ae7e-aadf837fe6d1"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3f28eca9-c246-48a7-ae7e-aadf837fe6d1/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3f28eca9-c246-48a7-ae7e-aadf837fe6d1/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3f28eca9-c246-48a7-ae7e-aadf837fe6d1/value","body":{"text":"secret_sauce"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3f28eca9-c246-48a7-ae7e-aadf837fe6d1/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"09a66188-ba8a-4aec-8d45-020f5dbb49db"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/09a66188-ba8a-4aec-8d45-020f5dbb49db/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/09a66188-ba8a-4aec-8d45-020f5dbb49db/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"164e2e70-597b-434b-ad65-aba7ad8419b1"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/164e2e70-597b-434b-ad65-aba7ad8419b1/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/164e2e70-597b-434b-ad65-aba7ad8419b1/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3eafe0df-4046-4e49-a603-81c299b4c676"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3eafe0df-4046-4e49-a603-81c299b4c676"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3eafe0df-4046-4e49-a603-81c299b4c676/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3eafe0df-4046-4e49-a603-81c299b4c676/text","body":{},"result":{"value":"1"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3eafe0df-4046-4e49-a603-81c299b4c676"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"63a49948-c555-4ba6-873f-f07b749cccc0"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/63a49948-c555-4ba6-873f-f07b749cccc0/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/63a49948-c555-4ba6-873f-f07b749cccc0/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"897e9815-801e-4cd9-b8a5-7376916e80c8"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/897e9815-801e-4cd9-b8a5-7376916e80c8/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/897e9815-801e-4cd9-b8a5-7376916e80c8/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"59f25d20-8de9-4532-91f1-1851caaf3726"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"59f25d20-8de9-4532-91f1-1851caaf3726"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/59f25d20-8de9-4532-91f1-1851caaf3726/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/59f25d20-8de9-4532-91f1-1851caaf3726/text","body":{},"result":{"value":"1"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"59f25d20-8de9-4532-91f1-1851caaf3726"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"df39dbaa-7b5e-4c87-9ae3-332e15ce7b56"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/df39dbaa-7b5e-4c87-9ae3-332e15ce7b56/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/df39dbaa-7b5e-4c87-9ae3-332e15ce7b56/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7aa23c3b-9319-4459-bf23-e36a2567e87e"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7aa23c3b-9319-4459-bf23-e36a2567e87e/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7aa23c3b-9319-4459-bf23-e36a2567e87e/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"adef2828-dcef-4476-9383-78f9a1b94121"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"adef2828-dcef-4476-9383-78f9a1b94121"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/adef2828-dcef-4476-9383-78f9a1b94121/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/adef2828-dcef-4476-9383-78f9a1b94121/text","body":{},"result":{"value":"1"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"adef2828-dcef-4476-9383-78f9a1b94121"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"116ece76-eb40-4882-b8b8-e234f66e4d77"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"28a44227-f4e9-4693-8b7f-d46acd4b95bb"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7007776b-d4b9-4351-a30b-6c944ff538e5"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"116ece76-eb40-4882-b8b8-e234f66e4d77"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/116ece76-eb40-4882-b8b8-e234f66e4d77/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/116ece76-eb40-4882-b8b8-e234f66e4d77/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/116ece76-eb40-4882-b8b8-e234f66e4d77/value","body":{"text":"Jane"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/116ece76-eb40-4882-b8b8-e234f66e4d77/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"28a44227-f4e9-4693-8b7f-d46acd4b95bb"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/28a44227-f4e9-4693-8b7f-d46acd4b95bb/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/28a44227-f4e9-4693-8b7f-d46acd4b95bb/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/28a44227-f4e9-4693-8b7f-d46acd4b95bb/value","body":{"text":"Doe"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/28a44227-f4e9-4693-8b7f-d46acd4b95bb/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7007776b-d4b9-4351-a30b-6c944ff538e5"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7007776b-d4b9-4351-a30b-6c944ff538e5/clear","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7007776b-d4b9-4351-a30b-6c944ff538e5/clear","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7007776b-d4b9-4351-a30b-6c944ff538e5/value","body":{"text":"90210"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7007776b-d4b9-4351-a30b-6c944ff538e5/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e7080883-eb96-4821-a75a-d682d435dbb4"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7080883-eb96-4821-a75a-d682d435dbb4/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7080883-eb96-4821-a75a-d682d435dbb4/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3d5ce859-823e-420a-8120-208d825515ce"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3d5ce859-823e-420a-8120-208d825515ce/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3d5ce859-823e-420a-8120-208d825515ce/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d2797175-6ccf-4ce3-894a-43b53b105780"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d2797175-6ccf-4ce3-894a-43b53b105780"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d2797175-6ccf-4ce3-894a-43b53b105780"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d2797175-6ccf-4ce3-894a-43b53b105780/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d2797175-6ccf-4ce3-894a-43b53b105780/text","body":{},"result":{"value":"1"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d2797175-6ccf-4ce3-894a-43b53b105780"}]},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a46882d4-ea2e-4c6f-aa79-4d0b97297856"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a46882d4-ea2e-4c6f-aa79-4d0b97297856/click","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a46882d4-ea2e-4c6f-aa79-4d0b97297856/click","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eb9b60db-8a6e-4a55-bc8b-a5389e9d6633"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/eb9b60db-8a6e-4a55-bc8b-a5389e9d6633/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/eb9b60db-8a6e-4a55-bc8b-a5389e9d6633/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cdfd915e-459a-4f19-acd4-d3e3207f0865"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cdfd915e-459a-4f19-acd4-d3e3207f0865"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/cdfd915e-459a-4f19-acd4-d3e3207f0865/text","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/cdfd915e-459a-4f19-acd4-d3e3207f0865/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"caa3cab7d2df96107d27e9087d1c04fa","cid":"0-14","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:49.049Z"}],"uid":"suite-0-0","cid":"0-14","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T00:48:49.061Z"},{"type":"suite:start","start":"2022-02-18T00:48:37.335Z","_duration":612920,"tests":[{"type":"test","start":"2022-02-18T00:48:37.336Z","_duration":612899,"uid":"test-00-0","cid":"0-15","title":"TestCase_8: (TestCase_2 modified) should be able to add one item to cart, delay on inventory page, autologout, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_8: (TestCase_2 modified) should be able to add one item to cart, delay on inventory page, autologout, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:50.235Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:37.336Z","_duration":612899,"uid":"test-00-0","cid":"0-15","title":"TestCase_8: (TestCase_2 modified) should be able to add one item to cart, delay on inventory page, autologout, log back in and check it out successfully","fullTitle":"UserStory: Delay.TestCase_8: (TestCase_2 modified) should be able to add one item to cart, delay on inventory page, autologout, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3872cede-18e3-43be-a2c8-8a9fa1b8c2a9"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3872cede-18e3-43be-a2c8-8a9fa1b8c2a9/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3872cede-18e3-43be-a2c8-8a9fa1b8c2a9/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3872cede-18e3-43be-a2c8-8a9fa1b8c2a9/value","body":{"text":"standard_user"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3872cede-18e3-43be-a2c8-8a9fa1b8c2a9/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"64569780-2978-48d6-b106-ad2f60f3c46c"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/64569780-2978-48d6-b106-ad2f60f3c46c/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/64569780-2978-48d6-b106-ad2f60f3c46c/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/64569780-2978-48d6-b106-ad2f60f3c46c/value","body":{"text":"secret_sauce"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/64569780-2978-48d6-b106-ad2f60f3c46c/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a874b301-4fab-436c-968d-8f05a3bcb10d"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a874b301-4fab-436c-968d-8f05a3bcb10d/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a874b301-4fab-436c-968d-8f05a3bcb10d/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"70ef4d5f-7f3e-497e-bfad-f5fe1f32b11e"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/70ef4d5f-7f3e-497e-bfad-f5fe1f32b11e/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/70ef4d5f-7f3e-497e-bfad-f5fe1f32b11e/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9924f090-6e92-4c8c-aec2-b239ae1568b2"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9924f090-6e92-4c8c-aec2-b239ae1568b2/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9924f090-6e92-4c8c-aec2-b239ae1568b2/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6b81a325-dd3b-459c-9c00-18d8162412d0"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6b81a325-dd3b-459c-9c00-18d8162412d0"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6b81a325-dd3b-459c-9c00-18d8162412d0/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6b81a325-dd3b-459c-9c00-18d8162412d0/text","body":{},"result":{"value":"1"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6b81a325-dd3b-459c-9c00-18d8162412d0"}]},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5e1f2101-09e5-44b4-8a69-ebb84a28b7f3"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5e1f2101-09e5-44b4-8a69-ebb84a28b7f3","ELEMENT":"5e1f2101-09e5-44b4-8a69-ebb84a28b7f3"}]},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5e1f2101-09e5-44b4-8a69-ebb84a28b7f3","ELEMENT":"5e1f2101-09e5-44b4-8a69-ebb84a28b7f3"}]},"result":{"value":true},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5e1f2101-09e5-44b4-8a69-ebb84a28b7f3/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5e1f2101-09e5-44b4-8a69-ebb84a28b7f3/text","body":{},"result":{"value":"Epic sadface: You can only access '/inventory.html' when you are logged in."},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1d0621ec-f506-4ac1-a482-041d90aff9ed"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1d0621ec-f506-4ac1-a482-041d90aff9ed/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1d0621ec-f506-4ac1-a482-041d90aff9ed/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1d0621ec-f506-4ac1-a482-041d90aff9ed/value","body":{"text":"standard_user"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1d0621ec-f506-4ac1-a482-041d90aff9ed/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d320dbdd-5367-4a3f-91aa-f497f37ea579"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d320dbdd-5367-4a3f-91aa-f497f37ea579/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d320dbdd-5367-4a3f-91aa-f497f37ea579/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d320dbdd-5367-4a3f-91aa-f497f37ea579/value","body":{"text":"secret_sauce"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d320dbdd-5367-4a3f-91aa-f497f37ea579/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8fbcd3db-a9c8-4870-b296-c75f138c7deb"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8fbcd3db-a9c8-4870-b296-c75f138c7deb/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8fbcd3db-a9c8-4870-b296-c75f138c7deb/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8b151ea0-5845-4f5b-83e2-a0870c19b063"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8b151ea0-5845-4f5b-83e2-a0870c19b063/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8b151ea0-5845-4f5b-83e2-a0870c19b063/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e1c8faac-9445-44e7-9b69-3996f3cfd8f0"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e1c8faac-9445-44e7-9b69-3996f3cfd8f0"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e1c8faac-9445-44e7-9b69-3996f3cfd8f0/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e1c8faac-9445-44e7-9b69-3996f3cfd8f0/text","body":{},"result":{"value":"1"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"e1c8faac-9445-44e7-9b69-3996f3cfd8f0"}]},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1a596e62-3cf0-449b-ad82-df1018a012a8"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1a596e62-3cf0-449b-ad82-df1018a012a8/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1a596e62-3cf0-449b-ad82-df1018a012a8/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cb240ef0-5500-4881-8495-2bca57f990d3"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/cb240ef0-5500-4881-8495-2bca57f990d3/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/cb240ef0-5500-4881-8495-2bca57f990d3/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ec4f33c5-5569-47ae-b9aa-55734e30f2be"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ec4f33c5-5569-47ae-b9aa-55734e30f2be"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ec4f33c5-5569-47ae-b9aa-55734e30f2be/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ec4f33c5-5569-47ae-b9aa-55734e30f2be/text","body":{},"result":{"value":"1"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ec4f33c5-5569-47ae-b9aa-55734e30f2be"}]},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d2a2a9c8-c0f1-4350-9cb6-e826ee765c3b"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d2a2a9c8-c0f1-4350-9cb6-e826ee765c3b/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d2a2a9c8-c0f1-4350-9cb6-e826ee765c3b/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e3a80205-c13f-4234-8c8f-86ce9eb3f7b5"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e3a80205-c13f-4234-8c8f-86ce9eb3f7b5/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e3a80205-c13f-4234-8c8f-86ce9eb3f7b5/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4ebff26-f3d8-498c-a408-2f7d5319e7d8"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d4ebff26-f3d8-498c-a408-2f7d5319e7d8"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d4ebff26-f3d8-498c-a408-2f7d5319e7d8/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d4ebff26-f3d8-498c-a408-2f7d5319e7d8/text","body":{},"result":{"value":"1"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d4ebff26-f3d8-498c-a408-2f7d5319e7d8"}]},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7021d571-788e-4ae3-859e-c94929fa099e"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4a3c2424-09b0-4e64-b158-fcd00cfbf42c"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"74d9e80d-9c86-45c8-9dd6-359e7cb9cd0b"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7021d571-788e-4ae3-859e-c94929fa099e"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7021d571-788e-4ae3-859e-c94929fa099e/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7021d571-788e-4ae3-859e-c94929fa099e/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7021d571-788e-4ae3-859e-c94929fa099e/value","body":{"text":"Jane"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7021d571-788e-4ae3-859e-c94929fa099e/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4a3c2424-09b0-4e64-b158-fcd00cfbf42c"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4a3c2424-09b0-4e64-b158-fcd00cfbf42c/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4a3c2424-09b0-4e64-b158-fcd00cfbf42c/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4a3c2424-09b0-4e64-b158-fcd00cfbf42c/value","body":{"text":"Doe"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4a3c2424-09b0-4e64-b158-fcd00cfbf42c/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"74d9e80d-9c86-45c8-9dd6-359e7cb9cd0b"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/74d9e80d-9c86-45c8-9dd6-359e7cb9cd0b/clear","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/74d9e80d-9c86-45c8-9dd6-359e7cb9cd0b/clear","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/74d9e80d-9c86-45c8-9dd6-359e7cb9cd0b/value","body":{"text":"90210"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/74d9e80d-9c86-45c8-9dd6-359e7cb9cd0b/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8444c690-82a6-4b74-ba9c-ed58c6ce00e0"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8444c690-82a6-4b74-ba9c-ed58c6ce00e0/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8444c690-82a6-4b74-ba9c-ed58c6ce00e0/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1eeb6cd7-298d-418c-b422-3e4c0de890d4"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1eeb6cd7-298d-418c-b422-3e4c0de890d4/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1eeb6cd7-298d-418c-b422-3e4c0de890d4/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2a6bc6b2-fa02-4d9f-a7fc-98e139e28395"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2a6bc6b2-fa02-4d9f-a7fc-98e139e28395"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2a6bc6b2-fa02-4d9f-a7fc-98e139e28395/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2a6bc6b2-fa02-4d9f-a7fc-98e139e28395/text","body":{},"result":{"value":"1"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2a6bc6b2-fa02-4d9f-a7fc-98e139e28395"}]},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1bd5fe41-4c31-4751-b68a-97b6a2f9d1ce"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1bd5fe41-4c31-4751-b68a-97b6a2f9d1ce/click","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1bd5fe41-4c31-4751-b68a-97b6a2f9d1ce/click","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07eddbe2-8060-4830-b2aa-5eea49896277"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/07eddbe2-8060-4830-b2aa-5eea49896277/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/07eddbe2-8060-4830-b2aa-5eea49896277/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5cb1fe3f-64ea-4567-92e8-f94b6225964c"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5cb1fe3f-64ea-4567-92e8-f94b6225964c"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5cb1fe3f-64ea-4567-92e8-f94b6225964c/text","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5cb1fe3f-64ea-4567-92e8-f94b6225964c/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"8435a31666557688e44624672ed86580","cid":"0-15","type":"result"}],"retries":0,"parent":"UserStory: Delay","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:50.235Z"}],"uid":"suite-0-0","cid":"0-15","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout8-inventory-delay.e2e.js","title":"UserStory: Delay","fullTitle":"UserStory: Delay","parent":"","end":"2022-02-18T00:58:50.257Z"},{"type":"suite:start","start":"2022-02-18T00:48:38.228Z","_duration":14983,"tests":[{"type":"test","start":"2022-02-18T00:48:38.229Z","_duration":14957,"uid":"test-00-0","cid":"0-16","title":"TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","output":[],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:53.186Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:38.229Z","_duration":14957,"uid":"test-00-0","cid":"0-16","title":"TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9da7fa22-d629-4d8e-a083-e936e7e2069d"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9da7fa22-d629-4d8e-a083-e936e7e2069d/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9da7fa22-d629-4d8e-a083-e936e7e2069d/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9da7fa22-d629-4d8e-a083-e936e7e2069d/value","body":{"text":"standard_user"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9da7fa22-d629-4d8e-a083-e936e7e2069d/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8f1ef9a4-65f8-40e4-af90-67a42dfc5fb4"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8f1ef9a4-65f8-40e4-af90-67a42dfc5fb4/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8f1ef9a4-65f8-40e4-af90-67a42dfc5fb4/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8f1ef9a4-65f8-40e4-af90-67a42dfc5fb4/value","body":{"text":"secret_sauce"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8f1ef9a4-65f8-40e4-af90-67a42dfc5fb4/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eb50a989-0f64-496f-94c7-02b6ee25e6b8"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/eb50a989-0f64-496f-94c7-02b6ee25e6b8/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/eb50a989-0f64-496f-94c7-02b6ee25e6b8/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3a95793f-3d36-45b9-aa56-7d5be065f917"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3a95793f-3d36-45b9-aa56-7d5be065f917/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3a95793f-3d36-45b9-aa56-7d5be065f917/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"eb834da0-b768-4bae-8892-364abc44b843"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/eb834da0-b768-4bae-8892-364abc44b843/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/eb834da0-b768-4bae-8892-364abc44b843/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8333cd76-4565-4cb9-9733-0f2222003df5"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8333cd76-4565-4cb9-9733-0f2222003df5"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8333cd76-4565-4cb9-9733-0f2222003df5/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8333cd76-4565-4cb9-9733-0f2222003df5/text","body":{},"result":{"value":"1"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8333cd76-4565-4cb9-9733-0f2222003df5"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3a95793f-3d36-45b9-aa56-7d5be065f917"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3a95793f-3d36-45b9-aa56-7d5be065f917/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3a95793f-3d36-45b9-aa56-7d5be065f917/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8333cd76-4565-4cb9-9733-0f2222003df5"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8333cd76-4565-4cb9-9733-0f2222003df5"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8333cd76-4565-4cb9-9733-0f2222003df5/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8333cd76-4565-4cb9-9733-0f2222003df5/text","body":{},"result":{"value":"1"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8333cd76-4565-4cb9-9733-0f2222003df5"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c53318ef-44ba-4358-a310-6d334f9e46b6"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c53318ef-44ba-4358-a310-6d334f9e46b6/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c53318ef-44ba-4358-a310-6d334f9e46b6/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"97cad1db-975d-4b3e-a0e5-8e0eb1e3e7db"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/97cad1db-975d-4b3e-a0e5-8e0eb1e3e7db/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/97cad1db-975d-4b3e-a0e5-8e0eb1e3e7db/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"469495e2-ea2f-46bd-a99b-ce3ba86b04c0"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"469495e2-ea2f-46bd-a99b-ce3ba86b04c0"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/469495e2-ea2f-46bd-a99b-ce3ba86b04c0/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/469495e2-ea2f-46bd-a99b-ce3ba86b04c0/text","body":{},"result":{"value":"1"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cd560e54-7ee0-4312-868d-b5a8d2f8f03c"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cd560e54-7ee0-4312-868d-b5a8d2f8f03c/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cd560e54-7ee0-4312-868d-b5a8d2f8f03c/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"469495e2-ea2f-46bd-a99b-ce3ba86b04c0"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":true},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":false},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":true},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":false},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":true},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":false},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":true},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":false},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":true},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"12043318-2748-4653-899a-5ac132f8ce69","ELEMENT":"12043318-2748-4653-899a-5ac132f8ce69"}]},"result":{"value":true},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/12043318-2748-4653-899a-5ac132f8ce69/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/12043318-2748-4653-899a-5ac132f8ce69/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ac8aecfd-9ad2-47f1-b036-10577b28baf7"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ac8aecfd-9ad2-47f1-b036-10577b28baf7/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ac8aecfd-9ad2-47f1-b036-10577b28baf7/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ac8aecfd-9ad2-47f1-b036-10577b28baf7/value","body":{"text":"standard_user"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ac8aecfd-9ad2-47f1-b036-10577b28baf7/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2bd7f1c8-611a-4713-92e4-ab892623ec5f"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2bd7f1c8-611a-4713-92e4-ab892623ec5f/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2bd7f1c8-611a-4713-92e4-ab892623ec5f/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2bd7f1c8-611a-4713-92e4-ab892623ec5f/value","body":{"text":"secret_sauce"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2bd7f1c8-611a-4713-92e4-ab892623ec5f/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"978d7abd-53d4-4777-bc99-89b237af1e32"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/978d7abd-53d4-4777-bc99-89b237af1e32/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/978d7abd-53d4-4777-bc99-89b237af1e32/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4043e17f-513a-4fc8-8848-3e4ce598dac5"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4043e17f-513a-4fc8-8848-3e4ce598dac5/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4043e17f-513a-4fc8-8848-3e4ce598dac5/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3a1e7cda-5c26-47c7-acf2-f4b20d52ee16"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3a1e7cda-5c26-47c7-acf2-f4b20d52ee16"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3a1e7cda-5c26-47c7-acf2-f4b20d52ee16/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3a1e7cda-5c26-47c7-acf2-f4b20d52ee16/text","body":{},"result":{"value":"1"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3a1e7cda-5c26-47c7-acf2-f4b20d52ee16"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cb9f2d00-fa9e-4234-bbec-b7c3a7d2cfe0"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cb9f2d00-fa9e-4234-bbec-b7c3a7d2cfe0/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cb9f2d00-fa9e-4234-bbec-b7c3a7d2cfe0/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"32d7a157-3edd-4b0c-9ee2-297f22a6fda1"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/32d7a157-3edd-4b0c-9ee2-297f22a6fda1/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/32d7a157-3edd-4b0c-9ee2-297f22a6fda1/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e0fa79e1-968d-497d-a0a6-31bc3cc60a88"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e0fa79e1-968d-497d-a0a6-31bc3cc60a88/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e0fa79e1-968d-497d-a0a6-31bc3cc60a88/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d3993b2b-9263-4438-89d6-f01eb3282523"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d3993b2b-9263-4438-89d6-f01eb3282523"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d3993b2b-9263-4438-89d6-f01eb3282523/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d3993b2b-9263-4438-89d6-f01eb3282523/text","body":{},"result":{"value":"1"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d3993b2b-9263-4438-89d6-f01eb3282523"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6575672d-8c86-444c-b93e-e7c2c51cc8df"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"55bb0039-1b2f-4140-b18a-cd350c3b4745"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51b754b8-bbc3-4cb8-b4d9-e4468bff5993"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6575672d-8c86-444c-b93e-e7c2c51cc8df"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6575672d-8c86-444c-b93e-e7c2c51cc8df/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6575672d-8c86-444c-b93e-e7c2c51cc8df/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6575672d-8c86-444c-b93e-e7c2c51cc8df/value","body":{"text":"Jane"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6575672d-8c86-444c-b93e-e7c2c51cc8df/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"55bb0039-1b2f-4140-b18a-cd350c3b4745"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/55bb0039-1b2f-4140-b18a-cd350c3b4745/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/55bb0039-1b2f-4140-b18a-cd350c3b4745/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/55bb0039-1b2f-4140-b18a-cd350c3b4745/value","body":{"text":"Doe"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/55bb0039-1b2f-4140-b18a-cd350c3b4745/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"51b754b8-bbc3-4cb8-b4d9-e4468bff5993"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/51b754b8-bbc3-4cb8-b4d9-e4468bff5993/clear","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/51b754b8-bbc3-4cb8-b4d9-e4468bff5993/clear","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/51b754b8-bbc3-4cb8-b4d9-e4468bff5993/value","body":{"text":"90210"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/51b754b8-bbc3-4cb8-b4d9-e4468bff5993/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"d3993b2b-9263-4438-89d6-f01eb3282523"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a509f41c-f21d-46fd-b2dc-1588d0a84bca"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a509f41c-f21d-46fd-b2dc-1588d0a84bca/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a509f41c-f21d-46fd-b2dc-1588d0a84bca/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"732b65af-684e-4ccf-abdf-85ca4144b096"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/732b65af-684e-4ccf-abdf-85ca4144b096/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/732b65af-684e-4ccf-abdf-85ca4144b096/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8c6ab382-192c-4adb-823f-6ef5b55c562a"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8c6ab382-192c-4adb-823f-6ef5b55c562a"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8c6ab382-192c-4adb-823f-6ef5b55c562a/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8c6ab382-192c-4adb-823f-6ef5b55c562a/text","body":{},"result":{"value":"1"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"8c6ab382-192c-4adb-823f-6ef5b55c562a"}]},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4bb8157f-4e79-4c85-a3fe-440b7c2e2b26"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4bb8157f-4e79-4c85-a3fe-440b7c2e2b26/click","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4bb8157f-4e79-4c85-a3fe-440b7c2e2b26/click","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5ee11129-8784-4d59-b8c4-b2b6a80893ac"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5ee11129-8784-4d59-b8c4-b2b6a80893ac/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5ee11129-8784-4d59-b8c4-b2b6a80893ac/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1033d317-e6d2-4d68-8040-554466fa52e2"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1033d317-e6d2-4d68-8040-554466fa52e2"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1033d317-e6d2-4d68-8040-554466fa52e2/text","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1033d317-e6d2-4d68-8040-554466fa52e2/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"9939025a1ec9e909f3c6df6f4e27cda7","cid":"0-16","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:53.186Z"}],"uid":"suite-0-0","cid":"0-16","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T00:48:53.217Z"},{"type":"suite:start","start":"2022-02-18T00:48:40.317Z","_duration":3089,"tests":[{"type":"test","start":"2022-02-18T00:48:40.318Z","_duration":3078,"uid":"test-00-0","cid":"0-17","title":"Login_1: Should be able to login with valid credentials","fullTitle":"UserStory: Login.Login_1: Should be able to login with valid credentials","output":[],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:43.396Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:40.318Z","_duration":3078,"uid":"test-00-0","cid":"0-17","title":"Login_1: Should be able to login with valid credentials","fullTitle":"UserStory: Login.Login_1: Should be able to login with valid credentials","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4cc60f68-d753-41a6-ad5c-b9ce0798f7d0"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4cc60f68-d753-41a6-ad5c-b9ce0798f7d0/clear","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4cc60f68-d753-41a6-ad5c-b9ce0798f7d0/clear","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4cc60f68-d753-41a6-ad5c-b9ce0798f7d0/value","body":{"text":"standard_user"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4cc60f68-d753-41a6-ad5c-b9ce0798f7d0/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb5ffcc2-9aaf-4b14-ba81-ae4059903f6e"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb5ffcc2-9aaf-4b14-ba81-ae4059903f6e/clear","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb5ffcc2-9aaf-4b14-ba81-ae4059903f6e/clear","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb5ffcc2-9aaf-4b14-ba81-ae4059903f6e/value","body":{"text":"secret_sauce"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb5ffcc2-9aaf-4b14-ba81-ae4059903f6e/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"428ba585-6451-4ab9-a32f-c44691b0f885"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/428ba585-6451-4ab9-a32f-c44691b0f885/click","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/428ba585-6451-4ab9-a32f-c44691b0f885/click","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6012cfb8-26ad-4d40-968a-6314d9b1fe91"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6012cfb8-26ad-4d40-968a-6314d9b1fe91/text","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6012cfb8-26ad-4d40-968a-6314d9b1fe91/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:43.396Z"}],"uid":"suite-0-0","cid":"0-17","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\example.e2e.js","title":"UserStory: Login","fullTitle":"UserStory: Login","parent":"","end":"2022-02-18T00:48:43.406Z"},{"type":"suite:start","start":"2022-02-18T00:48:43.406Z","_duration":5820,"tests":[{"type":"test","start":"2022-02-18T00:48:43.407Z","_duration":5815,"uid":"test-01-0","cid":"0-17","title":"Login_2: Should be able to login, then logout","fullTitle":"UserStory: Login.Login_2: Should be able to login, then logout","output":[],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:49.222Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:43.407Z","_duration":5815,"uid":"test-01-0","cid":"0-17","title":"Login_2: Should be able to login, then logout","fullTitle":"UserStory: Login.Login_2: Should be able to login, then logout","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"421c721b-fe6d-4888-8f30-a6b381ae619c"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/421c721b-fe6d-4888-8f30-a6b381ae619c/clear","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/421c721b-fe6d-4888-8f30-a6b381ae619c/clear","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/421c721b-fe6d-4888-8f30-a6b381ae619c/value","body":{"text":"standard_user"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/421c721b-fe6d-4888-8f30-a6b381ae619c/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"524bbd90-0a7b-4327-8dbe-c68c68fa8e38"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/524bbd90-0a7b-4327-8dbe-c68c68fa8e38/clear","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/524bbd90-0a7b-4327-8dbe-c68c68fa8e38/clear","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/524bbd90-0a7b-4327-8dbe-c68c68fa8e38/value","body":{"text":"secret_sauce"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/524bbd90-0a7b-4327-8dbe-c68c68fa8e38/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"962ec09a-e978-4ae5-b3b9-7071ea039d1d"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/962ec09a-e978-4ae5-b3b9-7071ea039d1d/click","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/962ec09a-e978-4ae5-b3b9-7071ea039d1d/click","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3bc43482-6286-4d55-a930-fb201a5dd551"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3bc43482-6286-4d55-a930-fb201a5dd551/text","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3bc43482-6286-4d55-a930-fb201a5dd551/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2862d03e-f97b-4465-a8aa-9de84607905a"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2862d03e-f97b-4465-a8aa-9de84607905a/click","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2862d03e-f97b-4465-a8aa-9de84607905a/click","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bc061bfc-74eb-4489-a3cd-70e7f42488cc"}},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bc061bfc-74eb-4489-a3cd-70e7f42488cc","ELEMENT":"bc061bfc-74eb-4489-a3cd-70e7f42488cc"}]},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bc061bfc-74eb-4489-a3cd-70e7f42488cc","ELEMENT":"bc061bfc-74eb-4489-a3cd-70e7f42488cc"}]},"result":{"value":true},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bc061bfc-74eb-4489-a3cd-70e7f42488cc","ELEMENT":"bc061bfc-74eb-4489-a3cd-70e7f42488cc"}]},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bc061bfc-74eb-4489-a3cd-70e7f42488cc","ELEMENT":"bc061bfc-74eb-4489-a3cd-70e7f42488cc"}]},"result":{"value":true},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bc061bfc-74eb-4489-a3cd-70e7f42488cc/click","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bc061bfc-74eb-4489-a3cd-70e7f42488cc/click","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"0f3724aaebb962dada180ba018f1726d","cid":"0-17","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:49.222Z"}],"uid":"suite-0-1","cid":"0-17","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\example.e2e.js","title":"UserStory: Login","fullTitle":"UserStory: Login","parent":"","end":"2022-02-18T00:48:49.226Z"},{"type":"suite:start","start":"2022-02-18T00:48:43.745Z","_duration":8554,"tests":[{"type":"test","start":"2022-02-18T00:48:43.746Z","_duration":8539,"uid":"test-00-0","cid":"0-18","title":"Login_3:should be able to login, logout, login","fullTitle":"UserStory: Login.Login_3:should be able to login, logout, login","output":[],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:52.285Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:43.746Z","_duration":8539,"uid":"test-00-0","cid":"0-18","title":"Login_3:should be able to login, logout, login","fullTitle":"UserStory: Login.Login_3:should be able to login, logout, login","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d9458be3-9300-4377-bde9-da1dd5854a86"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d9458be3-9300-4377-bde9-da1dd5854a86/clear","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d9458be3-9300-4377-bde9-da1dd5854a86/clear","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d9458be3-9300-4377-bde9-da1dd5854a86/value","body":{"text":"standard_user"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d9458be3-9300-4377-bde9-da1dd5854a86/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e9b80417-b3c3-4c6b-94f2-74813fe758df"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e9b80417-b3c3-4c6b-94f2-74813fe758df/clear","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e9b80417-b3c3-4c6b-94f2-74813fe758df/clear","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e9b80417-b3c3-4c6b-94f2-74813fe758df/value","body":{"text":"secret_sauce"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e9b80417-b3c3-4c6b-94f2-74813fe758df/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3f2d142c-5cc8-4a97-80bb-734174072a7d"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3f2d142c-5cc8-4a97-80bb-734174072a7d/click","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3f2d142c-5cc8-4a97-80bb-734174072a7d/click","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"57d86d59-043c-4c3b-956a-2a84a44a4d98"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/57d86d59-043c-4c3b-956a-2a84a44a4d98/text","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/57d86d59-043c-4c3b-956a-2a84a44a4d98/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"30056415-bc81-421a-95ec-328b5b65506b"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/30056415-bc81-421a-95ec-328b5b65506b/click","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/30056415-bc81-421a-95ec-328b5b65506b/click","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"48dcf817-c51f-416b-9144-a1e8a8f157a9"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"48dcf817-c51f-416b-9144-a1e8a8f157a9","ELEMENT":"48dcf817-c51f-416b-9144-a1e8a8f157a9"}]},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"48dcf817-c51f-416b-9144-a1e8a8f157a9","ELEMENT":"48dcf817-c51f-416b-9144-a1e8a8f157a9"}]},"result":{"value":true},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"48dcf817-c51f-416b-9144-a1e8a8f157a9","ELEMENT":"48dcf817-c51f-416b-9144-a1e8a8f157a9"}]},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"48dcf817-c51f-416b-9144-a1e8a8f157a9","ELEMENT":"48dcf817-c51f-416b-9144-a1e8a8f157a9"}]},"result":{"value":true},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/48dcf817-c51f-416b-9144-a1e8a8f157a9/click","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/48dcf817-c51f-416b-9144-a1e8a8f157a9/click","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"15a3a1f1-6cc3-4095-8601-43a50d7e574c"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/15a3a1f1-6cc3-4095-8601-43a50d7e574c/clear","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/15a3a1f1-6cc3-4095-8601-43a50d7e574c/clear","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/15a3a1f1-6cc3-4095-8601-43a50d7e574c/value","body":{"text":"standard_user"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/15a3a1f1-6cc3-4095-8601-43a50d7e574c/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9030baab-c424-48e8-931d-21abcb3b1e89"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9030baab-c424-48e8-931d-21abcb3b1e89/clear","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9030baab-c424-48e8-931d-21abcb3b1e89/clear","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9030baab-c424-48e8-931d-21abcb3b1e89/value","body":{"text":"secret_sauce"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9030baab-c424-48e8-931d-21abcb3b1e89/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"817cf00d-ae1d-4fb7-aa1f-f803bd1b01f7"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/817cf00d-ae1d-4fb7-aa1f-f803bd1b01f7/click","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/817cf00d-ae1d-4fb7-aa1f-f803bd1b01f7/click","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"58281155-d9b4-4118-a68b-af27839e50af"}},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/58281155-d9b4-4118-a68b-af27839e50af/text","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/58281155-d9b4-4118-a68b-af27839e50af/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"61e1bd98c58ecd0e33ad0697f4efac14","cid":"0-18","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:52.285Z"}],"uid":"suite-0-0","cid":"0-18","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js","title":"UserStory: Login","fullTitle":"UserStory: Login","parent":"","end":"2022-02-18T00:48:52.300Z"},{"type":"suite:start","start":"2022-02-18T00:48:49.975Z","_duration":2603,"tests":[{"type":"test","start":"2022-02-18T00:48:49.976Z","_duration":2588,"uid":"test-00-0","cid":"0-19","title":"LoginError_2: accessing a valid page without being logged in should show correct Error message","fullTitle":"UserStory: Login.LoginError_2: accessing a valid page without being logged in should show correct Error message","output":[],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:52.564Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:49.976Z","_duration":2588,"uid":"test-00-0","cid":"0-19","title":"LoginError_2: accessing a valid page without being logged in should show correct Error message","fullTitle":"UserStory: Login.LoginError_2: accessing a valid page without being logged in should show correct Error message","output":[{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/inventory.html"},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/inventory.html"},"result":{"value":null},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"548dad83-bbac-4dd3-a772-57ba661595b7"}},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"548dad83-bbac-4dd3-a772-57ba661595b7","ELEMENT":"548dad83-bbac-4dd3-a772-57ba661595b7"}]},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"548dad83-bbac-4dd3-a772-57ba661595b7","ELEMENT":"548dad83-bbac-4dd3-a772-57ba661595b7"}]},"result":{"value":true},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/548dad83-bbac-4dd3-a772-57ba661595b7/text","body":{},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/548dad83-bbac-4dd3-a772-57ba661595b7/text","body":{},"result":{"value":"Epic sadface: You can only access '/inventory.html' when you are logged in."},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"581ee81eab1da8dbd1cae05e9219d07e","cid":"0-19","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:48:52.564Z"}],"uid":"suite-0-0","cid":"0-19","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\loginerror2.e2e.js","title":"UserStory: Login","fullTitle":"UserStory: Login","parent":"","end":"2022-02-18T00:48:52.579Z"},{"type":"suite:start","start":"2022-02-18T00:48:52.580Z","_duration":604321,"tests":[{"type":"test","start":"2022-02-18T00:48:52.582Z","_duration":604313,"uid":"test-00-0","cid":"0-20","title":"LoginTimeout_1: Logged in user should be kicked out after 10 minutes","fullTitle":"UserStory: Login.LoginTimeout_1: Logged in user should be kicked out after 10 minutes","output":[],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:56.895Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:52.582Z","_duration":604313,"uid":"test-00-0","cid":"0-20","title":"LoginTimeout_1: Logged in user should be kicked out after 10 minutes","fullTitle":"UserStory: Login.LoginTimeout_1: Logged in user should be kicked out after 10 minutes","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"640d7ccc-8263-412b-9dab-557bf528893d"}},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/640d7ccc-8263-412b-9dab-557bf528893d/clear","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/640d7ccc-8263-412b-9dab-557bf528893d/clear","body":{},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/640d7ccc-8263-412b-9dab-557bf528893d/value","body":{"text":"standard_user"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/640d7ccc-8263-412b-9dab-557bf528893d/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e7d948dd-383b-4720-99b2-5a6dbe5d88c4"}},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7d948dd-383b-4720-99b2-5a6dbe5d88c4/clear","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7d948dd-383b-4720-99b2-5a6dbe5d88c4/clear","body":{},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e7d948dd-383b-4720-99b2-5a6dbe5d88c4/value","body":{"text":"secret_sauce"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e7d948dd-383b-4720-99b2-5a6dbe5d88c4/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9024fe33-0fb6-49db-a81c-9eead39bae22"}},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9024fe33-0fb6-49db-a81c-9eead39bae22/click","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9024fe33-0fb6-49db-a81c-9eead39bae22/click","body":{},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c84158bf-7de1-4c70-9c3d-a0fad52c2188"}},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c84158bf-7de1-4c70-9c3d-a0fad52c2188/text","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c84158bf-7de1-4c70-9c3d-a0fad52c2188/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5f45f5b9-6668-4ae9-93d9-b37c4b04bdd9"}},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5f45f5b9-6668-4ae9-93d9-b37c4b04bdd9/click","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5f45f5b9-6668-4ae9-93d9-b37c4b04bdd9/click","body":{},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/refresh","body":{},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"error\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c96a0668-18a7-471f-81df-7d17d4cee34c"}},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c96a0668-18a7-471f-81df-7d17d4cee34c","ELEMENT":"c96a0668-18a7-471f-81df-7d17d4cee34c"}]},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"c96a0668-18a7-471f-81df-7d17d4cee34c","ELEMENT":"c96a0668-18a7-471f-81df-7d17d4cee34c"}]},"result":{"value":true},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c96a0668-18a7-471f-81df-7d17d4cee34c/text","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c96a0668-18a7-471f-81df-7d17d4cee34c/text","body":{},"result":{"value":"Epic sadface: You can only access '/inventory.html' when you are logged in."},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"32eb1a2e1a9d4268ea48bc54824bb48f","cid":"0-20","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:58:56.895Z"}],"uid":"suite-0-0","cid":"0-20","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\logintimeout1.e2e.js","title":"UserStory: Login","fullTitle":"UserStory: Login","parent":"","end":"2022-02-18T00:58:56.902Z"},{"type":"suite:start","start":"2022-02-18T00:48:52.913Z","_duration":18970,"tests":[{"type":"test","start":"2022-02-18T00:48:52.915Z","_duration":18931,"uid":"test-00-0","cid":"0-21","title":"Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","fullTitle":"UserStory: Reset Cart State.Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","output":[],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T00:49:11.846Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:52.915Z","_duration":18931,"uid":"test-00-0","cid":"0-21","title":"Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","fullTitle":"UserStory: Reset Cart State.Reset_1: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Inventory Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0f088f5a-b1c4-4499-b1d5-f6fce8ac484d"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0f088f5a-b1c4-4499-b1d5-f6fce8ac484d/clear","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0f088f5a-b1c4-4499-b1d5-f6fce8ac484d/clear","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0f088f5a-b1c4-4499-b1d5-f6fce8ac484d/value","body":{"text":"standard_user"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0f088f5a-b1c4-4499-b1d5-f6fce8ac484d/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"aadbf4fc-152a-4ca2-a8c6-7324c5e70cf8"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/aadbf4fc-152a-4ca2-a8c6-7324c5e70cf8/clear","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/aadbf4fc-152a-4ca2-a8c6-7324c5e70cf8/clear","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/aadbf4fc-152a-4ca2-a8c6-7324c5e70cf8/value","body":{"text":"secret_sauce"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/aadbf4fc-152a-4ca2-a8c6-7324c5e70cf8/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cf0ad00f-dd39-4fce-ba4c-ae0df153fa87"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cf0ad00f-dd39-4fce-ba4c-ae0df153fa87/click","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cf0ad00f-dd39-4fce-ba4c-ae0df153fa87/click","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"013b8844-8dd8-4648-8056-d315172db386"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/013b8844-8dd8-4648-8056-d315172db386/text","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/013b8844-8dd8-4648-8056-d315172db386/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0a9f1a27-96f0-424d-b5cb-3cfa42185271"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0a9f1a27-96f0-424d-b5cb-3cfa42185271/click","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0a9f1a27-96f0-424d-b5cb-3cfa42185271/click","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3376860b-bb11-4678-8ed7-cfbbcd841840"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3376860b-bb11-4678-8ed7-cfbbcd841840/click","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3376860b-bb11-4678-8ed7-cfbbcd841840/click","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"75bc2769-d691-4eb0-a024-b6f7102e4871"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"75bc2769-d691-4eb0-a024-b6f7102e4871"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/75bc2769-d691-4eb0-a024-b6f7102e4871/text","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/75bc2769-d691-4eb0-a024-b6f7102e4871/text","body":{},"result":{"value":"2"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"75bc2769-d691-4eb0-a024-b6f7102e4871"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d90aa22e-3a36-494b-81d2-0eb4bd3f5398"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d90aa22e-3a36-494b-81d2-0eb4bd3f5398/click","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d90aa22e-3a36-494b-81d2-0eb4bd3f5398/click","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"75bc2769-d691-4eb0-a024-b6f7102e4871"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd"}},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":true},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"452c4225-2010-43f7-9fab-7b34a92464dd","ELEMENT":"452c4225-2010-43f7-9fab-7b34a92464dd"}]},"result":{"value":false},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"iVBORw0KGgoAAAANSUhEUgAABhIAAANUCAYAAABWkrf4AAAAAXNSR0IArs4c6QAAIABJREFUeJzs3Xl81OW99/83k8lkmcyEEAjLIIi4JIqItiTlgKdCYkF7U0ms/rDWRI9LW0F70N5FsLVWK0GP1ZZFe1xaA3W5tSTY3EelBrhb4VhCW0DRQWuPVRjZCZnJOtl+f4QMM5NZk0kmCa/n48GjzMz3e32vzCSpXO/v9fkM6+jo6BAAAAAAAAAAABh0nE5nn1/D0OdXAAAAAAAAAAAAgxZBAgAAAAAAAAAACIogAQAAAAAAAAAABEWQAAAAAAAAAAAAgiJIAAAAAAAAAAAAQREkAAAAAAAAAACAoAgSAAAAAAAAAABAUAQJAAAAAAAAAAAgKIIEAAAAAAAAAAAQFEECAAAAAAAAAABniN///vdRn0OQAAAAAAAAAADAGaArRIg2TCBIAAAAAAAAAABgiPMPD6IJEwgSAAAAAAAAAAAYwoKFBpGGCQQJAAAAAAAAAAAMUeHCgkjCBIIEAAAAAAAAAACGoEh3HIQ7blhHR0dHLCYEAAAAAAAAAAD6l9Pp7PNrsCMBAAAAAAAAAAAERZAAAAAAAAAAAACCIkgAAAAAAAAAAABBESQAAAAAAAAAAICgCBIAAAAAAAAAAEBQBAkAAAAAAAAAACAoggQAAAAAAAAAABAUQQIAAAAAAAAAAAjKGO8JAAAAAAAAAACA3tm9e3fMx5w2bZokdiQAAAAAAAAAAIAQCBIAAAAAAAAAAEBQBAkAAAAAAAAAACCoiIIE99731bxnV1/PBQAAAAAAAAAADDBhmy27976v2tVPqKPOJevd9yo5b0Z/zKsb51OrVPvEo31+nbM+cfT5NQAAAAAAAAAA8dX4hzfVtP0dtXzwnlo/+0xttSclSQnpw2WcOFGJF01V8szLlfK1q+I80/gLGSR0hQhNm/8gSXKu+rkUxzABAAAAAAAAAICeanc55Xr2adW//Fu11ZwIeExbzQm11ZxQ8+5dqnuxTAkZI2S+4duy3P49GSzWfp7xwBA0SPAPERLGjlPKvK/LNO2yfpuct9RrimT60pf7bPyjN17XZ2MDAAAAAAAAAOKr/rVXVPvYI0EDhGDaak7I+dQq1b/8W6X/8H6Zr1vYRzMcuAIGCYFCBMsdd8p8/bdkSErq1wl2MdrGy2gb3ydjN+347z4ZFwAAYDBw2+1q3LxZ7n12tTocctvtPq8bbTYZbTYl5+YpMSdHqfn5cZopAAAAAPRMzU+Wq+7Fsl6N0VZzQieW3Sv33veU8dMVMZrZ4NAtSBiIIQIAAABiq9XhkGtdmeoqKtTudIY9ttXhUFN1tee5tMIimQsLlZyb29dTBQAAAIBeOb5kkRoqN8ZsvLoXy9TurFXmk2tjNuZA5xMkECIAAAAMba0Oh2rXrFFdRXmvxmmoeluW4mJJ8gQRBuuZWSsUAAAAwMBV85PlMQ0RujRUbpTBmn7G7EwwdP2FEAEAAGBoq12zRgcLF/Q6RDBYLBq9br1MOTmSJOe6MjkK8tVQVRWDWQIAAABAbNS/9kqvyxmFUvdimepfe6XPxh9IjBIhAgAAwFDW7nTq6OJFPqWJ/Jmys2UuLPKEA6bsbBmsVrU7nTpcUuzpm+AfIrQ7nXKtW+e5hrWkRBnLlvf9FwUAAAAAIbS7nKp97JEIjpyg1PsfkXXBTCVmnFoLb3aq7ePNcj6wWHXvhz679rFHlDLvahksQ3uHtrHupfVq/OMWQgQAAIAhyG236+jiRWp1OLq9Zhw3Tul33aXU/IKgZYlqSkuDhghS524E7x4LzrIytTtdyiwtjfFXAgAAAACRcz37tNpqToQ5aoIsv92k4V/p/PdQ+4G/q60hSQmTJyjh4kJl/DpLw755vVyfBR+hreaEXM8+rfR7lsZu8gOQseaB+zwPCBEAAACGDrfdrsMlxd2aKRssFllKSmQtLvEECO1Opxq2bFbbAYeaqnd0PudyBQwRmqqrlZyb6+m34K+rdBJhAgAAAIB4qX/5t+EP+uYjsnzFKjX/XQ33Fet45eedz08sVOYzP1fq5JlKf/RuuRauCnutIR8kdP2FEAEAAGDo6Co15B8imLKzNWrtUzLabJKkpupqudaVhexv4B0iHF+2TOmLF0uSalevDnpOXUW5knKnK62wqPdfTAhuu13uj/ap7cDpHRdJebkyXZBN8+c+1u50yv3RPrU6HN3ef+M4m+d7DPHVtPN0STN+LgAAwEDRXP1uRMcl5c7o0fiNf3gzgt0IUtr/+rISJLX9+T9PhwiS9FmFjj9dpKTH5yjh/FmyaJVcIcZpqzmhxj+8qZSvXdWj+Q4GniDBeM5kmS6cQogAAAAwBAQqZ5San6/M0pUyWK1qdThUU7oibINk/xBhmCVNRptNrQ6H6jZWhDz3+LJlMmXn+JRCioWuvgz+ZZU8Tm2SSC0okKW4RMm5uSHHa6iq0tHFi3yeS1tQqMyVK8PO5fBNN/ks1Kbm52vU2qfCnndixSNyrVvn81xmaWmPghdH/pxun7WluFgjlt8f9VjhtDudqt+4UQ1VbwfvuXHq/TfabEotKJB5QWGPvwdOrHhELfv2KTE7u0++nmC8Q7jM0pW9DkUOF98U0XEGq1XJuXkyL1jQqwX/uo0VcpWVeXYUeTPl5Cg1v0CW4mJCBQAAEDdHvvXNiI7LevF3SsqLPkxo2v5ORMclpiepo61Zbe+/3P3FXbXqiPKaZ0SQ0Lz9HTkTjLJ+/14lXXJpPOcEAACAXji5ZnW3RV7vBe6m6uqAuxX8+YcIDVVvy7Z5i6TQuxG8HV++TGMrNvbgqwgsVM8Hfw1VVWqoqlJybm7IxeBAQYP7o30Rzcc7ROh8vDOi81rs3cdPzs2L6Fxvbrs94HvRuHmzFOOF97qNFapdvTqi916SWh0OOcvK5CwrC/sZBNNi39f5HkfzL7hectvtPgFbXUW5hi++q1djhmp07q+hqkon16zW8MV3yVJcHNV13Ha7ji9fFjBA8D7GbbfLua5M1uISzw4jAACAgajx7bd6FCS0fPBeRMfVFJ6jmiCvJf/7lzoXz49+rsYYXnOwMpou+7LaDh5U20GHmv60VZIIEwAAAAapVoej253upuxsZZZ23l1fV1Gu48uWhR3HP0SoqyhX+uLFMlitctvtYXcjdHHb7aqrKI9JiaNgPR/CaaquVs2KR4LuFDBYrTJlZ8u97/TivttuV7vTGfKO7YYAuznanU5PD4mQc/ILIIzjxvXorndXWVnA51sdjojmEYl2p1M1paWe3hc90VRdLUf+nB7vuuhP/u9pfUVFr4OELsnTc5WUF/gzaXc6PcFJu9OpEysekdtuj7jXiP/Ph3HcOJmLinwCqqbqHWqsqpJ73z61O506uWa1UvLzY75rCAAAIJxQJYvaXbVqsX8oSWraEVkJJH+tn4XojhyJOY9r+NcmSGqW+81Vau2Paw5wxlG//q0a/uv3cj61Sm2OAwM2THA9/ys51/4y5DFp375F6ff8sJ9mBAAAMPDUrl7ts9BusFg0au1TMlitaqqujjpEOLHiEdVVlMtgschaXCJJqildEd2c1qyJyeLx8eXLog4RulhKbg75elJurk+QIHUufqcWFAQ9p6spdaDnQy3gB7o7vSe7ESSpYcvmoK/Vl5f3Okhodzp1uKQ45B3uXfzDmEAMloFfSqfrPbUUF8u1bl1MQ5mkvNywoURTdbWOLrpT7S6X6irKZS4sjOjaNaUrPD8fwUpzJed2Xr8rXDNYrIQIAAAgLrJe+l3I1/ef23mTTYv9A7Ue2C/j+LOiGr+t9mSP56Y5D2j0ozcoMUlq//OjOv6Lz8Of09trDgIGQ5pF5sJvynrn3UqwjZckNf1pq5y//Lma9+yK8/RO62h2q93pDPkHAADgTBaob4GlpMTT08C/D0AwGcuXy5STo7qKcs/uBktJiSeMiKZMi2devbibXeq8+z/QYnb64sU6q3qnJu77SBP3faSzqndq1Jq1Sp5+euE1NT8/7EJsoIV8977Qi+fNQcoYNe8I/f4ECiCC3aUeSkNVlc9/AxvHjfN9PUTIEKlgZXIMFossxcUavW69570fu/F1n88gbUGhzzmp+fkhg5mBoMHrPbWW3Ox5T+vLe/f9G43k3Fyf3TORXNv75zI1Pz9sf4/k3FyNXrdeo9au7d1kAQAA+khKwVzP35t7uCuhJ4zz12jM6u/IlCG17/5PHf/2f0a0G+FMYJSkYaYkmQs7G1wM1J0JqVd9XYnnnR/vaQAAAAxYzrIXfB4bx43z7CI4vuy+iG686Co9410CyThunOcu6to1kfVG8Odat65XuxLqAwQR6YsXd7u722C1KrWgQKkFBZ07MO5bqowIegUEChqad1RLQcrHtzudQe/S9y9bFHBcP6n50S+wN/qVVkopKFBjVZVav/jCM8eGqqoeL96fXLM6YPkm76bdgXh/Bul33aUaT4me8M2r463r+6yr1FRKQYFc69apYctmZYQpdRVLybm5nh0eDVs2KzPM8d7hVCTf75JotAwAAAa0pLwZaqzaJKmzT4L52uujOj8hfbjaak5EdU7y0t9rxL99SQkJzWrb8qiO3BFdiJCQPjyq6w02nmbLAz1MME6aLOOkyXGdAwAAwEDWuNn3DvT0u+6KahdBoBChaxypc2E6KTdXSRGWeKlds8bz966mwD3pA9B5bVe358IFE8m5ubJt2RrR+IH6JIQKBMK9n6FK4fiPa8rOjnpRt93p7Lb7JDk3Tx1Ol8/z9RXlPQoS2p3Obr02pOAlc4Ix2mwatfYptTocA37hut3pVMOpnyFzUef3VlphkVzr1p16rapf+zsYbTZPL4NwWrxCrZ7+jAEAAAwkKVfO08lHHpQkNVdHvyPBOHFiFEHCBKWt/j8aftUEDZNT7heX6/hPKqLeiWCcODHaaQ4qRu8HAz1MAAAAQGBdC/Xeuu5yd/ntVAgkWIhgHDfOs3hqsFqjajrb1dS1S0NVlawlJRGfH47BYonZWFLwPgmBAgH/3QDGceM8OwE6zwvcJyFQABFpMOOtYXOAnQIFBWp3+QYMDZs3h20aHYhzXVm3BWxTdnZUIYK3wbC4XVdx+n3r+p435eR4Ptv6iop+DRIChWfBJHi9vz35vAEAAAYa4/izZLSNV6vjgNqdTjXveFdJed0bNAcLGQyjsiK+VvLKdZ0hQvMRNf3iGh19NrKeCP4SL5rao/MGC6P/E4QJAAAAg4//AnXXXe7ed1kHEyxEkKTUK68MW6rHn3GczVMWxnthviWChr3BGKzdQ4Oa0lJllpb2eEx/ybl53e7Cd9vtgQMBv/fEXFTkswOjcfPmgKFLoP4IPWm07B9kpObnn/rfAh2X72fYkzvp6ysquj0Xacmcwar+VABjys72CT4sJTerpnSFmqqre7WrJlqtX3QGg979PoLxbpjsXFcWVeAHAAAwUKVcOU+uF56T1FneKFCQcORb3+zVNYy3v6rMb56nYc1/V8N9xTpe2bMQQZKSZ17eq7kMdN2CBGlghgltx46q7eiRHp1ryrkoxrMBAAAYWJr9FqjNpxaOA9257i1UiCBJzrIyOcvKopqLpbhYI5bfr+TcPNXKq7zRR/tCnBVaSkFBt0CkrqJc7S6nMpYtj8nibsA+CdU7JL9dFK0OR7fdH2mFRd1KOQW6MzxQmBKuEbS/Voej23uRcqp8kcFqVWp+vs/r0d5JH2h3iyk7O+p5DiZuu93T88Li93mnFhSopnSFpNjvqgnGWVbm+QzMRYVhju4MkGosK9Tucql2zRoZbbZ+3T0BAADQF5LyZniChKYeNFweJqkj5BEzlb5wpgySZJyglEf+n8Y/EuCwE9t18oqbVBdipISMEUr52lVRz3EwCRgkSN3DhI7GRpku+7KMZ5/Tb5PzVv/qy6p94tGoz0vKm6GsF3/XBzMCAAAYOPzLoHTdoRyosW+XcCFCT7XYOwMDU3a2z/PBmhNHIq2wSK6ysm6lhxqqqtRQ1XnHffrixb0KFAL3SdjZ7Tj/XQXJ03NltNkClDeq7tafwH+8nvRHaAjYAPn0dfxDl2jvpI9V+aXBpM6rmbd/42ujzabk6blq2lkt17qyPg8SXOvWqXZtZyhlys6OqBG3wWpVZulKHV28SJJ0fNkyNW7eHLOQDQAAIB6S8v7F8/cW+wdqPbBfxvFn+R6T232XQpfWA5+r7QtH0NelQiV2tTVISNKw1GADJWlYmLmab/h2mCMGv6BBguQbJrS7XDJfd4MS0tP7ZWIAAACIXLDyQ/53lnfpChHcdrvqyysiKp8SinufXe2uzjCja+dBrOu0j1r7lA4uuMZzHW91FeWqqyhXcm6uzEVFSlsQ/i7uQPz7JLQ7nd0W4f3DmaS8zvcuOTfPpz9BU/UOnyCha5eCt5QeNEKu92uynJqf7/NeByxvFMWd9O2u7s19jbbxUc9zMOlqVJ62oDDg9625qFBNOzsDGbfd7lNKKBrN1dU+O1e8uffZfXaDmLKzNXrd+oh/jlILCjRqzVodX3af2l0un5DNXFg4pHeUAACAoclgtSopd4anD0Lzjne7BQlZLwW/gbzd5dShOTNDNF3+gQ6d+4NezzMhY4Qst3+v1+MMdCGDBOl0mNDRIRmSkvpjTgFZbv2O0r59c9yuDwAAMJj47wbw1hUiSJ07F0avX9+ra9VVlKtp2enFdf/F8lgx2myybd6io4sWBQ1Omqqr1VRdrdrVq5WxbHm3HQHhBOqT0FS9w6dMTMOWzd3OkToDBe8godlv90GgO/2j7Y/QtZDtzT+MCFjeaGNF5EFCgM8vmoVzt93uKQUUzOh1vfuei6WGqirP4n2wYMc7nHGVlfW46XTX92c4BqtVGcvvjzqMSy0oUHLuFtWsWOH5XuwK2Uw5ObKUlPQ4ZAMAAIiHlCvneoKExrffkvna6yM+12CxKv2H9+vEsnv7anqSpPQf3i+DJbY3UQ1EYYMEqTNMCLd9o68NS0rSsDgGGQAAAINJ1wKke5/vorN3iBALgcoiGceNi9n4/gxWq0avX6+6inLVrl7tU0rIW6vDoaOLFymtsEgZy5ZFvCAbsE/CjmrPe+a/q8BgsXjO8Q8F/Psk+PexCHa9ULxL8HQJVPrGv7xR153uPS1zE0041O5yRbRYPlB0Na42jhsXNHgyWK1KW1Couo0VatiyWZk9vFby9FzPDhZ/LXa72p0uNe2sVrvTqcPFN3l2GUTDYLUqc+VKpd91l5xlL6i+okLtLpfcdruO33efalevVmbpSnYoAACAQSH5K6fLG3UFCtEwX7dQ7r3vqe7F6Pq+RSrtxhKZr1vYJ2MPNBEFCQAAABicTNk5nrv3DVar6isqVF9REeas0DKWLZcpJydob4WuMjjByirFQlphkdIKi9RQVSVXWVnQHQp1FeVy77NrbMXGiMY1WK2eevhdvJtE+y+Qey/GGm227j0WvPok+PdH6Ek5Kf/Pzr+s0ennu5c3cpa9oBHL7w97jUDjuffZo97dMRi0O52eO/fDlZlKKShQ3caKznMqynsUyCXl5Wr44rvCzqlrR0FDVZWOL1umzNLSqK9ltNk0Yvn9Gr74LtVVVMhV9oJav/hCrQ6HDhffpLTCoh6NCwAA0J8Scy6S0TZerY4Danc61WL/QIk5F0U1RsZPV6jdWauGysj+TRCp1PkLlPHT0DtxhxKCBAAAgCHAfwE7UB33dqez13eKZ5aWhgwRJMlgtUjqHiT0xU6F1IICpRYUyG23y1VW5lNaqIvbbtfJNavDLuB2ScrzCxK8dhb47ypI8tuF4N9jobGqSqkFBWp1OLrd1R/szvRgvOvnd2l3uYLW3DfabD7HN27eLEUQJATSdqDvQqF4ath8unF1h6su6Hvpr/FU74G+0LWjQJLqNlaorqK8Vz0ODFarrCUlspaUyFlWpto1q9Xucnl2txAmAACAgS4pb4Zay1+TJDW8/ZbSowwSJCnzybUyWNNjtjMh7caSMypEkAZRkODes0vNf/tL2OMst9zeD7MBAAAYWPxrcrY6HDLl5HRbFO+NrrJIoUIE6fTieqvjgM/zfdmw15STo8yVK2UpKdHxZff5LOZLkmvduoiDhOTcPNXKd0G5a2dBt10Ffou7/j0Wut77poBljaLrjxCorFGkNfclRdwoODW/oNuCejTlfIw2m9IXL/Y8bjvgCBjwDATen1Wg9zeYhs2bfcpW9YWM5cs975ur7IWYlCKylpQoOTdXh4tv8oQJNGIGAAADXcqV81R/KkhofHuT0u/uWc+DjJ+ukGnKVNU+9kiIBsyhJWSMUPoP7z9jyhl5GzRBQtP2d1T7xKMhj7He+f1+mg0AAMDA4h8YNFXvUGpBgdIKi6JesG6q3tFtITnSEEGSpwROV+157zn2NVNOjkavW6+DC67x6Z/QtRsjkgXTQMe499llsFq79UfwX5T3P7fV4VCrw6HmHb6L/d69FSJVv7H3W7EjaRRsysmRcdy4bu9fpOV8jDabT2jTVF09IIME78bVpuzsiBvkdf2c1VVE3sC6J7zLbPkHWL1hysnRqLVP6XDxTZJiF1IAAAD0laS8030SWuwf9OqGDvN1C5Uy72q5nn1a9S//NuJAISFjhMw3fFuW2793RjRWDmTQBAkJI0fK1INtKwAAAGcCU7bvgnZXGRujzRZ1g92aUt8tutGECKbsbM/1vJv9StHfgd9TBqtV5qKibmFI5w6JyBZM/fsk+AcBUuDAwWC1BuiTsKPbrpBoF24bqqqiangcdJwIdxYk5+Z1W/yvKS1Van5Bn96F35+cZS94/j5q7VMR/5w45sxW6xdfqH5j3wYJkpSYk+1pvhxLybm5nu/TWIYUAAAAfcFgtSopd4an2XLj22/JfO31PR/PYlX6PUuVfs9SNf7hTTVtf0ctH7wn93t71NHe7jkmcfJkJV40VckzL1fK166KydcymA2aIMF8/bdkvv5b8Z4GAADAgBToTvia0hUR3y1jLiyU0WbrbE586i5tKboQQZIyTtXg9y8T05M78P117SroadPfaEordeuT8NE+T++HLsGa86YUFPgECV27EnzGjzJU8d/dIUmj1qwNu6jfUPW2T/medqdTDaf6NoSSftdd3YKEdqdTh0uKNbpsXVRhgvf300DSeCro8g6/ItEVUrnt9ohKRfVGWx82LO/63RDrkAIAAKAvpFw51xMkNO/4714FCT7jfu0qpXztKrUe2K+DV3xFUue/XWy7BuZ/w8bToAkSAAAAEJzBalVqfr7PLgBnWWSNxIzjxnlq2nvfxR9tiJA8PdcTFvjvBkjN79niv7ea0lLVVZQrtaBAmStKgy5mtzudqq/oXkrHYLEEODow/z4J7U6nT6mfrmMiOTdQA99oQpV2p1MNW3x3d5iysyMKVIw2m0+QIJ1uAB3uPEtxcbdz3Xa7DpcUa9SatWEX39udTtWuXRPx92F/aqqu9oQ7lih3FaQVnt7tUldRrhE5PWtgHYmuQCqa791o9eXYAAAAsZL8ldPljRqrNsV8/Ma33/L83buUEk4zxHsCAAAAiI1gd8iHk7mysw9VXUW5Z3E12hDBYLEoY/nybuN0Sb8rskbHwdRVlHt2OTRUVclRkK/jy5Z1KxnUVF2twyXF3a5vHDcuqjvHA/ZJ8Lqz3jhuXNCF9HAhQaDeCqE0bO5e1sgcQa8CqTMQMGVn+zxXt7EiorvQhy++q9u5Uuf74MifE/D973q9pnSFHAX5AzJEkKT68tM7ZqINubzf01j0rQjGO+wIN8d2pzNgYBVMq8Ph+ezojwAAAAaDxJyLPDuM251Otdg/iOn4zTve9fw95cp5MR17qCBIAAAAGCLSCotkHDcuqnMC7SKINkToPGelTDk5anc6VVNa2u0a0fZp8NZZpsl3zK7mv4dvukmfZV/g+XO4+KaApXQsJTdHfd3k6cEXWMP1ewh9bnQLt4HKGkVT3ilQ6NCwufuY/gxWq0atfSroHeve7//+3Oly5M/RZ9kX6GDhAjnLygZsyRzvHR6p+fk96vnQtYuhq1RUrLntdh1dvMjzOFwQd3z5Mp1cs1oHCxeELSXV7nT6jN2Tnw0AAIB4SMqb4fl7g9cOgljw3uXgfR2cRmkjAACAIST9rrsiXvzvOl6STq5ZrVaHQ5biYqUVFp26q7w0zNmdMktLPQvbh0uKuy0gZ65cGfF8AjFYLEqePr1b8+ZIJU/P7VFTXP8+Cf6vhZJSUBD03Gh2jrQ7nd2+7mhr+qcWFHRroN1YVaW0CHY1GG02jd34uo4uutOn70OgeQYLDgwWi9pdrojnG3D8OlfQ9zOYYGGO9w6PSHd2+EvNL9Bxdf6cRVIqqkub44uQX0e706XGqiqfHiOZpaUhP+92p1OtBw5I6gwgDhYuUGpBgcyFRT7fK10BSu3q1V47HfLZkQAAAAaNlCvnqb78NUlS49ublH73vTEZ17usUWLOhTKOPysm4w41BAkAAABDSFphkerLKyJadO3ajdDudMq1bp3SFhRqxPL7PXXww91RbrBYlFm60rOIenzZsm53Q6cvXtyr3QjS6TvjnWVlql2zOqpF6dT8fGWW9izI8O914Dtu6IXjUIuz4XYzeAu0cyDaxe+uUjzeQUDD5s1qdzojuhvfaLNp9Lr1OrlmdbeeCeEkT89V5sqVcuTPieo8f267XYdvuimqcybu+yjg8139MwwWS48bdxusVqUtKFTdxgrVbaxQxvLlEb2X3iW6wl7jVLmwcIGPwWrt9vk0VFWF3SmRPD23xz8bAAAA8eDdu6DF/kHE/z0bjndZo2T6IwRFaSMAAIAhJnPlyogaqHbtRnCuK1PqnHxlrlwZcYiQPD1Xo9etV2pBgdqdTh1ftqzbAqkpO1vDF/euN4I3a0mJbJu3KGPZ8rAlnIzjximztLSzNE8P/3ERLAwwZWeHHdOUkxPwMwjVWyGQQAv3PVn8DhQ+1AVoSB2MwWrViOX3y7Z5iyzFxWHf/9T8fI1as1aj16/vdZAUS60Oh5reA4AvAAAgAElEQVSqO0O23jYA995ZEkmpqEglT89VxrLlsm3eEtGuEcn380lbUBjy57/rZ2P0+vUx+Yc3AABAfzFYrUrMudDzuDFG5Y28yxrRHyG4YR0dHR3xnkS8Ne34bx298TpJ0lmfOMIcDQAAMPCF62+QtqBQmStXqt3p1Mk1qyPeiZCany9Lyc2eRfZ2p1OHS4q77UQwWCwau/H1Pl1Ebnc65d63T03VOzzPmbJzZMrJGVCL10OV225Xu8vl8/4n5+ZFFLSg77ntdrn32T1ljDp3puRE1egbAABgoKld9XM5Vz0hqbOXQSx2ENSu+rmkzn/D2HYFL+c5kDlP/Rtu9+7dMR972rRpkggSJBEkAACAoenkmtWeBsr+bJu3yGizqdXhkNFm6xYimLKzZbB0LgYn5XU2S07NL/BZIHatW6eTa1Z3Cx4MFotGr1vPgiUAAACAmGqxf6BD87/WJ2OnFMzVyF/9uk/G7mv9ESTQIwEAAGCIGr74Lk//A29pCwo9d+wHChG6disEEqhhqzdCBAAAAAB9JTHnIhkslqj6pkWKskahESQAAAAMYSOW3y9TTo5PmaOu3giSuu9EyMnxvN7udMr9UefW3hb7PjVUve2pLx+IKTtbo9Y+RVkhAAAAAH1m+I8eUqtjf8zHTcqbEfMxhxKCBAAAgCEurbBIRtt4Hb9vqVIKCjwL/YF6Irjtdjny50R9jfTFi2PaWBkAAAAAAjFfe328p3BGGjRBQqvjgFoPfB7vaQAAAAxKybm5Grvxdc/jSBorRyJtQaHS77qLXQgAAAAAMIQNmiCh4fVy1T7xaLynAQAAMGh5N0qWpNQ5+WrYXBV1fVGDxSJzYaGsJTcTIAAAAADod81/3anmnX9WQtYYma8pkhISoh6jadsf1bx7lxInnaPUr3+jD2Y5tAyaIAEAAACxY8rJUebKlcqU1FRdrabqHWqx29XqcMi9b5/vsdnZMtpsSszJUXJunpJzc+MzaQAAAABnPOeqJ1S76ueex65nntKoF19TQubIiMc48cB9qn9pvedx3YvrlPXS72I6z6FmWEdHR0e8JwEAAAAAAAAAQCjtx4/JkXdJt+et31mk9P+9PKIx3O/v0eHCq7s9n/HTFUq7saTXc4wH56mStbt374752NOmTZMkGWI+MgAAAAAAAAAAMeb+aF/g59/fE/kY+z4M/Pze93s0pzMFQQIAAAAAAAAAYMAzXZAd+PmLu+9SCDpG9oWBn59ycY/mdKYgSAAAAAAAAAAADHiGzJFKv/ten+cSzz1faf92R8RjmC6+ROZv3eTzXHLevwzaskb9hR4JAAAAAAAAAIBBo/mvO9W8889KyBoj8zVFUkJC1GM0bfujmnfvUuKkc5T69W/0wSz7T3/0SCBIAAAAAAAAAABgkKLZMgAAAAAAAAAAiCuCBAAAAAAAAAAAEBRBAgAAAAAAAAAACIogAQAAAAAAAAAABEWQAAAAAAAAAAAAgiJIAAAAAAAAAAAAQREkAAAAAAAAAACAoAgSAAAAAAAAAABAUAQJAAAAAAAAAAAgKIIEAAAAAAAAAAAQFEECAAAAAAAAAAAIiiABAAAAAAAAAAAERZAAAAAAAAAAAACCIkgAAAAAAAAAAABBESQAAAAAAAAAAICgCBIAAAAAAAAAAEBQBAkAAAAAAAAAACAoggQAAAAAAAAAABAUQQIAAAAAAAAAAAiKIAEAAAAAAAAAAARFkAAAAAAAAAAAAIIiSAAAAAAAAAAAAEERJAAAAAAAAAAAgKAIEgAAAAAAAAAAQFDGeE8gUi+/Wq6y9a/EexoAAAAAAAAAAAwYr774XJ9fgx0JAAAAAAAAAAAgqEGzIwEAhrL/dfKQLmuolaWtRYdNydqVkq7N1lHxnhYAAAAAAABAkAAA8fbLz9/zeXxWc4POam6Qy2BUdVpGnGYFAAAAAAAAdKK0EQDE0bzaQ0Ffu/HEfl3Q6OrH2QAAAAAAAADdESQAQByd11Qf8vWRbe5+mgkAAAAAAAAQGEECAMTRWS2NIV9PaW/rp5kAAAAAAAAAgREkAEAcfZGYEvL140ZTP80EAAAAAAAACIwgAQDi6L/NI4K+9kmSWbtSh/fjbAAAAAAAAIDuCBIAII46hgV+/khiklaPnty/kwEAAAAAAAACMMZ7AgBwprK2terbx/f7PFc5fIyOGZO0OzU9TrMCAAAAAAAAfBEkAECcfOfIpz6P/5CepSprVpxmAwAAAAAAAARGaSMAiIPCmi80vqXR89ienKb/Sh8TxxkBAAAAAAAAgRnnzb8+4AsLry/UzTfd0M/TAYCh78JGp65wHfM8bjAk6HcjxsdxRgAAAAAAAEBw7EgAgH6U0NGhhSccPs+9OsKmY0ZTnGYEAAAAAAAAhEaPBADoR8XHP1d6W4vn8SdJZs1yHdcs1/Fux27MGKf9ppT+nB4AAAAAAADQjfGtylfjPQcAOCN81XVM0xpqfZ47t7k+4LGvDx9LiAAAAAAAAIABgdJGANAPJrgb9I2agxEd+3FymrZYR/XxjAAAAAAAAIDIUNoIAPrBNTUH9c+k1KCve+9MeNua1R9TAgAAAAAAACJCkAAA/WD16MkBn5/jPKprTp7eqbDFMlIfJ6f117QAAAAAAACAsChtBABxMqalSVefPOx57DCl6O300XGcEQAAAAAAANAdQQIAxMm82iNKVLvn8WbLKDUYEuI4IwAAAAAAAKA7ShsBQB9KUIdMHe1K7OiQqb1NiR0dSupo18gWty5tOOk57s/mEaoxJmqCu1FNwwxqNhjkNhjUPMygdg2L41cAAAAAAACAMx1BAgD0UEJHh8a3NMrmbtKo1maltbcqra1NaW2tp/7eKlNHe/iBJH2l/oS+Un8i4GtOg1HHjaZTf5I8f3ckJatxGDsYAAAAAAAA0LcIEgAgQhPcjTqnuV5nuRs03t2oMS3N/XJda3urrO5WTXI3dHvtuNEkR2Ky9ptS5TClaF9ymtqGsYMBAAAAAAAAsUOQAABBTHA36Nymek1yN+icpnqltbfGe0rdZLa6ldnq1tRGp+e53anp+iDFqo+S01SbkBjH2QEAAAAAAGAoIEgAAC+WtlZNbazV1MZaZTfWxXs6PTKtoVbTGmolSfYUq95LsWpvilXOBH7lAwAAAAAAIHqsKgGApJwmly5pcGpq40mZ29riPZ2YyWl0KqfRqWuGJej91M5A4f1Uq9po4AwAAAAAAIAIESQAOGONaWnS1AanpjbW6ix3Y7yn06eSO9o0vb5G0+trdMxo0vup6dqbbNUnyeZ4Tw0AAAAAAAADHEECgDPO8LYWXeE6ptnOo/GeSlyMbHVrtvOoZjuP6jNTqv5oGam/mofHe1oAAAAAAAAYoAgSAJxRZjuP6grXMQ1va4n3VAaEie4GFR//XBc3ObXFMlKfm1LjPSUAAABg0Hir8tV4TwEAEGPz5l8f7ykMSAQJAM4I0xpqNdt1VGc3N8R7KgPSpfUndXF9rbZaR2mLNUsNBkO8pwQAAAAAAIABgiABwJB2dnODZruOalpDbbynMuAZ1aErnUc0tdGpzZZR2pGWEe8pAQAAAAAAYAAgSAAwZP2r67iurXHEexqDzuiWJn3rxH5NaXSqfMQ41SQkxntKAAAAAAAAiCOCBABDUmHNF7rCdSze0xjUpjbWyna4Sa+NGCd7siXe0wEAAAAAAECcUAQbwJAyorVFyw5+RIgQI5mtzfrukU91hetovKcCAAAAAACAOGFHAoAhY1pDrW459lm8pzEkFdYc1JiWZr0yYny8pwIAAAAAAIB+RpAAYEiYV3tIV9Ueifc0hrQZdSeU0erW01nnxHsqAAAAAAAA6EcECQAGvXiHCEdGjNO+s6ao3jJCH2SdJ3dyqo4lD1dtYppajYlqMyaqzt2u1raOoGMkGAzKTDdpzMhUZQ5rkrn2hCy1x5RWe1zWk0eUVntC1pojspw8JsvJo7LUxqd0U3ZTnebXHFJlxpi4XB8AAAAAAAD9jyABwKBW4DzSbyFCjSVT2y6ao49sOTpoHa0TycN1tC0x+AkdkloktbQFPSTJlKCxI1M1KiNZxoRhkqQmpakpOU3HR08IOZ8x+/+urC/+R6O++B+NdvxDY/d/pOR6Vw++sugUuI6oJjFR29Iy+/xaAAAAAAAAiD+CBACD1lfqTmj+yUN9Nv5Hky7RHy65WvtGTdYRo0WNbcN8DwieD4Q1wpqksSNTZE0z9XiMQ2edp0NnnefznLXmiMbs/1i2f9p1zr6dGvP5xz2fZAjXnXDIPcyganNGn4wPAAAAAACAgYMgAcCgdF5znW44cSDm474+8wZtO/df9GnqaDV5BwW9CA28ZWUka/wYs5ISE2IzoB9nRpacGVn6eOosbf3G7Uqtr9V5723XuR/8Wed+uENGd3PMrnXj8f1qNBj0fkp6zMYEAAAAAADAwEOQAGDQSejo0NUnD8dsvO2XztWGSxfof5JGnu5jEKPgQOrsfzBqRLLGjUrpswAhmAZzuvbMuFp7ZlwtY4tb59irdXH1H5S9+08xGf8bNQd1wJSqmoQQJZ4AAAAAAAAwqBEkABh0vl57WOc01/d6nBfmLdLbky5XbZuh84kQzZB7IsFg0NhRKRo7MtXT/yCeWhNN+njqLH08dZYyjjqUt/U1TX33TSW29HyXQlarW9+oOaiykaH7OQAAAABnshb7B2p8e1O8pxFUYs6FSrlyXrynAQAYwAgSAAwqUxqdynf2vLmyK9miZ6+6W++MvkQt7YrpzgNv40ebB0yAEEjNKJveuv7f9c68Es2oekmXvfP7HgcKlzWc1AFnijZbR8V4lgAAAMDQkJhzkWoe/omaq9+N91S6MVgsynppQ7ynAQAY4AgSAAwaSR3turq25yWN1l/5XZVPntMZILTHbl7e+roHQqzVWzNUVbRIO+b8f5r9+2c0ZefbGtYR/c6Mb5w8qE+SzfrMlNoHswQAAAAGv5G/+rUOfjVX7S5XvKfiY8Rjv1BizkXxngYAYIAb3EHCNQ/od7dNUVo057hb5G6p16HPPtL2t8tVVvVpbMeXpLYWuVvcqj/m0Ce73tELz2zSP6IdQ5I0SdOvm6NvfPlS5ZyTIVNiokxea5Pupnqd2P+p9rxbqd+/tivya0T7dXnes0+1Z0elNpTv1aGor1Ov3c/dovtej/Sip3z/Sb1VYDv1INoxJmlu8XzNnna+zj0rQ2nJXjXc21rkburj74MQPq+6Xnf8MsiLY6fo2vnzNevSSTprpLn7vOtrtP+fH6t6a2XoeQ9BBc4jsrkboz5ve85X9fRXv6OT7cY+CxCs5kSdPc4ic8rg/LXqGj5Svy9err98tVDzf/uoRh78Z9RjXO46rs8yCRIAAACAQAxWq0b+6jc6cuM3Pc/1d0mh5j+/67Mrwnr3PZQ0AgBEZHCuePWGKVEm03BNuDBPEy7M07XX7tCzD/1clQdjeI2ERJkSEmUaf76mjz9f0+fM09Z1pXr0jUjLsWRp9m3fVcncKRqTHPwoU7JZY86bojHnTdHchUe0+81X9IvntkW2yB8Nz3t2qSZceKnmX+/Q1hdX6dHKgbqIPUnz7/muvjVzkjJMQQ5JSJTJ7PV9cMNeVZb9Ss/+qeclc3ovS/PvWaaSf7UpLdjN7AmJMlmzNHlqliZPnTVA5t0/zm5uUEFt9F/nTxeu1E7rOX0WICSZEnT2WItGpAf7ZhtcvpiYo/+8/wVdUfmcZm76bVTnTq+v0V/MGdqXHMvYDQAAABg6kvJmyHr3PXKuekKS1GL/UBk/ekhJeTP6/Not9g9U98JznscpBXOVfve9fX5dAMDQYIj3BOLNND5Pix5/QNeODX9s3UGHPv8s3J8jqmtq8T3RbNPsW5dpSW4EExo7V0vXPKql1/iFCG0tcjuPnL7OsXq5vWu7m7I07Zq79czzyyL6WnrFbNPsO36mZ75/aR9fqAfOK9LDv/mZFs32CxHcLao7cvpzOuT0/YxMWVN07T0/05O3xOtrulSLfvmoFs0OESIE0DXvlUVZfTe1AaLAdSSqX1jHho/RTd95sTNE6CNjRqZq6nkjhkyI4O3/zb9NLy1+XE0p0YUCl7uO9dGMAAAAgKEh/e57lZR7Ojg49r1/U+uB/X16zXanU8d/uETtTqekzp0QIx77RZ9eEwAwtAyhHQmRlb2ZnDtXswrmaX6u14KtdYpuuHO+Nvy4MuT4n/zXkojL6oyZOl+3L16omWNPlaUx2TT3lu9qa/WvtDvYSWPna+WjN2lahvdlHdr+RqVeWrclQOmiLE0rWqg7r5+lCeZTl8m6VLc//oBMDz6kl/8eyUzDvW+TNH32+brwoss0c8almmDtej5REwp+oGfaSnXHmr2RXKjv5d6kJ78/XznW00/VHdylra++orWBSgCNnaWSW67V/Bm2zrJFCcOVU3S3VtYu1X3lXne+v/6Qvhnmc1/y9KuaO/7Ug/q9enbhQ4qmVdX0e27V/HPMp59oq9fnu7dp6x/3yr5vh3af2jEzOXeWcqddrlmzpmhyxqnvrYThmnbjMi35nyV6Mug31+A2qtWtixucER//3jmX6eG596mxjxopD/YyRpH6NPvLeuEHT+nbv1yiNOfxiM6Z0ujUmJYmHUoMsZ0KAAAAOMN590todzp17Hu3akzlH/rseieWLlGL/QNJnc2VMx/7hQxWa5izAAA47YzbkfCP6k0qW7FEi5/Yps/dp59Pu3iWFsXwTv5D71Xq4Tse13bvSizjL9O1s4OdcamWPLDQJ0So+bBSP164RA8HDBEk6Yh2l6/SHQuXquyvJ+X5cqxTVPLjZZrb+y9D0qfauXWTytaU6o4bl2rtu0dOX0eJmjD7Vi2ZFpML9dIcPbzYO0Ro0edbV2nxHaWBQwRJOrit83vhN3tV53nSrGk33qvb+3pXh48ifWuG144C516V/e9bdMeDz+vlradDBEn6R/U2vfxMqRYVL9Gz1V6fucmm2TcU9eek+9WUxshDhPcnXaaffK3vQoTxo826aHLGkA8RuhwfPUHrlqxSU2rkOxOmNZzswxkBAAAAg5/BalXWS6dvP2uxf6CTP/tJn1yrdtXP1fj2W57HNFcGAPTEmbESFsChP63ShjlTtORLwzufSJikC78u6bmQp0Vplx5+91O9dc2kU4+Ha/RUSVu7Hznt+8WaO/50U92699Zryf2VEfY7+FQvP/gjuR95VLdPPXVXe8aluvnHc7Tp4S29+xL8rlO54iGZvK9jsmn2txfq5d2vxL43QxSmLy3SdE8I06LPqx7XHb/cFdG5h8of0qNnr9HDs08t5psmac535ujZB2P53oVw42Wa7Ll5u167X41kN8kRbXj4aZ37zDLNPhV6mC7I06Kx5Voby34fA8TU+sgWpo8NH6MH5t6nlj7oh5BkStAFE9PPmADBW80om/7Pd1eq5InFER1/QWOd3krv40kBAAAAg1xizkUafv+DOvnIg5Ik1wvPKSlvRkybHze+/ZanH4N0hjZXPrJJ99z6vOxKVM4dT+qJ+aFKAx9R5Q8W66mPpPkPv6o7Q904+eF6fXNppeolnXXLk3qmyBbRuJJkmn2vXrsnT6GL5LZo+xM362dbO0sz59yxxmvuvuNF5OoH9Ob3pkRxgiSd1NYHF+mxumL95vG5GhPkKPtzt+ie1+sl2XTb00/q2vFBDgxgz9PX6743opyW5mpl5a26xP/pmk+1tapSm97eK/vBUzdfmswaM/F8XbFgob4xc5Iyoign3Wmvnpr/kELVMPHn+d75aL2+9YN3NOvhJ3XnNHPY885Ehw4f0YkTNT0+f8SIDI0ZPfTLfQ8UZ96KmJdNuw7o9i8NV9d9tubMKZJiXKbnL0d06JpJnl+2I0bOlbTJ76Ailczy+j+cIzv0aMQhguckbbh/lS58fplmnvr5yfjSXC0auyXGC8tHtOH+9Zq27ruehXvTBXm6YewrejJeC9hjb9LNuV6/NI78Tc9GGCJ02flEuXZOO/01ZVw0Rzdoi16O4TSDGmk+/R8PTQ7ZIyyfJe3So3/8WDMXnt95fsJ4nTtH0ot9MMc4S2tvjei4H97wuFr6YCdCVkayJo6zyJgwLPaDDxIHzpmi8n97UEW/fjDssZF+XgAAAMCZznLL7Wre8a4aqzrXCU4sXaLRORfJOP6sXo/dYv9AJ5Yu8TymuXKL7C+sUuWXf6b5va5C0KLtb72leiXKZGrR/g1bZL/mJuVEuEjt3r5DO+/M08xQFWGb/qbtW1tCHND3Dr3xuH7x1yyVrAkeIqhphyrfrJdMiTK5HXr5rY917W3n9+c0pbZ67XnlIT3wyqenKjckypyVpREJkuprdOjvu/TKf+zSK6sn6dr7lum2rpuK+9oFC7X06i267z/Wa/oz39V0soRuxozO0k9/9pj++c/Poz737LMn6OnVj/fBrBDMGR0k6PUjOnGbPEFCmnWSYh4kTDTLuyBIXU33Be4xd+Qpx/N/Hi2yv/1z7ezRxXbp4bc/1u9v7FpYnqRZt83S2oe39Wi04LZo7ba5emF+104Lm3Kuz5J+eSTkWX1lzPWXabJnJb5F9i09ef+2aMMHRZqea9ahzz7VP/btkn2spP4OR5LNGhHNdV88oEMLz9cEd4vc7ZJpiJa4TGsPnw68PvMGHWmLbdPjBINBk2xpGpVBvX9Jsl92hT766yxdsCf075RIPi8AAAAAnUY89gsdnn+lWh0HYtYvgebKQbg/1nO/2KTpK+ZqTNR3pnvpWuS3ztXcaZtU+ae3VFm9UDkzEsOeajIlyu3eoe27WjQzxPHuv+wIVNCiG9+dCjFUs01PPf+xNPteFU0Mfpj7Lzu01S2Zr56j3Dc2aeubb2n7t88PHZJ4ueR7r+rN7/k/e3oXQNidIarXnmeW6L43TkqmLM28+W4tmnu+MryXB2o+VuUzq/Tctk+14cFF+uR7T2rl1ZG+Z1N0Z+WrujPkFD7VKw/9SGUftsh04a0qurjrhURdsvBWTa9apUfXzdJL35sSZhfKmalowf/SE794qkfnoX+dcT0SfBRlaYTXw7rjO2J+iWtzJ3kFCfU69A//xfYs3XDppNMPmz7V7ld6ccFXtmiP146gjPMuV9C2DL1w6Jm9+ofXWuGEc2LTkSF6Wboh22s3R9On2t3DO/J3P7pY8669RTff85AefqbSpzdBn/pnjVePBptmLp4fPOnv5le6Y/71mnftjfrGdTdq0dN9McH4S41gYbryothuz00wGHTR5OGECH72/MvXwx4TyecFAAAAoJPBatXIX/3a8zgW/RJorhxIokwmyf3h83rs//buRsiabZu0VZJpVp5KZs2SSS3a+sY7iqRAy8yZeZ3Hb/ubVw9Kf/XaXrVN0izN/tdeTbXH7Bue1063TcXXhyrBdFJbN22TlKg5MxZq5uxEyb1Nldv6r2/eoTdK9cAbJyXT+bpzzRr9aL5fiCBJGedr/tI1+s87zpdJLdrzdKle+SxGE2g7ospTIYJGztVDD/iFVBmzdMNVZtW/8bzKY3XNIebK/Ct09tkTojrn7LMn6Mr8K/poRgjmjA4S5k4dH2aRv3cmL3xAN0z12rdU87G2ditbM0cTRno9/OIjlfXqqlu0e3/96YcZNuX2SePgTfrc++0aOUnz++IyYfm9f8cOdCscNeC9vk12r//aSJt6k9asuVclc6dEESjgkFJiNlZqilGX5WSekf0Qwvn7RTPiPQUAAABgyOnql9DF9cJzqt/wao/GorlyMHP070tmySTJ/twqbejxzYMObdm4V1Ki5s6YIvOleZppkrS7UlsOhD87LffU8X/aoZ1NQQ6q2aFNf5X0r3mamRbkmL5Us0Vlr9dL0+ZrTqh+Bwfe0YbdkkxzNPNis6bP6Awd9mx8R/v7Y55NO7Tu+Y/lVqJmL1kWtmTVmPnL9MN/TZTkUNlzWyIKfkKr155nfqSnPmzpDDJW3KpLApQvyplXpLPk0MsbdoQIj85s0e4uYDdCfJyxQcKYogd0u3dNtCaH9kRcmz7EuFPzNPu6W/Xwmt9o7Y1TfIKK3Ruf777IPc0m7xuea4592us5bDjinfyaldEn635H9MlRr8DCmqFz++Iy4fi9f3UnHHFt+twzW7R2416vXQlS2sQ83bD4Ab2w4Td6ec0D+vEdRZqdOynoCGe6Xed/JWZjZWUk66JzMs7ofgjhnMiKonMWAAAAgIhYbrld5qLrPI9PPvITz66CSNFcObQRs249tZD8sZ77eaUO9WQz9YG/adNnkqzzNPtiScl5mn+VWVJnf4Cw0i7TzJmJkrZp+18C90Co+es27VGiZs+6TPHIEfZvrdQeSdPn5Ckj1HHVW7Rfkvmqy3VJgmTKnaf5VkmflWvTh30/z66ySrLO0/wZkTQgMGvm9dd23rS5e4u29fJ+4vptz3fuhlCicm69O3iQMf4yzRkrubdu0tbepxdDUjS7EtiNED9n1u22512q2dMu05wZebrkvOFeW7Na9PkfXwnTWNesabe9qrdu68F13Se187VS/bg8wG8ovx4KLmcM+hn8s0Z1sp0a16wRve/RNHD5vX8njlTGbSq9caj8IS01LdPPrrvUdwueyayMiVM0c+IUzZy/UEvbWlR3/FPZd+3Vtj9t0ab34tOXYqA5nj4qJuNkZSRr8lln+nbf8OqsmRpxJIJbbQAAAABEZfiPHpLb/oFa7B96+hxkvfi7iMoS0Vw5EmbNvPNuzf7zz7X1o/V64LXL9MxCW/jTvNjfKu9cPC/I8zRXzrl8jsyvV6o+ov4AiZo5Z45MWzdp67t/07/P8i8ddFLVf9wrmWZp5qWJ0u6ophcDDm1/yyHpfE2/KMTifNvH2rTBIcmseZefaq6ccL5mFpi1obxelW/tUPGFocoi9Z79w1MlynOnRNzoWhOnaKZV2uD8WPaPWzQ/K3xfi4AObtKPn9wmt6SMq5fp4ZA9F2y6ZIZZKt+r7bvrNahaL8IAACAASURBVHc2XZcDibRXArsR4mcIBQk9X+h3f/aOnl0T4ybLkuSu1+fvb9OGF5/Xpr8HOWaUOS7pMgaef7xSqhv+OkeLbpyv2dNsSgv0f4IJiUrLOl/T556v6XOLtOjYp9peuV5l5XsH4U6MWOr97gFChMh1DGO3BgAAANAXDFarMh/7hY5861q1u1yd/RIe+YlGPPpkyPNorhwFc54WLZ+j6ge3aP+Lj+uVGU9qYYhmwj6adqjyzXpJNt1w5fmnn79gjm6YWKnnPtumym3FmlkwPOgQkqSL8zTXtEmVf9qhnXfl+QYPR3Zo027JdPUczUyW9oSZkv2ZxbrqmXATn6uVlbfqknCHSdKxvao+KMk0SRNCrI27q99SpVPSxCLNveD08zlXFums8vXav3WTtt6Sp7mhtjT0ykl9/o/OHR2Tz44mDBqu0WMlOaVDNTWSetCoun6vnlr+vOxuyXThrXrijikKFw1MPu9SSdu08y975Z7dtwHLYHVl/hUq3/h/9c9/fh70GHYjxNcZW9qoU4sOvVephxf/SjsjOLruoEOff+b/54jq/AqcuQ/uUNnDnY1773gwRIggSWZ+dcDL37do7YNL9M0FS/XjdZu080OHauoDb3WUJNPISZp9ywNasybEFjqERYgAAAAAYKBIzLlIw3/0kOdx/YZXw/ZLoLlydMxfuklLCzrLEZX9R7n2R1jiyL1rh7a7JV0wTzN9Kr7aNGfBFEkR9gdImKKZBYHLGx3a8Y7sMmv+V6dENqlYO3BAdkk6d7yCF5pp0c53O+v958zNk08hjPGX69ppkrRXG7Y6+nCibunU52bq4eqm/UAPqjy0HVHlQ6WqPKbAzZWDME2epMmStPtj/SP6q54xwu02YDdCfA2hHQmRcTe1yO08oE8+2KWtla+EXuT3Ua9P/muJ7gvYR2GS5t9zt0pmd5YTMo3NU8k9WRrxxFKtrQ4zrE8ZIvSWKSFL0lAo9/Opdr72vHa+durh2CmaOStPc6ZN0YWTs5Rh9t16lzZxlm5/wK1D34ssFMNphAgAAAAABhrztderecd/q7688x+FJx/5iUwXXhSwaTLNlXvCrOm33a251aXa9NkrWrpuil665fww55zU1jc6S9lcMi+vs86+l4wvzdIl2qs9n5Vr04fzdduFoUe75KvzZH6j0q+8kUPbN30sWedr5gWhz++Sc8caPTG/B3fVB3Fo/6nenWfbgvdHqHlHlVtbJE3R3Fn+1x6u3K9OkXbv1f4NW2S/5qbIyw71s5zx0b5vkTVXDijR1PkZO+tV1yZpgL4n8RZqVwK7EeJvCAUJ9dr93C1BFvr72qeqfGKJDrU9qR8X2Dp/MZgnaf7SJ2V6dImeDBUmOFvknT2bkqdI6mWZpbMyfJo8nwgbhffMiDSv35Ztbp9mwQH1+pdki1qcfk+9fkQnbpPn603LzJM0OPskhHRwr7a/tlfbTwULY6bO0bVFviWQTOPnaNHSHbr50V3xm+cgk5pi1MRxlnhPAwAAAAC6iaRfAs2Ve8F8qW6/Z462PbhFNeWP67l/eUa3hVq8P/CONpzqV7Dnl/8/e3ceZddZ3vn+u+cz16iSZMkTnrARtgyWFdpOQIIsGW4rBDt4metgkmVDYuI2C7oTQhrSfTF9wZ0EBxo6tGNuQoiBRWIHUveCTXJtBvuCbYJlR8HYeMCWZUkl1XTmvffZe98/9qlSqVSnBqkmSb/PWme56ux93vc9g8pV77Of53kfb/1MpxPn2R/ggq1cVRrknu8/wMO/s5VtJSYbOeffvnXVbr7D4WbMsJs/v+FaOhbRKt/H4KPXceEbjrEPwawGOON8B54Oeer5vcy/RNEYB/alX63rWVjdpf2Dn2w3V+5m58c+srDKEP0bOBd4ipfZP7yA5Z6COvVKUDbCyjvFSxstrsc+80m+9GTt8B3uBnZ84I+5ZrYHPfgC+5uHv+1dc/ypa9esn1qLr8boD497yBlcyRlTf96Wx3h21vMXo+lzjZEHp9/3AiNTgguFNWcfdVXAyWj/k2kJpFs+/RAvTSmtte7SnbN/3k4wr2mWeWN1eEnGzmVtXvOqHmxL9f6XwrbyQTY1pkf+RERERERkvib6JZjF9OKn6c2U1Vz5+OVf/24+9rZuYIx7PvVlnpqlxNGeRx9gD+CWBli3vsNtII8LBA/ez4Ojc0xunc8V2/LA4zz4L+le0p6H7mfP1ObFq9JeHn1gL+CQH5jltSg5QMiD3/oBc70Ux+rCi7amXzy6e9b37ggv7ubhMsD5XHj+/AMcwZNf5EN3PkOAw4Xv+wTv36yGyUvlV9/8Js4668jCWspGWB1OooyE1WCIez53L1v+9N1snrhAoLSJd922k3s+1ukq+Qd49pWrufBV6XfumZt4F/DVY17DlWw+fcoPs9G9aZOcxbZ+E2unBBKCoRc4ao9/WrbAsZQdumZgjgZF3M9T+25gc6n9w39gAzuBv1zQLBPezef/7irWll/m2Wee4bFvD3LPk0tcJunm2/nH7RvBdHDjZ/jqOz/Klxbw8P3f/yz/8w3n86mJVML8AOeuB5biPV9GfS2fXx/dz8WN8SUZ3zJNzt1YUhBhCf36WPohfDpb4O97NjJkqx+MiIiIiMhCTfRLmAgYNP7pPvxHfoi39Q2Mf+bP1Fz5uOW55IZb2fnoxxk8NMhtXxzg12Y6LXqG++9JN893/P7neP/mDsNFz3DXDR/lnnLaH2DH1bM3Ab7wl7eT/+Ygj33vcWrbzubhB4Zg/XVHNC9edX76AF99EXC387E7b+SSTpkTP/0yv/HhQWq7Bnng5e1cs7HDecfBvWwr29yHeLB8H1/9/k4+vm2uPaQaj31jkP0Am7dzVFWmjg/bzV133M8o0PO2j3DbsZSSOrS3fQHuRtb1Lfzhp5rpWQnKRlgdlJGw2PYN8uf37D6izE9h805ue0unBwxxz7+9cPjbzNlcedNx5De9fTsXTtngH33+kaM3+BfB5t/cdETTnT0/+9oMZ41Rm5JtkZYdWpgzuqYERWqjzNS3/Us/e/nwN9bZbH7fsb1+6963iXMyDoWBs9l85Q52vnUZ8sxCcDMOrgtkBji34+eks10/G5ryecvTc/niLW+lvG1saMmCCABnbyiQzyqOuhwuaFTZMXZgpZchIiIiInLCyl9zLd7lbzjq/okgAkDXrf9RzZWPVX4T7/nADnqA0cG/4asvHH1K8Oh9DJaB0lVse+0sY1nns+OaNHiw554H5r5K/oKtXFUC/uUHPLrrEe7fB+u2T2tevMzWnX52+sVze9MN9yOEPHzffdSA/Ft/uXMQAeCi7bzrTIC9fPW+Z5ZgpUBmKzfceD4uIY997k+55+XZT98/+Ek+8c81YAPvuWl75x4QU01pruxedCOfft8mjikXoVZLMzNK+ckS1dLZ1KwEZSOsHgokLIH9936Bwaendj7oZsu1t7Kl0/l3PsSuyYpIDuds+91jLE9zKR/+3zYd7o8Q7eXRbzxwTCPNbjvXvHbKJnv0Arvumum83UeWHTp9EzsWNM91nLF2yreHhrhnptPueoSnpgQsztn67o6vdWeX8t6tZ0/5foin7j/OXhXz8eOhKf9j7ubCbTsXPkbBnVJ3scboXA2+V7lXNytcVl+qxEfoLXms6cks2fhytMvqo1zUqKz0MkRERERETlpmqWull3BCy2++jg+/rRsICYLpR0Me++EjBEB+29y9C06/fHsaCCjfx+Cj4ewncz5XvCUtb/T5PxlkPxv491fOnsWw5DZu5EKAF17mqEvCmj/h4YdDIM9V/26u8ksbuHx7+lxq376Ph5tznH6M1r3tI3z8bd0QPMNdH7iFTww+w+j0AM7oCzx454f5ncnSRB/hujPnM/qU5sr9O/j4H+9g3TEGAYI9L7czIc7nnGMb4pQzkYWgbITVQ5fkLokhvvS3P+CKj23njIkd3vVb+a2bBnjsrplK5Qzy5/98JXe+/ex0Q7i0iXf9t6vZ9Z/v5bl5zznANf/tVrZNafQy+i+D3LHrOJ5Gx3nezZapWQ+77u9QSmg3D/1ijCsmyhP1bOLXbhrg/hlfg6Nt+dCVXDhlv3f/iw91OPNevvLj7dw2kZM28Dre+4FLeewz8286vOUDN7BlSmwkePohvrTor90Mdt3PU/u2sq79vhUuvppPXf0If3jvfEsqbeKDV55/OJAwupddJ3hZo7P82twnHSPLNDnndF2lsxIuaFb4aVaNrUVEREREZDWaWuJo2qHRHzD4YHvzfD69Czb+Mtds/jJ/vivtD/DeN8x+5fuF23ey7t6vsb9cgzOv5vIFlgB66s5beOud8zlzB58avJFL5jqtfxNXnAlPvfg4T70Il0zZcB996H4eDIDSdq64aO4ZT9+2k0v+6gs8ETzE4EM3cMVb5io9dCzyXHLzHXxu7Z/xob/azcN3fpSH73TID/RQtIDaKPvL7YBO5myu+cOPcNPr57uOF3j4W2Ppl4fu5w+vu39ej7rwfZ/j09PKHz3383SPastlm2Zvwi2TfvXNb+Leb/zfykZYRZSRsFR2fYG/fHTqZrDDOTtu5T0dOrrvv+vLPPji4Uh14eLruP1P331EYKCzs3nXf/0E77l4SnJVeTd/f9tiZyOczc4/+uMj52k+w33/q/M8Dw7unnLFvcM5b/0Et113dsfzJ5xz3Uf40BVTd/Zf4OG/7Zwh8Njt9/LY5EXsDme85VY+f/OV82q8vOW3P8GH37Lh8A/yYC8P/u3XZkjhWwq7+dL3nuHwBQ95Nt/wCe64aT5rP5t3/ddb2Tbll4z9/3Yf8/vf2up1XnPpAglnbyioL8IK2Rg0VnoJIiIiIiIineU3cdMHdxy16b//oQd4AuDMq+fZu6CbbTuuTL/cNcgDc5Tb4cyt7Gjv/Vy4Y2XLGqUmMgmGePSIvpFDPHRfui9z+jXb06yFufT8Mjt/Jf3yiW/8gD2LvNLD8pxz9R/zzbvv4A9uuJJL1ucJh4bYv2+I/UGedRdfyXt+/3a+8rXbFxBEWEzP8PA/14BL2fZ6NWleiPfd+J6VXoJMoYyEJfTY7fez6+IpjZcz57Pz/Tv50oyNl3dzx3/7Gwr/xw1csT5tHFy4YCcfvuN1XPmtQb7yNw/MkJ0wwOarr+P9117JGVN/DtVeYPAzH5+5DNBCrd/EFa8+n81vfB1bXn0+6474eVdj11c/y5dmuwJ+12cZ3HUp753oZu92s+X62/n7N+7m4Qce4KFdD/HYz9ND6y7eypbNW7niDZeyeePUiUJe+v7X+MtZr7R/gI997nzu/PBEFkiec952K3detp37v/plPv/PRxc5XHfxTt51/U62XdR9RGmgXXd/cgkyOTrbf/dn+dJFt/PeiQCN1c2Fb7+Vv952Dbv+5REefvxpfvrg4+33/2y2bLuUy9+4lStfczZHVOgp72bw9vlnYZxqSnlHJY1ERERERERONQM7+PTg/AotuxffyFcGbzzivnU7P8G3F1iF2L3yVr595a1TF8HOP/06Mw+zgevu/DrXdRjrkpu/zrdvnn7vbOMdv8lMgvsfYc/One3gxrHM6XDF73+db//+QlewifcPfp33L/RhpQ1se+etbHvnQh+4yOuY7qePcF8Z3G3buUJFEhbk0s2zNSWR5aZAwpIa5M+/tZU7rztceqaweQcfu3yQ22aqY7/vfm77LzV+7/dvZOd57U3l/AaueOfvcsXVN1IdHWJk4mLtfDfrevK402qzBUOP89VPfZKv/ny+a8yz+aavc99NC31uNZ6697PzKsFzz8c+yxmf+0/sONOZvK+wcRM7btjEjhtuneWRACGjj36NP55PmaJHv8Aff8bl4x+4crKklDuwiZ0fuJ2dN4dUx4YYaQA49K7toZBxjnx8NMZT3/yLBZQVWixD3POfP8u6z9zKzldNCaCUNrB529Vs3gZ8aI4hys9wz2IFj05Sp69V1F9ERERERERkTj3bec/bv8yHvjnI/U/v5KZ5ZWLIzCYaVG/gpmu3qqyRnNBU2miJ7b/7sww+P7W5zgBX/PbvsrnTA/Y9xOc/9Nt87O5HeGlqhRfLodC/gTPObN/6pwURmkPsGvwCH7xxIUGEYxMM7eaeP/kwH/yr+V79/jh33PJRPv/gXqrTG97MPhG77v1T3nXb4LzLDO3//md53y1f5MEXp5XHcR0KAxOv38BRQYRgaDf3fPqjC3hOi+1xPv+BD3P7N3ez/6jGTrMJ2f/kILf/p4/ylyd4k+WlVMo7lAr637WIiIiIiIjIfFx4zY1scccY/H8eYUHbFHKkdo+N/NtuZOcC+1+IrDbKSFhyQ/zl3T/hio9tPVzzfuMv896b7uX3Zmk6/NjX/ozHvjbA5qt3cs3WTZx75gD5jHM4eBCFBGHAyPPP8Ngjg9xz7+6lq+kfhFTLQxx45QUefXCQL81QJmhuLzD46Q8y+NVNXLNzJ1deejan9+eP3tBv1qgd2stPf/hAh3JO87Dvfm6/5X5uP28779l5JZe/5mxOL7m4U+eKQoJmjf3P7ebhY35Oi22IB+/6OA/edTZb3rmdX7tshvcdJt+PPT9/hPv+7mvcv8SBo+V20PE4d5EbLisbYeWNWQrkiIiIiIiInDB6ruT9N97H7/zF17j3mq1cd+bcD5HpQp742pd5wr2Sj96gJsty4juxAwnf/Di/8c0TYPxH/4zfOqbCdUPsuveL7Lp3EdYw1VK/brPZt5t77ty9PCV4fv4AX/r0A3xpGaa64+ZruWPRRnuBx/7uizz2d4s24AnleTfPGxhZtPFyWVvZCKvA85ncSi9BREREROSk0Hp5D97WN6z0MuQUsO5tt3LT9z7IXf/zft50+47DF8jK/Lw4yOe/5bDzthu5Qtc3ykngxA4kiMhJ54lcF/9+fD9dUTj3yfNwWr82sFfafsfjkXzvSi9DREREROSkMPLhD9L45/uJK+WVXoqc9AbYefvdS9bU+aR35tXcOXj1Sq9CZNGoR4KIrCq+afJX/YuXM9lT8hZtLDk2f9V/Ji3DWOlliIiIiIicsLK/ugOzWJz8vvFP9xE+9W8ruCIRETnVKJAgIqvOC16OPzz9NTxYWsMvvGPPKOgtediWNrBXwh43y/cKfXxsw0XsdzIrvRwRERERkRNa8bffy/rvPUr+6neu9FJEROQUpUCCiKxKDcPiG93ruWPtucc8hnojrJw/XXce9/ZuoGypgp6IiIiIyGIwSyV6//ufs27wO3iXq0eCiIgsLwUSROSEZ8bRjPeX8s4yr0RERERERGRpORe+hoGv/D29t9+BvWHjSi9HREROEQokiMgJ7/Kf/2jG+/NZXQ2/FLI1NXUTEREREVlp+WuuZe3gP1G69UOYpdJKL0dERE5y2mUTkRNeoTxMxjFphvHkfcpGWDp9Q3tWegkiIiIiIkJa7qjr1v+40ssQEZFTgDISROSkcEXl2SO+z7jWCq3k5HbaSz/DaoUrvQwREREREREREVlGCiSIyEnhff9wO/nM4R9prgIJS+IN3/nKSi9BRERERERERESWmQIJInJSyFdGueUnd2OZ+rG2VM547klevev7K70MERERERERERFZZtpxE5GTxi8/9A9cP/QwuaxNPqMeCYspWytz9V3/ZaWXISIiIiIiIiIiK0CBBBFZ9YYcb97nXnvvHXzk4S+wMRxdwhWdWvr3v8j//vn/RL4yv9c0NIwlXpGIiIiIiIiIiCwn+6qd18544Lpr38Fvvftdy7wcEZGjDdkeA6E/7/Mv/fF3uPTH3+GJN7yNR7a/k4Prz17C1Z28crVxrrjvy1z+4N8v6HEHFhD4ERERERERERGR1c9e6QWIiMzlkO0e0+Mu+eG3uOSH32Lv2a/hx7/y6+ze8quLvLKTU9+BPWz53j28/vvfOKbHD9kKJIiIiIiIiIiInEwUSBCRVe8XXg4qx/74DS/8Gxte+Dd2fP0zPPGGt/GTK3+NkYGNi7fAk0CuNs5F//IAr33kO5z24lPHNZYyEkRERERERERETi72fYNfX+k1iIjM6olcNwft/axpBcc1TqZRZesDX2frA19naMM5PHvRL/Hcay7n5VdtIjatRVrticMOA8771/+PTY/9E+f+248w42hRxn0qW1qUcUREREREREREZHVQRoKIrHox8ES2m7dUhhZtzIG9zzGw9zn+3T/djZ/J84sLXscvzr+UX5z/Og6tP2vR5lltMvUqZ/58F+fu/iEXPf4gbrO+qOMftF1edHOLOqaIiIiIiIiIiKwsBRJE5ITwk3wXv1QboRC3Fn1sr1njgid+wAVP/ACARr7ELy54HS+dczEvv+q17D/9vEWfc7nky6Os2/MMZz3zE876+eOse+mZJZ3vp5niko4vIiIiIrKaXLXz2pVegoiIyLJQIEFETgh73Sz/0HMa7x5+acnnytbKXPiT73LhT74LQMv1ePms17DnnNfyylkXMjxwOqNrNiz5OhYiVx2j5+Ar9A3tmcy2WP/yM2Rqx9FcYoGe9/L8Y8/6ZZtPRERERERERESWhwIJInLC+HG+m1Lc4u2jryzrvHbgp1f0P/OTI+4v9www1reesb51jPemt3LvAGO96xY10OCEPsWxg5RGhyiNtv87doCu4QN0jRyg78DSB1fm46/7z6BlmCu9DBERERERERERWWQKJIjICeWBYj+vOB43D72w0ktpb+wPccazT8x4vFbqZbxnLc1cgdDN0HI8AjdD5LgEXobIcrBaLezQx2k1scIQJ/RxAh878MnVximNDS1rVsGx+szacxi3nJVehoiIiIiIiIiILAEFEkTkhPOzTJGPn/ZqfmP0FS5qlFd6OR3lyyPkyyMrvYwl9ZKb5a/7z2TYdld6KSIiIiIiIiIiskQUSBCRE9Kw7fK/1pzFL1VHeENthLP8+kov6ZQSGgbfLa7hvq61tAxjpZcjIiIiIiIiIiJLSIEEETmh/ajQy48KvVxWG+OXqiOc51dXekknvR/le/lesZ9X3MxKL0VERERERERERJaBAgkiclL4cb6bH+e72Vwf55eqI1zYXP19BU40T2VLfLfYz88yhZVeioiIiIiIiIiILCMFEkTkpLIr18WuXBcXNcpcUi9zSX2cbBKt9LJOaC+6OX5Q7OOxfM9KL0VERERERERERFaAAgkiclL6abbET7MlvtW9lkvq41xSH+dcv7bSyzphjNou/5op8q+5Lp5RBoKIiIiIiIiIyClNgQQROamNWw7fL/bz/WI/5/q1yaBCVxSu9NJWnQiDJ3Mldme7eDJXIjDMlV6SiIiIiIiIiIisAgokiMgp41kvz7NefkqWQpnzmlWcJF7ppa2o5708/5rr4slskUO2t9LLERERERERERGRVUaBBBE55TQMix/le/lRvpdC3OLcZo1z/Srn+DVOC5orvbwlFxkGu7Mlfu7lec4r8IqbWekliYiIiIiIiIjIKqZAgoic0qqmPdmgGWBNy+eCRpULmhXO8evk49YKr/D4hYbJS26Wl9wcP8sW+XkmT4Sx0ssSEREREREREZEThAIJIrKq/UrlEAOhP+d5e9wsjxR6j3u+g7bHwaLHQ8U+AM4K6pzfDiysC30Kqzyw0DQsDjgeL7tZXvKyvOjm2OcsXsZBJo55S2WITBTNee53utdSNvW/GRERERERERGRE512eERk1eptBVwz+sq8zn0uk1+UQMJ0v3Bz/MLN8Z2uAQAKcYt1gc+6sMn6VpN1QZNSFNIdtXCXqddCzbQpWxZjtsd+x2PIbt8cj7K1tD/W31Q5yK+OD83r3F35bsqe/jcjIiIiIiIiInKi0w6PiKxavVG40ks4StW0eTZj82wmf9SxUtyiuxXS1QrojkI218c5168d81zPenmezHVRNW0qls2Y5TBuO/iGeTxPQUREREREREREZEEUSBCRVae3FbC1NsrltdF5P+acZo0bD73I94r9POsdvcm/HMqmTdm1wc0CsLk+ftxjfq/Yf9xjLIZz/RpbayNcXp3/e3L98B4ezffwvWI/ddNawtWJiIiIiIiIiMhSUiBBRFaNXBzxxsohrho/cEyPv7g+zsX1cV52svxD72krFlA4mfS2Aq4f3nNMmRW9rYCrxg9w1fgB7utay7e71i7BCkVEREREREREZKkpkCAiq8K5fo3rh/fQ2wqOe6yNYYP/cOA5vlvs5x96TluE1Z2a3toOAiyGq8YPcHltlC+uOZOXneyijCkiIiIiIiIiIstDgQQRWXGXV0e5fmTPoo/7psohzm3W+PzaVy1paZ2+VkB/GNAf+fSHPv1RSH/os+Y4gyJnBg3+aN/TjFguI7bLiO0wZHvsdzIMOd4irX5m14/sWVAZo/nobQX83oHn+WrvRp7MdS3q2CIiIiIiIiIisnQUSBCRFfWmyiHeMfrKko2/MWzweweeX9RgwoWNCq9tjHN2UGdNGOAk8aKMO52TxKwNfdaG/lHHQsPkkO3wXKbA49nuGZs/H6sbD73IxYvQ32EmuTjixkMvcnfv6Txa6FmSOUREREREREREZHEpkCAiK+by6uiSBhEmHG8wwU1iXlsvc1GzzEWNCrk4WoJVLoyTxKwPfdaHPldWhqmaNrvyXTyVKfJ0pkBomMc07vUje5YsiDB9nle8jMociYiIiIiIiIicABRIEJEVsTFsLEk5o9nme8fYK9zde/q8H7O5Ps5rG+OrJngwm0Lc4srK8GRQ4alskd3ZErsWUELoTZVDi17OaDa/d+B5/mTdeYzY7rLNKSIiIiIiIiIiC6dAgoisiHcdenne5zYMi2ezeZ71Crzsplew56IWp4VNLm6U2RA05jXO5dVRHsn38qzXuQzQurDJpfVxNtfHWDdDSaETQSFusaU2ypbaKPsdj8dzXezKdbPfyXR8TG8rYMcCGiuPWg5P5rp42cky4qSBgI1Bgw1Bg9fWy2STuQMvuTjiHWP7+GL/mfOeV0RERERERERElp8CCSKyqLcn4AAAIABJREFU7N5UOcTGcO7N/4Zh8d1SP98v9s9YkuhJurivay0bwwZXj77COc3anGNeP7yHP1l33lHjba6Pc2l9jM3LUNZnOa0Lfd46PsRbx4fYlevi8Vz3jFkK7xjbN6+si1HL4W/7z5gxGDNxX64n4vLaKFeNHZgzoHBxfZxz/dqswR0REREREREREVlZCiSIyLKbz5Xve90sX+nbOK8a+i87WT47cM68Gjf3tgI21cuTjX5fXxvjVyqHOCuoz2/xJ7DN9XE218d5yc3xg2Ifj+bT12Bj2JhXX4RH8z3c3Td3aai6afHdYj9PZkvcdOjFOTNG3jHyCn+y/rz5PQkREREREREREVl2CiSIyLK6vDo655Xvo5bD5wYW3hj5u8V+6oY1Z++Ft5YPMG45vLFyiNc0ywua42RwRlDn+uE6W2qjPFhcw6X1sTkfM98gwlQjtsvnBl7FLUPPzxpM2Bg22Bg21HhZRERERERERGSVMld6ASJyanlj5dCsxxuGxV0DZy04iDDh0ULP5JX2nfS2At5/8PlTMogw1fnNKr9z8AVeN0cgYa+bXXAQYULdtPhK38Y5z3tjefbPhYiIiIiIiIiIrBxlJIjIspqrN8J3S/3HfWX6P/ScNmfD3293reW+rrXHNc/J4FV+nQ8ceHbWc+7tOe245njZyfLtrrW8dZaSVuf6c/e3EBERERERERGRlWEkSZKs9CJE5NTx9CWvnvX4eQ89ilksHfc8Q//9/2T07r/peDx32RZO/+KXj3ueE93wXf+LQ//jjo7HF+t1Cl/Zy/NvffOs51zwxM+Oex4RERERERERkVNNuZxW3di1a9eij71582ZApY1EZBUpbHvzogQRALre/o5Zj9d//NiizHOia/zkx7MeL/3a1Ysyj3PaBnKXbVmUsUREREREREREZHkpkCAiq4Z3wYWrcqxTWW7L5Ys2VvayrYs2loiIiIiIiIiILB8FEkRk1VjMTWsA74LZyyjFjdn7NZwKmj9/ZtbjzmkblmklIiIiIiIiIiKyWimQICInLatYnP2EuHMz5lNFUq0s21yLHSgSEREREREREZHloUCCiJy0wldemfW4kcks00pWL2fd+mWbq/7Yo8s2l4iIiIiIiIiILB4FEkRk1Vjsjebwlb2zHjcse1HnOxHZ60+b9bj/9FOLNldcKS/aWCIiIiIiIiIisnwUSBCRVWMxN62rD/zzrMfNwhxlj04Rc70Oixncqf/4sUUbS0RERERERERElo8CCSKyalQf/H/nzCKY/1izBxJUrz+Ve93rZz0+/o/fWJR5/KefWtRAkYiIiIiIiIiILB8FEkRkWc11BfzwX/yP457Df/qpOTfAc5cpkACQff1lsx73n36K+o+PPyvh0Bc+P+tx74JXH/ccIiIiIiIiIiKyNBRIEJFlNVcmwPg/fuO4r1w/9Befm/Ocwva3HNccJwvvvAtw5uiTsP9jHzmuOfynn5qz1FRhm94PEREREREREZHVSoEEEVlWPb/5npVeArnLtuCctmGll7FqlN5+9azHo/LSN0nuevs7lnwOERERERERERE5NgokiMiyyl12+axlbArb3ox3wYXHNcfAH/zRrCWU+m7+D8c1/smm9zdvmPX1Wn/bJ49rfO+CC+m5/oaOx7t+7dcV2BERERERERERWcUUSBCRZddz/cxZCWaheNyb1gDOaRvov/mWGY/lLtui/gjTmMUSxe1vnvFYYdubF6UMVP/Nt3QsobQaslRERERERERERKQzBRJEZNl1vf0dFLYdvXG9/rZPYhZLizJHz2++h9xlW466f+AP/mhRxj/ZDPzBHx210W8Wiov2epnFEus+8amj7u/73VuOOwNFRERERERERESWlgIJIrIi1t/2ySPK6SzWle9TrbvtU0fMMfD7H9GmdQczbfT333zL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"},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"a98777be8b24f71228ed01057138be76","cid":"0-21","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T00:49:11.846Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js:21:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-21","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset1.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T00:49:11.901Z"},{"type":"suite:start","start":"2022-02-18T00:48:57.790Z","_duration":12454,"tests":[{"type":"test","start":"2022-02-18T00:48:57.796Z","_duration":12435,"uid":"test-00-0","cid":"0-22","title":"Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","fullTitle":"UserStory: Reset Cart State.Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","output":[],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:10.231Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:57.796Z","_duration":12435,"uid":"test-00-0","cid":"0-22","title":"Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","fullTitle":"UserStory: Reset Cart State.Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2791db1a-6e01-4064-b40e-cc38e911bdc0"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2791db1a-6e01-4064-b40e-cc38e911bdc0/clear","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2791db1a-6e01-4064-b40e-cc38e911bdc0/clear","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2791db1a-6e01-4064-b40e-cc38e911bdc0/value","body":{"text":"standard_user"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2791db1a-6e01-4064-b40e-cc38e911bdc0/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a10a31ea-3f5d-4afa-93c2-e6e39483d51b"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a10a31ea-3f5d-4afa-93c2-e6e39483d51b/clear","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a10a31ea-3f5d-4afa-93c2-e6e39483d51b/clear","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a10a31ea-3f5d-4afa-93c2-e6e39483d51b/value","body":{"text":"secret_sauce"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a10a31ea-3f5d-4afa-93c2-e6e39483d51b/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bae6b391-0364-4d53-aac5-d21311c437bc"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bae6b391-0364-4d53-aac5-d21311c437bc/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bae6b391-0364-4d53-aac5-d21311c437bc/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b05b9d8-87fb-4f60-bf93-1e4870c7c30d"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9b05b9d8-87fb-4f60-bf93-1e4870c7c30d/text","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9b05b9d8-87fb-4f60-bf93-1e4870c7c30d/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"101eef56-be12-45e3-8447-e2d04e2d6d63"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/101eef56-be12-45e3-8447-e2d04e2d6d63/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/101eef56-be12-45e3-8447-e2d04e2d6d63/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9c979afa-1898-4d9d-ae7b-c74324ff2ec6"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9c979afa-1898-4d9d-ae7b-c74324ff2ec6/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9c979afa-1898-4d9d-ae7b-c74324ff2ec6/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c96166d1-a0c2-4567-bf92-d05e96440750"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c96166d1-a0c2-4567-bf92-d05e96440750"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c96166d1-a0c2-4567-bf92-d05e96440750/text","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c96166d1-a0c2-4567-bf92-d05e96440750/text","body":{},"result":{"value":"2"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c96166d1-a0c2-4567-bf92-d05e96440750"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6ceabaf7-f3bc-4267-871a-1be99110eee7"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6ceabaf7-f3bc-4267-871a-1be99110eee7/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6ceabaf7-f3bc-4267-871a-1be99110eee7/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a8a260c-dfd7-4976-a662-8ff4b8500186"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a8a260c-dfd7-4976-a662-8ff4b8500186/text","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a8a260c-dfd7-4976-a662-8ff4b8500186/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"efeaadcc-3d8e-4fe3-a375-4afe5268f94b"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/efeaadcc-3d8e-4fe3-a375-4afe5268f94b/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/efeaadcc-3d8e-4fe3-a375-4afe5268f94b/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":false},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3816cf57-170a-48ab-89e2-1f228299df61","ELEMENT":"3816cf57-170a-48ab-89e2-1f228299df61"}]},"result":{"value":true},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3816cf57-170a-48ab-89e2-1f228299df61/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3816cf57-170a-48ab-89e2-1f228299df61/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"46ebca1c-060b-47d0-a91c-c566ad587e5f"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/46ebca1c-060b-47d0-a91c-c566ad587e5f/click","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/46ebca1c-060b-47d0-a91c-c566ad587e5f/click","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a8a260c-dfd7-4976-a662-8ff4b8500186"}},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a8a260c-dfd7-4976-a662-8ff4b8500186/text","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a8a260c-dfd7-4976-a662-8ff4b8500186/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"8df0dda6186015e29f2b59518bf5acbd","cid":"0-22","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:10.231Z"}],"uid":"suite-0-0","cid":"0-22","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T00:49:10.247Z"},{"type":"suite:start","start":"2022-02-18T00:48:58.805Z","_duration":12705,"tests":[{"type":"test","start":"2022-02-18T00:48:58.807Z","_duration":12685,"uid":"test-00-0","cid":"0-23","title":"Reset_3: should be able to reset cart state from CheckoutStep1","fullTitle":"UserStory: Reset Cart State.Reset_3: should be able to reset cart state from CheckoutStep1","output":[],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:11.492Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:58.807Z","_duration":12685,"uid":"test-00-0","cid":"0-23","title":"Reset_3: should be able to reset cart state from CheckoutStep1","fullTitle":"UserStory: Reset Cart State.Reset_3: should be able to reset cart state from CheckoutStep1","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fc3953de-7f35-47cf-aca8-dc6200bb8df2"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc3953de-7f35-47cf-aca8-dc6200bb8df2/clear","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc3953de-7f35-47cf-aca8-dc6200bb8df2/clear","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fc3953de-7f35-47cf-aca8-dc6200bb8df2/value","body":{"text":"standard_user"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fc3953de-7f35-47cf-aca8-dc6200bb8df2/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4c1b90a3-27ba-4b92-9dab-f3ff061cd699"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4c1b90a3-27ba-4b92-9dab-f3ff061cd699/clear","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4c1b90a3-27ba-4b92-9dab-f3ff061cd699/clear","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4c1b90a3-27ba-4b92-9dab-f3ff061cd699/value","body":{"text":"secret_sauce"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4c1b90a3-27ba-4b92-9dab-f3ff061cd699/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1339c606-0fb1-4054-a672-65d35b0ed9e6"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1339c606-0fb1-4054-a672-65d35b0ed9e6/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1339c606-0fb1-4054-a672-65d35b0ed9e6/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"036d0aef-e062-4850-95d2-400c7f76f46d"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/036d0aef-e062-4850-95d2-400c7f76f46d/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/036d0aef-e062-4850-95d2-400c7f76f46d/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f346ed09-1437-4c58-b92c-a8badfac851c"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f346ed09-1437-4c58-b92c-a8badfac851c/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f346ed09-1437-4c58-b92c-a8badfac851c/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6d312d93-4296-42f3-8dd6-ec30b9ef16b9"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6d312d93-4296-42f3-8dd6-ec30b9ef16b9"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6d312d93-4296-42f3-8dd6-ec30b9ef16b9/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6d312d93-4296-42f3-8dd6-ec30b9ef16b9/text","body":{},"result":{"value":"1"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6d312d93-4296-42f3-8dd6-ec30b9ef16b9"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"efa1961b-4ae8-4ce3-8d04-eaa4beecc2c0"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/efa1961b-4ae8-4ce3-8d04-eaa4beecc2c0/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/efa1961b-4ae8-4ce3-8d04-eaa4beecc2c0/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e4c39563-aa43-4509-ac31-7712e14c0db5"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4c39563-aa43-4509-ac31-7712e14c0db5/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4c39563-aa43-4509-ac31-7712e14c0db5/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"76b01eae-1aac-41e5-9b17-6b45d415a127"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"76b01eae-1aac-41e5-9b17-6b45d415a127"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/76b01eae-1aac-41e5-9b17-6b45d415a127/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/76b01eae-1aac-41e5-9b17-6b45d415a127/text","body":{},"result":{"value":"1"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"76b01eae-1aac-41e5-9b17-6b45d415a127"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1df891c6-930a-4135-bdbf-1e000457bca8"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/1df891c6-930a-4135-bdbf-1e000457bca8/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/1df891c6-930a-4135-bdbf-1e000457bca8/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f5a45cdc-82b8-4e17-beb9-9d92301cd94f"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f5a45cdc-82b8-4e17-beb9-9d92301cd94f/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f5a45cdc-82b8-4e17-beb9-9d92301cd94f/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"055cbbce-fe3e-4db6-817f-887efb2fa8c5"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"055cbbce-fe3e-4db6-817f-887efb2fa8c5"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"055cbbce-fe3e-4db6-817f-887efb2fa8c5"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/055cbbce-fe3e-4db6-817f-887efb2fa8c5/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/055cbbce-fe3e-4db6-817f-887efb2fa8c5/text","body":{},"result":{"value":"1"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"055cbbce-fe3e-4db6-817f-887efb2fa8c5"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9ddba42-a912-4470-b51e-6d382f9bd655"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"885b6b55-a398-458c-a031-8047f6c7cea2"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07d86101-bc66-4b9f-af0e-dd7852ea2d3e"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f9ddba42-a912-4470-b51e-6d382f9bd655"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f9ddba42-a912-4470-b51e-6d382f9bd655/clear","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f9ddba42-a912-4470-b51e-6d382f9bd655/clear","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f9ddba42-a912-4470-b51e-6d382f9bd655/value","body":{"text":"Jane"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f9ddba42-a912-4470-b51e-6d382f9bd655/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"885b6b55-a398-458c-a031-8047f6c7cea2"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/885b6b55-a398-458c-a031-8047f6c7cea2/clear","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/885b6b55-a398-458c-a031-8047f6c7cea2/clear","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/885b6b55-a398-458c-a031-8047f6c7cea2/value","body":{"text":"Doe"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/885b6b55-a398-458c-a031-8047f6c7cea2/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"07d86101-bc66-4b9f-af0e-dd7852ea2d3e"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07d86101-bc66-4b9f-af0e-dd7852ea2d3e/clear","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07d86101-bc66-4b9f-af0e-dd7852ea2d3e/clear","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/07d86101-bc66-4b9f-af0e-dd7852ea2d3e/value","body":{"text":"90210"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/07d86101-bc66-4b9f-af0e-dd7852ea2d3e/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e3e79237-4f03-4aea-9011-0c362af93bda"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e3e79237-4f03-4aea-9011-0c362af93bda/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e3e79237-4f03-4aea-9011-0c362af93bda/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":false},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"456a645b-d6fb-46d5-b105-ee49699eb1f2","ELEMENT":"456a645b-d6fb-46d5-b105-ee49699eb1f2"}]},"result":{"value":true},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/456a645b-d6fb-46d5-b105-ee49699eb1f2/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/456a645b-d6fb-46d5-b105-ee49699eb1f2/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"057f43cd-4d84-4bac-a4d2-861b0caab127"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/057f43cd-4d84-4bac-a4d2-861b0caab127/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/057f43cd-4d84-4bac-a4d2-861b0caab127/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f51ffac0-d770-42e9-b55c-6cd5f9e7a0b3"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f51ffac0-d770-42e9-b55c-6cd5f9e7a0b3/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f51ffac0-d770-42e9-b55c-6cd5f9e7a0b3/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f51ffac0-d770-42e9-b55c-6cd5f9e7a0b3"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f51ffac0-d770-42e9-b55c-6cd5f9e7a0b3/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f51ffac0-d770-42e9-b55c-6cd5f9e7a0b3/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a3da5c61-a9e0-4ef8-82da-d31dfbae0e10"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a3da5c61-a9e0-4ef8-82da-d31dfbae0e10/click","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a3da5c61-a9e0-4ef8-82da-d31dfbae0e10/click","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"90eaf3af-0e59-44ca-af91-639712b251f4"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/90eaf3af-0e59-44ca-af91-639712b251f4/text","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/90eaf3af-0e59-44ca-af91-639712b251f4/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"388eacd9e685d35a68cc522de6bc1012","cid":"0-23","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:11.492Z"}],"uid":"suite-0-0","cid":"0-23","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset3-checkout1.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T00:49:11.516Z"},{"type":"suite:start","start":"2022-02-18T00:48:59.537Z","_duration":12785,"tests":[{"type":"test","start":"2022-02-18T00:48:59.539Z","_duration":12752,"uid":"test-00-0","cid":"0-24","title":"Reset_4: should be able to add one item to cart and check it out successfully","fullTitle":"UserStory: Reset Cart State.Reset_4: should be able to add one item to cart and check it out successfully","output":[],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:12.291Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:59.539Z","_duration":12752,"uid":"test-00-0","cid":"0-24","title":"Reset_4: should be able to add one item to cart and check it out successfully","fullTitle":"UserStory: Reset Cart State.Reset_4: should be able to add one item to cart and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0420856c-205b-48bc-a5be-d13a0fc896f7"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0420856c-205b-48bc-a5be-d13a0fc896f7/clear","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0420856c-205b-48bc-a5be-d13a0fc896f7/clear","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0420856c-205b-48bc-a5be-d13a0fc896f7/value","body":{"text":"standard_user"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0420856c-205b-48bc-a5be-d13a0fc896f7/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79937276-77da-4c9d-b10a-b7dbe5cea6e7"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79937276-77da-4c9d-b10a-b7dbe5cea6e7/clear","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79937276-77da-4c9d-b10a-b7dbe5cea6e7/clear","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79937276-77da-4c9d-b10a-b7dbe5cea6e7/value","body":{"text":"secret_sauce"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79937276-77da-4c9d-b10a-b7dbe5cea6e7/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"286b8585-7540-451c-8bbe-9c267ff0f2ee"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/286b8585-7540-451c-8bbe-9c267ff0f2ee/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/286b8585-7540-451c-8bbe-9c267ff0f2ee/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"58a258da-5868-4b37-8971-8a53603b54a7"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/58a258da-5868-4b37-8971-8a53603b54a7/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/58a258da-5868-4b37-8971-8a53603b54a7/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6caa7970-3d71-432e-a2aa-9666caf060c1"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6caa7970-3d71-432e-a2aa-9666caf060c1/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6caa7970-3d71-432e-a2aa-9666caf060c1/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ff353971-66e5-48fe-911b-12099328a2de"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ff353971-66e5-48fe-911b-12099328a2de"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/ff353971-66e5-48fe-911b-12099328a2de/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/ff353971-66e5-48fe-911b-12099328a2de/text","body":{},"result":{"value":"1"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"ff353971-66e5-48fe-911b-12099328a2de"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d1df2a5-e1eb-47dc-b382-974b421f67c6"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2d1df2a5-e1eb-47dc-b382-974b421f67c6/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2d1df2a5-e1eb-47dc-b382-974b421f67c6/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"48711905-a78e-4f05-9e8d-cb9ed5cc7315"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/48711905-a78e-4f05-9e8d-cb9ed5cc7315/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/48711905-a78e-4f05-9e8d-cb9ed5cc7315/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a98c921a-9ad6-4c57-b8d2-2d5f53c74a6f"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a98c921a-9ad6-4c57-b8d2-2d5f53c74a6f"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a98c921a-9ad6-4c57-b8d2-2d5f53c74a6f/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a98c921a-9ad6-4c57-b8d2-2d5f53c74a6f/text","body":{},"result":{"value":"1"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"a98c921a-9ad6-4c57-b8d2-2d5f53c74a6f"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f09da656-cbfe-43ba-90ad-c92e98c441b2"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f09da656-cbfe-43ba-90ad-c92e98c441b2/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f09da656-cbfe-43ba-90ad-c92e98c441b2/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"86aaae49-b0e6-4462-a1a1-621d88383392"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/86aaae49-b0e6-4462-a1a1-621d88383392/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/86aaae49-b0e6-4462-a1a1-621d88383392/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"61e73054-4cd1-4d85-8ebf-c3b22cef4f4a"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"61e73054-4cd1-4d85-8ebf-c3b22cef4f4a"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/61e73054-4cd1-4d85-8ebf-c3b22cef4f4a/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/61e73054-4cd1-4d85-8ebf-c3b22cef4f4a/text","body":{},"result":{"value":"1"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"61e73054-4cd1-4d85-8ebf-c3b22cef4f4a"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bbbd5e5f-5709-4d05-8a19-23f26af2fdca"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d66d8e53-497e-4234-95f0-6d64da2b1265"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bfb2f2c9-96a5-4ab9-b512-63725de9c344"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bbbd5e5f-5709-4d05-8a19-23f26af2fdca"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bbbd5e5f-5709-4d05-8a19-23f26af2fdca/clear","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bbbd5e5f-5709-4d05-8a19-23f26af2fdca/clear","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bbbd5e5f-5709-4d05-8a19-23f26af2fdca/value","body":{"text":"Jane"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bbbd5e5f-5709-4d05-8a19-23f26af2fdca/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d66d8e53-497e-4234-95f0-6d64da2b1265"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d66d8e53-497e-4234-95f0-6d64da2b1265/clear","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d66d8e53-497e-4234-95f0-6d64da2b1265/clear","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d66d8e53-497e-4234-95f0-6d64da2b1265/value","body":{"text":"Doe"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d66d8e53-497e-4234-95f0-6d64da2b1265/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bfb2f2c9-96a5-4ab9-b512-63725de9c344"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bfb2f2c9-96a5-4ab9-b512-63725de9c344/clear","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bfb2f2c9-96a5-4ab9-b512-63725de9c344/clear","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bfb2f2c9-96a5-4ab9-b512-63725de9c344/value","body":{"text":"90210"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bfb2f2c9-96a5-4ab9-b512-63725de9c344/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2416166f-74e9-44f3-b88f-6ac563c7a362"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2416166f-74e9-44f3-b88f-6ac563c7a362/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2416166f-74e9-44f3-b88f-6ac563c7a362/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3dbae7da-b44c-496e-bcd4-f8b9594be5a4"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3dbae7da-b44c-496e-bcd4-f8b9594be5a4/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3dbae7da-b44c-496e-bcd4-f8b9594be5a4/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5f04245b-aa00-42ba-a042-0601ce05070d"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5f04245b-aa00-42ba-a042-0601ce05070d"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5f04245b-aa00-42ba-a042-0601ce05070d/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5f04245b-aa00-42ba-a042-0601ce05070d/text","body":{},"result":{"value":"1"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"5f04245b-aa00-42ba-a042-0601ce05070d"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fdd03fd9-7a22-4270-b1eb-6dd1b07d2a38"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fdd03fd9-7a22-4270-b1eb-6dd1b07d2a38/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fdd03fd9-7a22-4270-b1eb-6dd1b07d2a38/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":false},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":false},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":false},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":false},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":false},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":false},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"b85e6664-992e-47b0-9845-40415629a6cb","ELEMENT":"b85e6664-992e-47b0-9845-40415629a6cb"}]},"result":{"value":true},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b85e6664-992e-47b0-9845-40415629a6cb/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b85e6664-992e-47b0-9845-40415629a6cb/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb72596e-8d06-4896-abdf-1eaa0471397c"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb72596e-8d06-4896-abdf-1eaa0471397c/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb72596e-8d06-4896-abdf-1eaa0471397c/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3dbae7da-b44c-496e-bcd4-f8b9594be5a4"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3dbae7da-b44c-496e-bcd4-f8b9594be5a4/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3dbae7da-b44c-496e-bcd4-f8b9594be5a4/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3dbae7da-b44c-496e-bcd4-f8b9594be5a4"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3dbae7da-b44c-496e-bcd4-f8b9594be5a4/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3dbae7da-b44c-496e-bcd4-f8b9594be5a4/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5fd61836-6e08-43c6-8454-29a77db138cd"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5fd61836-6e08-43c6-8454-29a77db138cd/click","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5fd61836-6e08-43c6-8454-29a77db138cd/click","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"96fe3be3-404b-4be9-8a24-001c11305861"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/96fe3be3-404b-4be9-8a24-001c11305861/text","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/96fe3be3-404b-4be9-8a24-001c11305861/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"991d6ffe715a738f543ca99e0a8073f7","cid":"0-24","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:12.291Z"}],"uid":"suite-0-0","cid":"0-24","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset4-checkout2.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T00:49:12.327Z"},{"type":"suite:start","start":"2022-02-18T00:49:14.458Z","_duration":11771,"tests":[{"type":"test","start":"2022-02-18T00:49:14.459Z","_duration":11763,"uid":"test-00-0","cid":"0-25","title":"Reset_5: should be able to add one item to cart and check it out successfully","fullTitle":"UserStory: Reset Cart State.Reset_5: should be able to add one item to cart and check it out successfully","output":[],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:26.222Z"}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:49:14.459Z","_duration":11763,"uid":"test-00-0","cid":"0-25","title":"Reset_5: should be able to add one item to cart and check it out successfully","fullTitle":"UserStory: Reset Cart State.Reset_5: should be able to add one item to cart and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c03ada3f-03a5-4012-b387-7a8db833ada4"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c03ada3f-03a5-4012-b387-7a8db833ada4/clear","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c03ada3f-03a5-4012-b387-7a8db833ada4/clear","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c03ada3f-03a5-4012-b387-7a8db833ada4/value","body":{"text":"standard_user"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c03ada3f-03a5-4012-b387-7a8db833ada4/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"86d0f8ae-c2d0-4bcd-8bc8-d7badc530977"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/86d0f8ae-c2d0-4bcd-8bc8-d7badc530977/clear","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/86d0f8ae-c2d0-4bcd-8bc8-d7badc530977/clear","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/86d0f8ae-c2d0-4bcd-8bc8-d7badc530977/value","body":{"text":"secret_sauce"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/86d0f8ae-c2d0-4bcd-8bc8-d7badc530977/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3d2c6414-d879-4675-930f-09755005306d"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/3d2c6414-d879-4675-930f-09755005306d/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/3d2c6414-d879-4675-930f-09755005306d/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e8aeafbc-a51b-4f26-bd3c-ceedb592c5bf"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e8aeafbc-a51b-4f26-bd3c-ceedb592c5bf/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e8aeafbc-a51b-4f26-bd3c-ceedb592c5bf/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"34c2a221-e726-497a-8f5c-d186117ed4a1"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/34c2a221-e726-497a-8f5c-d186117ed4a1/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/34c2a221-e726-497a-8f5c-d186117ed4a1/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1b75ae47-6f0a-4366-ac83-d02b5f6de1f5"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"1b75ae47-6f0a-4366-ac83-d02b5f6de1f5"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/1b75ae47-6f0a-4366-ac83-d02b5f6de1f5/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/1b75ae47-6f0a-4366-ac83-d02b5f6de1f5/text","body":{},"result":{"value":"1"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"1b75ae47-6f0a-4366-ac83-d02b5f6de1f5"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"75648e67-1f84-4aa8-a655-a971bbad9466"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/75648e67-1f84-4aa8-a655-a971bbad9466/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/75648e67-1f84-4aa8-a655-a971bbad9466/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23ccc583-5779-43e5-a6e1-0484d7540ec6"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/23ccc583-5779-43e5-a6e1-0484d7540ec6/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/23ccc583-5779-43e5-a6e1-0484d7540ec6/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7f670f5e-dba0-44b0-bcdf-46111c646523"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7f670f5e-dba0-44b0-bcdf-46111c646523"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"7f670f5e-dba0-44b0-bcdf-46111c646523"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/7f670f5e-dba0-44b0-bcdf-46111c646523/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/7f670f5e-dba0-44b0-bcdf-46111c646523/text","body":{},"result":{"value":"1"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"7f670f5e-dba0-44b0-bcdf-46111c646523"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"695427a8-f202-47db-aa32-6ebe89827bd8"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/695427a8-f202-47db-aa32-6ebe89827bd8/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/695427a8-f202-47db-aa32-6ebe89827bd8/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"97fda41c-0da1-478b-8f2e-d84b24d730ad"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/97fda41c-0da1-478b-8f2e-d84b24d730ad/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/97fda41c-0da1-478b-8f2e-d84b24d730ad/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"01cc0a62-7f29-4341-8a32-f3b9e0315b47"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"01cc0a62-7f29-4341-8a32-f3b9e0315b47"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"01cc0a62-7f29-4341-8a32-f3b9e0315b47"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/01cc0a62-7f29-4341-8a32-f3b9e0315b47/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/01cc0a62-7f29-4341-8a32-f3b9e0315b47/text","body":{},"result":{"value":"1"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"01cc0a62-7f29-4341-8a32-f3b9e0315b47"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f489b1db-a1db-4dea-87d8-b2dff46a4a32"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ed4cf332-8d48-434e-84d7-4e56af6cbd23"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7d7b056f-729d-4390-8044-2f782fb4c902"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f489b1db-a1db-4dea-87d8-b2dff46a4a32"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f489b1db-a1db-4dea-87d8-b2dff46a4a32/clear","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f489b1db-a1db-4dea-87d8-b2dff46a4a32/clear","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f489b1db-a1db-4dea-87d8-b2dff46a4a32/value","body":{"text":"Jane"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f489b1db-a1db-4dea-87d8-b2dff46a4a32/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ed4cf332-8d48-434e-84d7-4e56af6cbd23"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ed4cf332-8d48-434e-84d7-4e56af6cbd23/clear","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ed4cf332-8d48-434e-84d7-4e56af6cbd23/clear","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ed4cf332-8d48-434e-84d7-4e56af6cbd23/value","body":{"text":"Doe"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ed4cf332-8d48-434e-84d7-4e56af6cbd23/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7d7b056f-729d-4390-8044-2f782fb4c902"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7d7b056f-729d-4390-8044-2f782fb4c902/clear","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7d7b056f-729d-4390-8044-2f782fb4c902/clear","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7d7b056f-729d-4390-8044-2f782fb4c902/value","body":{"text":"90210"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7d7b056f-729d-4390-8044-2f782fb4c902/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"36d89f6d-8389-4cc3-a722-5ed57017fd63"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/36d89f6d-8389-4cc3-a722-5ed57017fd63/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/36d89f6d-8389-4cc3-a722-5ed57017fd63/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f09c7bbc-df9b-4ef8-a9f6-40fade058bad"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f09c7bbc-df9b-4ef8-a9f6-40fade058bad/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f09c7bbc-df9b-4ef8-a9f6-40fade058bad/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4a19c036-9f4f-43c1-b72c-04c35790e2c3"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4a19c036-9f4f-43c1-b72c-04c35790e2c3"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/4a19c036-9f4f-43c1-b72c-04c35790e2c3/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/4a19c036-9f4f-43c1-b72c-04c35790e2c3/text","body":{},"result":{"value":"1"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"4a19c036-9f4f-43c1-b72c-04c35790e2c3"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a5cd72bb-3958-4d27-974a-ab5f524146a6"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a5cd72bb-3958-4d27-974a-ab5f524146a6/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a5cd72bb-3958-4d27-974a-ab5f524146a6/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"efd80b76-3d43-429b-a8d8-20db517835eb"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/efd80b76-3d43-429b-a8d8-20db517835eb/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/efd80b76-3d43-429b-a8d8-20db517835eb/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"daa293f5-20ab-412a-b497-b3aa1da2ff2f"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"daa293f5-20ab-412a-b497-b3aa1da2ff2f"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/daa293f5-20ab-412a-b497-b3aa1da2ff2f/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/daa293f5-20ab-412a-b497-b3aa1da2ff2f/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c0f18be0-efad-44b5-9379-1c7e07ee94b9"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0f18be0-efad-44b5-9379-1c7e07ee94b9/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c0f18be0-efad-44b5-9379-1c7e07ee94b9/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":false},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"d2784df1-aeec-4a40-b86c-af85fa20ad65","ELEMENT":"d2784df1-aeec-4a40-b86c-af85fa20ad65"}]},"result":{"value":true},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d2784df1-aeec-4a40-b86c-af85fa20ad65/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d2784df1-aeec-4a40-b86c-af85fa20ad65/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-cross-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"59842cd8-3bd0-497a-9234-dad20e94e50a"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/59842cd8-3bd0-497a-9234-dad20e94e50a/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/59842cd8-3bd0-497a-9234-dad20e94e50a/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"efd80b76-3d43-429b-a8d8-20db517835eb"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/efd80b76-3d43-429b-a8d8-20db517835eb/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/efd80b76-3d43-429b-a8d8-20db517835eb/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"daa293f5-20ab-412a-b497-b3aa1da2ff2f"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"daa293f5-20ab-412a-b497-b3aa1da2ff2f"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/daa293f5-20ab-412a-b497-b3aa1da2ff2f/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/daa293f5-20ab-412a-b497-b3aa1da2ff2f/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"efd80b76-3d43-429b-a8d8-20db517835eb"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/efd80b76-3d43-429b-a8d8-20db517835eb/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/efd80b76-3d43-429b-a8d8-20db517835eb/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"daa293f5-20ab-412a-b497-b3aa1da2ff2f"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"daa293f5-20ab-412a-b497-b3aa1da2ff2f"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/daa293f5-20ab-412a-b497-b3aa1da2ff2f/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/daa293f5-20ab-412a-b497-b3aa1da2ff2f/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"37ec6b11-3eed-46e9-82a4-835082078cbe"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/37ec6b11-3eed-46e9-82a4-835082078cbe/click","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/37ec6b11-3eed-46e9-82a4-835082078cbe/click","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5a326b5f-3be6-434d-bb1b-b6d2a9d2d395"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5a326b5f-3be6-434d-bb1b-b6d2a9d2d395/text","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5a326b5f-3be6-434d-bb1b-b6d2a9d2d395/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"b3498b873c52ad77931d8969a6f28a29","cid":"0-25","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"passed","events":[],"errorIndex":0,"end":"2022-02-18T00:49:26.222Z"}],"uid":"suite-0-0","cid":"0-25","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset5-checkoutcomplete.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T00:49:26.230Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\standard_user\\master-report.html"}