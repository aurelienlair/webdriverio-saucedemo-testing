{"info":{"type":"runner","start":"2022-02-18T00:48:14.236Z","_duration":18493,"cid":"0-6","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir39244_507561554"},"goog:chromeOptions":{"debuggerAddress":"localhost:61492"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"81471bde2762ec4a8877f9e61483aab3"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/standard_user","filename":"report.html","reportTitle":"Sauce Demo Report for standard_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js"],"sessionId":"81471bde2762ec4a8877f9e61483aab3","isMultiremote":false,"instanceOptions":{"81471bde2762ec4a8877f9e61483aab3":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/standard_user","filename":"report.html","reportTitle":"Sauce Demo Report for standard_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T00:48:32.729Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":18493,"start":"2022-02-18T00:48:14.236Z","end":"2022-02-18T00:48:32Z"},"title":"Sauce Demo Report for standard_user ","suites":[{"type":"suite:start","start":"2022-02-18T00:48:14.244Z","_duration":18418,"tests":[{"type":"test","start":"2022-02-18T00:48:14.245Z","_duration":18400,"uid":"test-00-0","cid":"0-6","title":"TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","fullTitle":"UserStory: Logout.TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ca59a8c1-f6af-49e8-a0cb-7ded21a800cf"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/value","body":{"text":"standard_user"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d19adf09-ce86-4546-a376-04a0a56a9dbe"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/value","body":{"text":"secret_sauce"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"948a7646-ef9b-42ab-8ffc-ec4266ce5a56"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/948a7646-ef9b-42ab-8ffc-ec4266ce5a56/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/948a7646-ef9b-42ab-8ffc-ec4266ce5a56/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0be5f86d-d6f6-4261-a88d-30b2670baa19"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0be5f86d-d6f6-4261-a88d-30b2670baa19/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0be5f86d-d6f6-4261-a88d-30b2670baa19/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7ce3ed2d-c6ee-4309-84ae-976519349e1c"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7ce3ed2d-c6ee-4309-84ae-976519349e1c/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7ce3ed2d-c6ee-4309-84ae-976519349e1c/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c6d93c33-a5fc-4750-9ad7-724860eae37e/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c6d93c33-a5fc-4750-9ad7-724860eae37e/text","body":{},"result":{"value":"1"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"88952bf6-9cd6-4040-bcc5-02dfe4e11dfa"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/88952bf6-9cd6-4040-bcc5-02dfe4e11dfa/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/88952bf6-9cd6-4040-bcc5-02dfe4e11dfa/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"230ad796-8c9e-48f1-8807-6672ced548a0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/230ad796-8c9e-48f1-8807-6672ced548a0/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/230ad796-8c9e-48f1-8807-6672ced548a0/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f7747a52-e092-4169-bf98-cec7a4481dba"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f7747a52-e092-4169-bf98-cec7a4481dba/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f7747a52-e092-4169-bf98-cec7a4481dba/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2d736376-8f7b-48c7-a8aa-2feeb90554db/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2d736376-8f7b-48c7-a8aa-2feeb90554db/text","body":{},"result":{"value":"1"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9bffc254-7b02-40fe-8418-5d9127914039"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"196ec00b-9a46-411c-a465-af7e657b92af"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9bffc254-7b02-40fe-8418-5d9127914039"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/value","body":{"text":"Jane"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/value","body":{"text":"Doe"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"196ec00b-9a46-411c-a465-af7e657b92af"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/value","body":{"text":"90210"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba34c538-d7d8-472b-ad1d-50ef68b08582"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba34c538-d7d8-472b-ad1d-50ef68b08582/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba34c538-d7d8-472b-ad1d-50ef68b08582/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"01cbc2f8-4a6b-4612-9da8-ab6da7180d50"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3af51dbe-7391-4123-9cdc-7df9eaf3543a"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3af51dbe-7391-4123-9cdc-7df9eaf3543a/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3af51dbe-7391-4123-9cdc-7df9eaf3543a/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b254a4f3-9d07-4c40-9b87-ca4d394bb401"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b254a4f3-9d07-4c40-9b87-ca4d394bb401/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b254a4f3-9d07-4c40-9b87-ca4d394bb401/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f43ec3c0-583a-42c6-bf6d-70fc609ee0aa"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f43ec3c0-583a-42c6-bf6d-70fc609ee0aa/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f43ec3c0-583a-42c6-bf6d-70fc609ee0aa/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fa1df062-5b81-4642-b1a6-bc041fc93ed8"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fa1df062-5b81-4642-b1a6-bc041fc93ed8"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fa1df062-5b81-4642-b1a6-bc041fc93ed8/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fa1df062-5b81-4642-b1a6-bc041fc93ed8/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfcda905-ab95-498d-8475-7a60ebb43ba4"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfcda905-ab95-498d-8475-7a60ebb43ba4/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfcda905-ab95-498d-8475-7a60ebb43ba4/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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jhz/hXxbSlYwrySUo9l41VFA2sD/i7O/RHHvm6za34T3SwfbnnUEaYSFrBUbeWZO4AV1R3v+SOlyOan2AtE5WGeP/P27s+2k7f8VDV4XDlc+WY/ERLhFkRWp+xSKm9+XrewqeJxdoXx1/kaOLksZ4/lERERERERERETk2+7WnpEAgJmswmVkmABvK3sPRnLhZTMzFmzkN2XbWJtvJW1qDKZrn0VxhyWF7PyVlOzfyYZsyzDHuZncuI72L0R8d24OyaHsEvsg9of6/9rw4QkujFvbIuVG3advQ1+KiIiIiIiIiIiIDPU//vznP//5ZjdCRERERERERERERETC19PTA0BDQ0PEj52W1l8/5zaYkSAiIiIiIiIiIiIiIuNFiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQnqL292A4zm2R+/2U0QEZFxdNTx/s1uggDQTfUrz/DaqV5i7Rs5UJSCKdhX+1rZV7ieissx2DcXszzNfCMbOgG4cbywgt1nbLzqKCD1tj1nGNxOVheU0jJ/Ix8vS7nZrRl3jXseZ92RJJaXbsFugQl/f3racDg6yFhkJS7snW/etfn3863iBvVZgN/drfBs3vT7eqPfV31u6kprMRXZJ0T/i4iIiESKZiSIiIh8K8WQvTyfZBN0OXZQdib4N9s/2EPFZYidv5Il37okgsitpondS9eyu95zsxsi8i3UjePlFWx0uG92Q0REREQibsLNSBAREZEbxGJjzZMneLqklYq9Dn6yzU7cJMN3zley+XAHTLGxNj8FpRFEACzY33gf+81uRjDem90AGRcWG9sdtpvdirClLnufj5fdxAbc0H7zQt8NOpWIiIjIDTbh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BBERERERERERERERuagUSBARERERERERERERkXEpkCAiIiIiIiIiIiIiIuNSIEFERERERERERERERMalQIKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4FEgQEREREREREREREZFxKZAgIiIiIiIiIiIiIiLjUiBBRERERERERERERETGpUCCiIiIiIiIiIiIiIiMS4EEEREREREREREREREZlwIJIiIiIiIiIiIiIiIyLgUSRERERERERERERERkXAokiIiIiIiIiIiIiIjIuBRIEBERERERERERERGRcSmQICIiIiIiIiIiIiIi41IgQURERERERERERERExqVAgoiIiIiIiIiIiIiIjEuBBBERERERERERERERGZcCCSIiIiIiIiIiIiIiMi4FEkREREREREREREREZFwKJIiIiIiIiIiIiIiIyLgUSBARERERERERERERkXEpkCAiIiIiIiIiIiIiIuNSIEFERERERERERERERMalQIKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4Aq7ruhf7IERERERERERERERE5OwNDw9f8NdQRoKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4FEgQEREREREREREREZFxKZAgIiIiIiIiIiIiIiLjUiBBRERERERERERERETGpUCCiIiIiIiIiIiIiIiMS4EEEREREREREREREREZlwIJIiIiIiIiIiIiIiIyrtDFPgARERERkSuF6zi4joOTyeBk0hQyKZxMhkI6jZNJ4dg2TjaLY2dxbRsn5y/ncpDP4+YLuE5xcsB1cB0Xisuuv+z4y67rv7DrrXsrpW3FxZJAwJ8XVwNjV7zJMAgYhvdYwPDXxy4XpyAEQwRCIQwrjGFZBCzLXw4TsCyCkTKMSBlGJEKwLDq6blkEgsEL+EmIiIiIiMhkUiBBRERERARwXRc3n8fN2d6Af3Gw387i2DZuLutvH7PNnzs52/vZfA43l/OX8zj53Oj2fA63UPCC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"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T00:48:32.645Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T00:48:14.245Z","_duration":18400,"uid":"test-00-0","cid":"0-6","title":"TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","fullTitle":"UserStory: Logout.TestCase_15: (TestCase_2 modified) should be able to add one item to cart, checkout, logout at checkoutComplete page, log back in and check 0 items in cart","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ca59a8c1-f6af-49e8-a0cb-7ded21a800cf"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/value","body":{"text":"standard_user"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ca59a8c1-f6af-49e8-a0cb-7ded21a800cf/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d19adf09-ce86-4546-a376-04a0a56a9dbe"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/value","body":{"text":"secret_sauce"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d19adf09-ce86-4546-a376-04a0a56a9dbe/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"948a7646-ef9b-42ab-8ffc-ec4266ce5a56"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/948a7646-ef9b-42ab-8ffc-ec4266ce5a56/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/948a7646-ef9b-42ab-8ffc-ec4266ce5a56/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0be5f86d-d6f6-4261-a88d-30b2670baa19"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0be5f86d-d6f6-4261-a88d-30b2670baa19/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0be5f86d-d6f6-4261-a88d-30b2670baa19/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7ce3ed2d-c6ee-4309-84ae-976519349e1c"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7ce3ed2d-c6ee-4309-84ae-976519349e1c/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7ce3ed2d-c6ee-4309-84ae-976519349e1c/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/c6d93c33-a5fc-4750-9ad7-724860eae37e/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/c6d93c33-a5fc-4750-9ad7-724860eae37e/text","body":{},"result":{"value":"1"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"c6d93c33-a5fc-4750-9ad7-724860eae37e"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"88952bf6-9cd6-4040-bcc5-02dfe4e11dfa"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/88952bf6-9cd6-4040-bcc5-02dfe4e11dfa/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/88952bf6-9cd6-4040-bcc5-02dfe4e11dfa/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"230ad796-8c9e-48f1-8807-6672ced548a0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/230ad796-8c9e-48f1-8807-6672ced548a0/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/230ad796-8c9e-48f1-8807-6672ced548a0/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f7747a52-e092-4169-bf98-cec7a4481dba"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f7747a52-e092-4169-bf98-cec7a4481dba/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f7747a52-e092-4169-bf98-cec7a4481dba/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/2d736376-8f7b-48c7-a8aa-2feeb90554db/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/2d736376-8f7b-48c7-a8aa-2feeb90554db/text","body":{},"result":{"value":"1"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"2d736376-8f7b-48c7-a8aa-2feeb90554db"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9bffc254-7b02-40fe-8418-5d9127914039"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"196ec00b-9a46-411c-a465-af7e657b92af"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9bffc254-7b02-40fe-8418-5d9127914039"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/value","body":{"text":"Jane"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9bffc254-7b02-40fe-8418-5d9127914039/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/value","body":{"text":"Doe"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/79d7cab0-bbd3-47cc-a947-b2f0e2a35ac0/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"196ec00b-9a46-411c-a465-af7e657b92af"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/clear","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/clear","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/value","body":{"text":"90210"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/196ec00b-9a46-411c-a465-af7e657b92af/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"ba34c538-d7d8-472b-ad1d-50ef68b08582"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/ba34c538-d7d8-472b-ad1d-50ef68b08582/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/ba34c538-d7d8-472b-ad1d-50ef68b08582/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"01cbc2f8-4a6b-4612-9da8-ab6da7180d50"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3af51dbe-7391-4123-9cdc-7df9eaf3543a"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3af51dbe-7391-4123-9cdc-7df9eaf3543a/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3af51dbe-7391-4123-9cdc-7df9eaf3543a/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-test=\"finish\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b254a4f3-9d07-4c40-9b87-ca4d394bb401"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b254a4f3-9d07-4c40-9b87-ca4d394bb401/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b254a4f3-9d07-4c40-9b87-ca4d394bb401/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-complete.html"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f43ec3c0-583a-42c6-bf6d-70fc609ee0aa"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/f43ec3c0-583a-42c6-bf6d-70fc609ee0aa/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/f43ec3c0-583a-42c6-bf6d-70fc609ee0aa/text","body":{},"result":{"value":"CHECKOUT: COMPLETE!"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fa1df062-5b81-4642-b1a6-bc041fc93ed8"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h2"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fa1df062-5b81-4642-b1a6-bc041fc93ed8"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/fa1df062-5b81-4642-b1a6-bc041fc93ed8/text","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/fa1df062-5b81-4642-b1a6-bc041fc93ed8/text","body":{},"result":{"value":"THANK YOU FOR YOUR ORDER"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cfcda905-ab95-498d-8475-7a60ebb43ba4"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfcda905-ab95-498d-8475-7a60ebb43ba4/click","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"css selector\",\"selector\":\".shopping_cart_badge\"}\n  (Session info: chrome=98.0.4758.82)","stacktrace":"Backtrace:\n\tOrdinal0 [0x006EFDC3+2555331]\n\tOrdinal0 [0x006877F1+2127857]\n\tOrdinal0 [0x00582E08+1060360]\n\tOrdinal0 [0x005AE49E+1238174]\n\tOrdinal0 [0x005AE69B+1238683]\n\tOrdinal0 [0x005D9252+1413714]\n\tOrdinal0 [0x005C7B54+1342292]\n\tOrdinal0 [0x005D75FA+1406458]\n\tOrdinal0 [0x005C7976+1341814]\n\tOrdinal0 [0x005A36B6+1193654]\n\tOrdinal0 [0x005A4546+1197382]\n\tGetHandleVerifier [0x00889622+1619522]\n\tGetHandleVerifier [0x0093882C+2336844]\n\tGetHandleVerifier [0x007823E1+541697]\n\tGetHandleVerifier [0x00781443+537699]\n\tOrdinal0 [0x0068D18E+2150798]\n\tOrdinal0 [0x00691518+2168088]\n\tOrdinal0 [0x00691660+2168416]\n\tOrdinal0 [0x0069B330+2208560]\n\tBaseThreadInitThunk [0x7777FA29+25]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A9E+286]\n\tRtlGetAppContainerNamedObjectPath [0x77DE7A6E+238]\n"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cfcda905-ab95-498d-8475-7a60ebb43ba4/click","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041"}},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":true},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"2bc48259-d986-4d48-ad7f-c555acf4f041","ELEMENT":"2bc48259-d986-4d48-ad7f-c555acf4f041"}]},"result":{"value":false},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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jhz/hXxbSlYwrySUo9l41VFA2sD/i7O/RHHvm6za34T3SwfbnnUEaYSFrBUbeWZO4AV1R3v+SOlyOan2AtE5WGeP/P27s+2k7f8VDV4XDlc+WY/ERLhFkRWp+xSKm9+XrewqeJxdoXx1/kaOLksZ4/lERERERERERETk2+7WnpEAgJmswmVkmABvK3sPRnLhZTMzFmzkN2XbWJtvJW1qDKZrn0VxhyWF7PyVlOzfyYZsyzDHuZncuI72L0R8d24OyaHsEvsg9of6/9rw4QkujFvbIuVG3advQ1+KiIiIiIiIiIiIDPU//vznP//5ZjdCRERERERERERERETC19PTA0BDQ0PEj52W1l8/5zaYkSAiIiIiIiIiIiIiIuNFiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQlKiQQREREREREREREREQnqL292A4zm2R+/2U0QEZFxdNTx/s1uggDQTfUrz/DaqV5i7Rs5UJSCKdhX+1rZV7ieissx2DcXszzNfCMbOgG4cbywgt1nbLzqKCD1tj1nGNxOVheU0jJ/Ix8vS7nZrRl3jXseZ92RJJaXbsFugQl/f3racDg6yFhkJS7snW/etfn3863iBvVZgN/drfBs3vT7eqPfV31u6kprMRXZJ0T/i4iIiESKZiSIiIh8K8WQvTyfZBN0OXZQdib4N9s/2EPFZYidv5Il37okgsitpondS9eyu95zsxsi8i3UjePlFWx0uG92Q0REREQibsLNSBAREZEbxGJjzZMneLqklYq9Dn6yzU7cJMN3zley+XAHTLGxNj8FpRFEACzY33gf+81uRjDem90AGRcWG9sdtpvdirClLnufj5fdxAbc0H7zQt8NOpWIiIjIDTbh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BBERERERERERERERuagUSBARERERERERERERkXEpkCAiIiIiIiIiIiIiIuNSIEFERERERERERERERMalQIKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4FEgQEREREREREREREZFxKZAgIiIiIiIiIiIiIiLjUiBBRERERERERERERETGpUCCiIiIiIiIiIiIiIiMS4EEEREREREREREREREZlwIJIiIiIiIiIiIiIiIyLgUSRERERERERERERERkXAokiIiIiIiIiIiIiIjIuBRIEBERERERERERERGRcSmQICIiIiIiIiIiIiIi41IgQURERERERERERERExqVAgoiIiIiIiIiIiIiIjEuBBBERERERERERERERGZcCCSIiIiIiIiIiIiIiMi4FEkREREREREREREREZFwKJIiIiIiIiIiIiIiIyLgUSBARERERERERERERkXEpkCAiIiIiIiIiIiIiIuNSIEFERERERERERERERMalQIKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4Aq7ruhf7IERERERERERERERE5OwNDw9f8NdQRoKIiIiIiIiIiIiIiIxLgQQRERERERERERERERmXAgkiIiIiIiIiIiIiIjIuBRJERERERERERERERGRcCiSIiIiIiIiIiIiIiMi4FEgQEREREREREREREZFxKZAgIiIiIiIiIiIiIiLjUiBBRERERERERERERETGpUCCiIiIiIiIiIiIiIiMS4EEEREREREREREREREZlwIJIiIiIiIiIiIiIiIyrtDFPgARERERkSuF6zi4joOTyeBk0hQyKZxMhkI6jZNJ4dg2TjaLY2dxbRsn5y/ncpDP4+YLuE5xcsB1cB0Xisuuv+z4y67rv7DrrXsrpW3FxZJAwJ8XVwNjV7zJMAgYhvdYwPDXxy4XpyAEQwRCIQwrjGFZBCzLXw4TsCyCkTKMSBlGJEKwLDq6blkEgsEL+EmIiIiIiMhkUiBBRERERARwXRc3n8fN2d6Af3Gw387i2DZuLutvH7PNnzs52/vZfA43l/OX8zj53Oj2fA63UPCC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"},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"81471bde2762ec4a8877f9e61483aab3","cid":"0-6","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T00:48:32.645Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js:38:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-6","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout15-checkoutcomplete-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T00:48:32.666Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\standard_user\\suite-0-0\\0-6\\report.html"}