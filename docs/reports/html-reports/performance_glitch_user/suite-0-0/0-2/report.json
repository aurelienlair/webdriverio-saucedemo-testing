{"info":{"type":"runner","start":"2022-02-18T02:02:17.949Z","_duration":22604,"cid":"0-2","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_1141393607"},"goog:chromeOptions":{"debuggerAddress":"localhost:65188"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"dd52918e6afdd9805e191fa6766449c1"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js"],"sessionId":"dd52918e6afdd9805e191fa6766449c1","isMultiremote":false,"instanceOptions":{"dd52918e6afdd9805e191fa6766449c1":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:02:40.553Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":22604,"start":"2022-02-18T02:02:17.950Z","end":"2022-02-18T02:02:40Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:02:17.958Z","_duration":22462,"tests":[{"type":"test","start":"2022-02-18T02:02:17.959Z","_duration":22443,"uid":"test-00-0","cid":"0-2","title":"TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f33b5e23-3f43-44cb-9dc2-f1850af0aeec"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/clear","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/clear","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/value","body":{"text":"performance_glitch_user"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5bbfdb0b-e104-411f-be44-5882fdf2256e"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/clear","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/clear","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/value","body":{"text":"secret_sauce"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"af7597c0-66da-4f0f-a1c1-675353afc66d"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/af7597c0-66da-4f0f-a1c1-675353afc66d/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/af7597c0-66da-4f0f-a1c1-675353afc66d/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e52e642a-ddfb-4d50-b3b7-655bafebccf2"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e52e642a-ddfb-4d50-b3b7-655bafebccf2/text","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e52e642a-ddfb-4d50-b3b7-655bafebccf2/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"81815f48-f642-4562-8bdd-76be3df6fbdc"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/81815f48-f642-4562-8bdd-76be3df6fbdc/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/81815f48-f642-4562-8bdd-76be3df6fbdc/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b98e0e4-fb44-4317-993f-02331b1f3f07"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b98e0e4-fb44-4317-993f-02331b1f3f07"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9b98e0e4-fb44-4317-993f-02331b1f3f07/text","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9b98e0e4-fb44-4317-993f-02331b1f3f07/text","body":{},"result":{"value":"1"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9b98e0e4-fb44-4317-993f-02331b1f3f07"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23ab76d6-a666-464a-b4b6-da3973d3b7fc"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/23ab76d6-a666-464a-b4b6-da3973d3b7fc/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/23ab76d6-a666-464a-b4b6-da3973d3b7fc/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9193b1e1-3ca9-4376-81cc-1f745fd32068"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9193b1e1-3ca9-4376-81cc-1f745fd32068/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9193b1e1-3ca9-4376-81cc-1f745fd32068/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a1fe4cc-1de9-401f-bc31-086f3283fb32"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a1fe4cc-1de9-401f-bc31-086f3283fb32/text","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a1fe4cc-1de9-401f-bc31-086f3283fb32/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"abd9f838-f9dc-46e1-abf9-1ce37e371347"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/abd9f838-f9dc-46e1-abf9-1ce37e371347/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/abd9f838-f9dc-46e1-abf9-1ce37e371347/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js:29:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:02:40.402Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js:29:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js:29:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:02:17.959Z","_duration":22443,"uid":"test-00-0","cid":"0-2","title":"TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_11: (TestCase_2 modified) should be able to add one item to cart, logout on CheckoutStep1, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f33b5e23-3f43-44cb-9dc2-f1850af0aeec"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/clear","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/clear","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/value","body":{"text":"performance_glitch_user"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f33b5e23-3f43-44cb-9dc2-f1850af0aeec/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5bbfdb0b-e104-411f-be44-5882fdf2256e"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/clear","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/clear","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/value","body":{"text":"secret_sauce"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5bbfdb0b-e104-411f-be44-5882fdf2256e/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"af7597c0-66da-4f0f-a1c1-675353afc66d"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/af7597c0-66da-4f0f-a1c1-675353afc66d/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/af7597c0-66da-4f0f-a1c1-675353afc66d/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e52e642a-ddfb-4d50-b3b7-655bafebccf2"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e52e642a-ddfb-4d50-b3b7-655bafebccf2/text","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e52e642a-ddfb-4d50-b3b7-655bafebccf2/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"81815f48-f642-4562-8bdd-76be3df6fbdc"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/81815f48-f642-4562-8bdd-76be3df6fbdc/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/81815f48-f642-4562-8bdd-76be3df6fbdc/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b98e0e4-fb44-4317-993f-02331b1f3f07"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9b98e0e4-fb44-4317-993f-02331b1f3f07"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9b98e0e4-fb44-4317-993f-02331b1f3f07/text","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9b98e0e4-fb44-4317-993f-02331b1f3f07/text","body":{},"result":{"value":"1"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9b98e0e4-fb44-4317-993f-02331b1f3f07"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"23ab76d6-a666-464a-b4b6-da3973d3b7fc"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/23ab76d6-a666-464a-b4b6-da3973d3b7fc/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/23ab76d6-a666-464a-b4b6-da3973d3b7fc/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9193b1e1-3ca9-4376-81cc-1f745fd32068"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9193b1e1-3ca9-4376-81cc-1f745fd32068/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9193b1e1-3ca9-4376-81cc-1f745fd32068/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8a1fe4cc-1de9-401f-bc31-086f3283fb32"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/8a1fe4cc-1de9-401f-bc31-086f3283fb32/text","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/8a1fe4cc-1de9-401f-bc31-086f3283fb32/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"abd9f838-f9dc-46e1-abf9-1ce37e371347"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/abd9f838-f9dc-46e1-abf9-1ce37e371347/click","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/abd9f838-f9dc-46e1-abf9-1ce37e371347/click","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":true},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14","ELEMENT":"5c2f63fd-54ce-41ec-89b8-dccc5caf9e14"}]},"result":{"value":false},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"dd52918e6afdd9805e191fa6766449c1","cid":"0-2","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js:29:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:02:40.402Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js:29:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js:29:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-2","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout11-checkout1-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T02:02:40.425Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-2\\report.html"}