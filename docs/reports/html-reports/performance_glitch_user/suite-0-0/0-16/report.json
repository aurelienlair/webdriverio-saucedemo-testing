{"info":{"type":"runner","start":"2022-02-18T02:02:54.036Z","_duration":23220,"cid":"0-16","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_107129883"},"goog:chromeOptions":{"debuggerAddress":"localhost:65463"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"d69349c807b676eea812c065957532b1"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js"],"sessionId":"d69349c807b676eea812c065957532b1","isMultiremote":false,"instanceOptions":{"d69349c807b676eea812c065957532b1":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:03:17.256Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":23220,"start":"2022-02-18T02:02:54.037Z","end":"2022-02-18T02:03:17Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:02:54.044Z","_duration":23098,"tests":[{"type":"test","start":"2022-02-18T02:02:54.045Z","_duration":23072,"uid":"test-00-0","cid":"0-16","title":"TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"dfadbbaa-c503-42f3-88cc-e1abf07601bb"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/clear","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/clear","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/value","body":{"text":"performance_glitch_user"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a1949654-85f1-492c-ac3b-7d81dd7e9d3d"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/clear","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/clear","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/value","body":{"text":"secret_sauce"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd518236-56df-4eea-85d6-66cec370c2e9"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd518236-56df-4eea-85d6-66cec370c2e9/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd518236-56df-4eea-85d6-66cec370c2e9/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f97686d3-953b-469a-ad4f-5e18221b5d3d"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f97686d3-953b-469a-ad4f-5e18221b5d3d/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f97686d3-953b-469a-ad4f-5e18221b5d3d/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"result":{"value":"1"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"result":{"value":"1"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c83a4fe-bcd5-43ce-9b0e-7c995e99d4d8"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7c83a4fe-bcd5-43ce-9b0e-7c995e99d4d8/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7c83a4fe-bcd5-43ce-9b0e-7c995e99d4d8/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"913fb1b5-7c1e-46b1-93c3-f2784c056df2"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/913fb1b5-7c1e-46b1-93c3-f2784c056df2/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/913fb1b5-7c1e-46b1-93c3-f2784c056df2/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ee4b6e5-c514-47f0-87c6-f00837b45105"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ee4b6e5-c514-47f0-87c6-f00837b45105"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0ee4b6e5-c514-47f0-87c6-f00837b45105/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0ee4b6e5-c514-47f0-87c6-f00837b45105/text","body":{},"result":{"value":"1"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0ee4b6e5-c514-47f0-87c6-f00837b45105"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"aa763326-e1fd-48e7-8b46-418a81ae95ad"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/aa763326-e1fd-48e7-8b46-418a81ae95ad/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/aa763326-e1fd-48e7-8b46-418a81ae95ad/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"iVBORw0KGgoAAAANSUhEUgAABhIAAANUCAYAAABWkrf4AAAAAXNSR0IArs4c6QAAIABJREFUeJzs3X101PWd//2XIRlCbgYCGiCD8LO2mLG0m9YlKQu2F0ls0D1RAq0/bUtiL1Z+6wLuoXcQFGulErx6w/lJUC8sV01Yb44tCTXnUrKGcG0NPzdhW7MuOkDX5QcyAlFImNwQJjdcfwwzzEzmO3eZJEN4Ps7hOJn5fj/fT2YSD3xe38/7fcPly5cvCwAAAAAAAAAAXHMcDseIXyNhxK8AAAAAAAAAAACuWQQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAXCfeeOONiM8hSAAAAAAAAAAA4DrgDhEiDRMIEgAAAAAAAAAAGOf8w4NIwgSCBAAAAAAAAAAAxjGj0CDcMIEgAQAAAAAAAACAcSpUWBBOmECQAAAAAAAAAADAOBTujoNQx91w+fLly7GYEAAAAAAAAAAAGF0Oh2PEr8GOBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIChxLGeAAAAAAAAAAAAGJ7W1taYj5mTkyOJHQkAAAAAAAAAACAIggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAARKTrld1xORYAAAAAAABGBs2WAQBhc7ywXRd+uVWSlPadFcMaq+uV3Wp/YoMGHR0y//3aWEwPAAAAAAAgbBf/+S31HnxHfR+8r/4TJzRwoUOSNGHyFCXOmaOkL35ZyQvv1KRv3j3GMx17N1y+fPnyWE8CABD/vEMEScp4amvUYYI7RHCb/KMNhAkAAAAAAGDEDXY61Pni8+p+9Z800H4+rHMmZExV6oPfU/rDjygh3TzCM4ycw+GQJLW2tsZ87JycHEmUNgIAhCntew9p4vw8z9ftT2yIqjSRf4gwcX6e0r73UEzmCAAAAAAAYKT7d6/pTP5COZ57NuwQQZIG2s/L8dyzOpO/UN2/e20EZxi/2JEAAAjbYFenPnu4TJcONXuei2RnQqAQ4cYXq5SQlh7zuQIIn9Nm08X9++U8YlO/3S6nzebzeqLFokSLRcm5eUqyWpVSUDBGMwUAAACA6LT/dKO6Xq6KyVhp3y1Txs+2xGSsWBiNHQkECQCAiEQbJhAiAPGl325XZ3WVumprNXjlL52RSCtZptSSEiXn5o7A7AAAAAAgds6tW62eur0xHTOleKmmbdsR0zGjRWkjAEDcSUhL140vVkVU5ogQAYgf/Xa7zpWXy16QL0dVVVQhgiT1NLythHTX7/CgwxH1OAAAAAAwktp/ujHmIYIk9dTtVftPN8Z83HhFkAAAiFgkYQIhAhA/LlRW6nTJUnXV1gxrnIT0dE2v3i2T1SpJclRXyV5YoJ6GhhjMEgAAAABio/t3r8WsnFEgXS9XXTc9EyhtBACIWqgyR4QIQHwYdDj06ZrV6m1pMTzGlJ2t1JJlnnDAlJ2tBLNZgw6HzpaVevom+IcIgw6H7IUFnh0J5rIyZZRfP3flAAAAAIhPg50OnclfGFFTZUlKfvr/043/fbouPW3Vp78NffyEjKma0XhQCenmKGc6fKNR2igx5iMDAK4b7p0J3mGCd3BAiACMPafNpk/XrFa/3T7ktcSsLE1eu1YpBYVKMAf+S297RYVhiCC5diN4lzVylUvq1LSKihh/JwAAAAAQvs4Xn484REgsrtSUpV/QDQq/dOtA+3l1vvi8Jv9gfaRTvKawIwEAMGyBdiZ4I0QAxobTZtPZstIh/QsS0tOVXlYmc2mZJ0AYdDjU07hfA6fs6m1x/S4PdnYGDBF6W1qUnJurfrtd9oL8gNdOK1lGmAAAAABgzHwy/0sRBQmmNbt14yP5mjBRkhzqDXNHguTalZB16D+immcssCMBAHBNCLQzwY0QARgb7nJG/iGCKTtbN+14TokWiySpt6VFndVVQfsbeIcI58rLNXnNGknShe3bDc/pqq3RxNz5SitZNvxvJginzSbn0SMaOHV1x8XEvFyZbss23GWB2Bh0OOQ8ekT9dvuQ9z8xy+L5GcPY6j10taQZvxcAACBeXGp5N6zjJuYuiGr8i//8VvghwpwSTXn6J0r72mzdMNCmAUemJkT4V6aB9vO6+M9vadI37458stcIggQAQEwkpKVr0jfvHhIkTPrm3YQIwBgIVM4opaBA0yq2KsFsVr/drvaKLSEbJPuHCDekpynRYlG/3a6uvbVBzz1XXi5TttWnFFIsDDoc6qyuHlJWyaPS9Z+UwkKll5YpOTc36Hg9DQ36dM1qn+fSlpZo2tatIedydsUKn4XalIIC3bTjuZDnnd/ytDqrq32em1ZREVXwYi/IH/JZp5eWaurGxyIeK5RBh0Pde/eqp+Ft454bV97/RItFKYWFSl1aEvXPwPktT6vvyBElZWePyPdjxDuEm1axddihyNnSFWEdl2A2Kzk3T6lLlw5rwb9rb606q6o8O4q8maxWpRQUKr20lFABAACMmbbvfCus4zJf/r0m5kUeJvQefCf8gx/5R6V/bbZ06aQubvnvGix9V6lR/DWp9+A7BAkAAITS9cpudTz95JDnO55+UjdMTPY0YAYw8joqtw9Z5PVe4O5taQm4W8Gff4jQ0/C2LPsbJQXfjeDt3MZyzazdG8V3EViwng/+ehoa1NPQoOTc3KCLwYGCBufRI2HNxztEcH19KKzz+mxDx0/OzQvrXG9Omy3ge3Fx/34pxgvvXXtrdWH79rDee0nqt9vlqKqSo6oq5GdgpM92xPUej2IxVqfN5hOwddXWaMqatcMaM1ijc389DQ3qqNyuKWvWKr20NKLrOG02ndtYHjBA8D7GabPJUV0lc2mZZ4cRAABAPLr49r6ogoS+D94P/+ABh/r/9f/WhceeUs8JaWpkfwWL7prXIIIEAMCwdb2y26exsumrf60bJF36879Jutp0mTABGHn9dvuQO91N2dmaVuG6u76rtkbnystDjuMfInTV1mjymjVKMJvltNlC7kZwc9ps6qqtiUmJI6OeD6H0trSofcvThjsFEsxmmbKz5TxydXHfabNp0OEIesd2T4DdHIMOh6eHRNA5+QUQiVlZUd313llVFfD5frs9rHmEY9DhUHtFhbpqa6Ieo7elRfaC/Kh3XYwm//e0u7Z22EGCW/L8XE3MC/yZDDocnuBk0OHQ+S1Py2mzhd1rxP/3IzErS6nLlvkEVL0tzbrY0CDnkSMadDjUUbldkwoKYr5rCAAAIJRgJYsGOy+oz/ahJKm3ObwSSP76T5wI/+DH7tXpqK4yjGtegwgSAADD4h8iuHsiSPLpmUCYAIyOC9u3+yy0J6Sn66YdzynBbFZvS0vEIcL5LU+rq7ZGCenpMpeWSZLaK7ZENqfKypgsHp/bWB5xiOCWXvZQ0Ncn5ub6BAmSa/E7pbDQ8Bx3U+pAzwdbwA90d3o0uxEkqadxv+Fr3TU1ww4SBh0OnS0rDXqHu5t/GBNIQnr8l9Jxv6fppaXqrK6OaSgzMS83ZCjR29KiT1f/gwY7O9VVW6PUkpKwrt1escXz+2FUmis513V9d7iWkG4mRAAAAGMi85XfB33948+7brLps32g/lMfK3HWzRGNP3ChI+q5RWssrjmaEsZ6AgCAa5dRiJCQlu5pwDxx/tXFsfYnNqjrld1jMVXguhCob0F6WZmnp4F/HwAjGRs3ymS1qqu2xrO7Ib2szBNGRFKmxTOvYdzNLrnu/g+0mD15zRrd3HJIc44c1ZwjR3VzyyHdVLlDyfOvLrymFBSEXIgNtJDvPBJ88fySQRmjS83B359AAYTRXerB9DQ0+AQriVlZvq8HCRnCZVQmJyE9XemlpZpevdvz3s/c+wefzyBtaYnPOSkFBUGDmXjQ4/Wemsse8ryn3TXD+/mNRHJurs/umXCu7f17mVJQELK/R3JurqZX79ZNO3YMb7IAAAAjZFJhkefxpSh3JSC2CBIAAFEJFiK4ESYAo8tR9ZLP14lZWZ5dBOfKN4R1N7+79Ix3CaTErCzPXdQXKsPrjeDPv9xSpLoDBBGT16zRlDVrfcoPJZjNSiks1PTduzW9ercSs7KUEUavgEBBQ7BAYNDhMLxL379sUTjjphREvsB+0a+00qTCQp8wYdDhCNlMO5iOyu0Bz08pKJBlf6Ombnws4Pvm/gymbd0qy/5GpRQUKDEry1NeK565f87cpaYmXQk+ehr3R70bJhrJubkyZWd7rh2KdzgVzs+75PqcaLYMAADilXdfhItv74v4/AmTp8RyOnF7zdFEaSMAQMTCCRHc3GECZY6AkXdxv++C4+S1ayPaRRAoRHCPI7kWpifm5mpimCVeLlRWeh67mwJH0wfAde3OIc+FKpeUnJsrS+OBsMYP1CchWCAQ6v0MVgrHf1xTdnbEC7qDDseQ3SfJuXm67Oj0eb67tiaqXQCDDkfA8MeoZI6RRItFN+14Tv12e9wvWg86HOq58juUusz1s5VWskyd1dVXXmsY1f4OiRaLp5dBKH1eoVa0v2MAAADxZNJdS9Tx9JOSpEstke9ISJwzRwPt52M9rZDXHM8IEgAAEYkkRHAjTABGnnuh3pv7LvdOv50KgRiFCIlZWZ7F0wSzOaKms+6mrm49DQ0yl5WFfX4oCenG/9+JhlGfhECBgP9ugMSsLPV/8onXeYH7JAQKIMINZrz17A+wU6CwUIOdvgFDz/79IZtGB+KorhqygG3Kzo4oRPB2LSxud9Vefd/cP/Mmq9Xz2XbX1o5qkBAoPDMywev9jebzBgAAiDeJs25WomWW+u2nNOhw6FLzuz67FNyMQoaEmzJHeopDJH3xy6N+zdFEaSMAQNiiCRHcKHMEjCz/BWr3Xe7ed1kbMQoRJCnlrrvUe6gloj/uQGOS353wfWE07DWSYB76/5n2ioqoxwskYJ+EMMsXue9gd/PfHeI5L0B/hGgaLfsHGSkFBVf+O3T3QaDQIZTu2tohz4VbMuda1X0lgDFlZ/sEH+5G3b0tLUPCupHU/4nrWt79Pox4N0x2VFeN2JwAAABG06S7lngeG5U3avvOtwL+ufh2/WhN0yN54Z2jfs3RRJAAAAjLcEIEN8IEYORc8lugTr1y53SoReRgIYIkOaqqdHbFioj+uHs1+C+QO48eGTJ+uPxDCUnqqq3Rp2tWx2xxN2CfhAAL//12+5Br+t+p7rTZApakCRSmhGoEHej6/uGQ+/1JMJs9oYJboFAgmEC7W0zZ2RHP81ritNk8oVG6364Z79JQPcPoOREJR1WV5zNIXVYS4mhXgOTeoXOhsnLYzc0BAADigfcOhN4oGi7fEMvJhDAhY6omffPuUbzi6CNIAACEJfkbi5U019X4MZoQwc0/TEiam63kbyyO6VyB65F/GRT3HcrBGgaHChGi1WdzBQbuZrFuRnf3hyOtZNmQ8STXwq69IF/nysuHHSi4+yR46z10aMhx/rsKkufnKtFi8Wl07Dpu6HvvP140/RF6AjZAvrrY7R+6RHonfazKL11LvBfe/Xd1JFosnl0BnaNwt39ndbUu7HD1FzFlZ4fViDvBbPZpZn2uvDymIRsAAMBYmJj3N57HfbYP1H/q46HH5C4w/JOQNXrlNVMf/N6oXWus0CMBABCWRMss3fhilc7/6NGoQwQ3754JU3/5rBIts2I4U+D6ZNQY2Ggh0R0iOG02ddfUhlU+JRjnEZsGO11hhnvnQazrtN+04zmdXnqf5zreumpr1FVbo+TcXKUuW6a0paHv4g7Ev0/CoMMxpEm0fzgzMc/13iXn5vn0J+htafa5mz3QLoVAOy1C6fZrspxSUODzXqcUFOqcfIOhngj6Uwx2Dt1JMd7/P+0uRZW2tCTgz23qshJP2S6nzeZTSigSl1pafJqQe3MesfnsBjFlZ2t69e6wf49SCgt1U+UOnSvfoMHOTvU0NKinwdUgOrWkZFzvKAEAAONTgtmsibkLPH0QLjW/q8RZN/sck/nK7w3PH+x06Ez+woibLp8vsiiSMyZkTFX6w49EdI1rEUECACBs7jBhOCGCmztMiMVYAIYKdPe+mztEkFw7F6bvHl55sa7aGvWWX11cD1TSJxYSLRZZ9jfq09WrDYOT3pYW9ba06ML27coo3+izkB+O5Nw8dVZX+43Z7FO6qKdx/5BzJFeg4B0kXPLbfRDoTv9I+yO4F7K9+YcR7vJG3uWPuvfWhh8kBPj8Ilk4d9psaq/YEvSY6dXxU9Kup6HBsK+Hm3c401lVFXXTaffPZygJZrMyNj4WcRiXUlio5NxGtW/Z4vlZdIdsJqtV6WVlUYdsAAAAY2HSXUWeIOHi2/uUuvz+sM9NSDdr8k8e0/nyH47U9CRJk3/ymBLSY3sTVTwiSAAARCSWC/+ECMDIcS9AOo/4Ljp7hwixEKgskn+Jn1hKMJs1ffduddXW6ML27er/5JOAx/Xb7fp0zWqllSxTRnl52AuyAfskNLd43jP/XQUJ6emec4b0hLhyrPvagfotRHqXeKDa94FK30wqLPQJEtx3unvvrIhEJOHQYGdnWIvl8cLduDoxK8sweEowm5W2tERde2vV07hf06K8VvL8XM8OFn99NpsGHZ3qPdSiQYdDZ0tXeHYZRCLBbNa0rVs1ee1aOapeUndtrQY7O+W02XRuwwZd2L5d0yq2skMBAABcE5K/drW8kTtQiETqtx+Q8/D76np5ZEpUpn23TKnffmBExo43BAkAAADjmCnb6rl7P8FsVndtbcTNd/1llG+UyWo17K3gLoMzkvXZ00qWKa1kmXoaGtRZVWW4Q6GrtkbOIzbNrN0b1rgJZrOS5+f6jOfdJNp/gdx7MTbRYpEpO9unNFJvS4tncdq/P0I05aT8Pzv/skZXnx9a3shR9ZKmbnws5DUCjec8Yot4d8e1YNDh8Ny5H6rM1KTCQnXtrXWdU1sTVSA3MS9XU9asDTkn946CnoYGnSsv17SKioivlWixaOrGxzRlzVp11daqs+ol9X/yifrtdp0tXaG0kmVRjQsAADCakqxfVKJllvrtpzTocKjP9oGSrF+MaIyMn23RoOOCeurC+zdBuFKKlyrjZ8F34o4nBAkAAADjgP8CdqA67oMOx7DvFJ9WURE0RJCkBLNrt5F/kDASOxVSCguVUlgop82mzqoqn9JCbk6bTR2V20Mu4LpNzPMLErx2FvjvKpjotwvBv8fCxYYGpRQWqt9uH3JXv9Gd6Ua86+e7DXZ2GtbcT7RYfI6/uH+/FEaQEMjAqfHZtLdn/9XG1Zc7uwzfS38Xr/QeGAnuHQWS1LW3Vl21NcPqcZBgNstcViZzWZkcVVW6ULldg52dnt0thAkAACDeTcxboP6a30mSet7ep8kRBgmSNG3bDiWYJ8dsZ0Lad8uuqxBBIkgAAAAYF/xrcvbb7TJZrUMWxYfDXRYpWIggXV1c77ef8nl+JBv2mqxWTdu6VellZTpXvsFnMV+SOqurww4SknPzdEG+C8runQVDdhX4Le7691hwv/e9AcsaRdYfIVBZo3Br7ksKu1FwSkHhkAX1SMr5JFosmrxmjefrgVP2gAFPPPD+rAK9v0Z69u/3KVs1EjI2bvS8b51VL8WkFJG5rEzJubk6W7rCEybQiBkAAMS7SXctUfeVIOHi2/Wa/Gh0PQ8yfrZFpnlf1oX/6+mIGzC7TciYqsk/eey6KWfkjSABAABgHPAPDHpbmpVSWKi0kmURL1j3tjQPWUgON0SQ5CmB46497z3HkWayWjW9erdOL73Pp3+CezdGOAumgY5xHrEpwWwe0h/Bf1He/9x+u139drsuNfsu9nv3VghX997hb8UOp1GwyWpVYlbWkPcv3HI+iRaLT2jT29ISl0GCd+NqU3Z22A3y3L9nXbXhN7COhneZLf8AazhMVqtu2vGczpaukBS7kAIAAGCkTMy72iehz/bBsG7oSP32A5q05B51vvi8ul/9p7ADhQkZU5X64PeU/vAj10Vj5UAIEgAAAMYBU7bvgra7jE2ixRJxg932Ct8tupGECKbsbM/1vJv9SpHfgR+tBLNZqcuWDQlDXDskwlsw9e+T4B8ESIEDhwSzOUCfhOYhu0IiXbjtaWiIqOGx4Thh7ixIzs0bsvjfXlGhlILCEb0LfzQ5ql7yPL5px3Nh/57Y8xer/5NP1L13ZIMESUqyZnuaL8dScm6u5+c0liEFAADASEgwmzUxd4Gn2fLFt/cpdfn90Y+XbtbkH6zX5B+s18V/fku9B99R3wfvy/n+v+vy4KDnmKRbb1XSF7+s5IV3atI3747J93ItI0gAAAAYBwLdCd9esSXsu2VSS0qUaLG4mhNfuUtbiixEkKSMKzX4/cvERHMHvj/3roJom/5GUlppSJ+Eo0c8vR/cjJrzTios9AkS3LsSfMaPMFTx390hSTdV7gi5qN/T8LZP+Z5Bh0M9V/o2BDN57dohQcKgw6GzZaWaXlUdUZjg/fMUTy5eCbq8w69wuEMqp80WVqmo4RgYwYbl7v83xDqkAAAAGAmT7iryBAmXmv/XsIIEn3G/ebcmffNu9Z/6WKf/j69Jcv3bxfJefP4ddiwRJAAAAIwDCWazUgoKfHYBOKrCaySWmJXlqWnvfRd/pCFC8vxcT1jgvxsgpSC6xX9v7RUV6qqtUUphoaZtqTBczB50ONRdO7SUTkJ6eoCjA/PvkzDocPiU+nEfE865gRr4RhKqDDoc6mn03d1hys4OK1BJtFh8ggTpagPoUOell5YOOddps+lsWaluqtwRcvF90OHQhR2VYf8cjqbelhZPuJMe4a6CtJKru126ams01RpdA+twuAOpSH52IzWSYwMAAMRK8teulje62FAf8/Evvr3P89i7lBKuShjrCQAAACA2jO6QD2Xa1mckuRZF3YurkYYICenpyti4ccg4bpPXhtfo2EhXbY1nl0NPQ4PshQU6V14+pGRQb0uLzpaVDrl+YlZWRHeOB+yT4HVnfWJWluFCeqiQIFBvhWB69g8ta5QaRq8CyRUImLKzfZ7r2lsb1l3oU9asHXKu5Hof7AX5Ad9/9+vtFVtkLyyIyxBBkrprru6YiTTk8n5PY9G3woh32BFqjoMOR8DAyki/3e757OiPAAAArgVJ1i96dhgPOhzqs30Q0/EvNb/reTzpriUxHXu8IEgAAAAYJ9JKlikxKyuicwLtIog0RHCds1Umq1WDDofaKyqGXCPSPg3eXGWafMd0N/89u2KFTmTf5vlztnRFwFI66WUPRXzd5PnGC6yh+j0EPzeyhdtAZY0iKe8UKHTo2T90TH8JZrNu2vGc4R3r3u//x7nzZS/I14ns23S6ZKkcVVVxWzLHe4dHSkFBVD0f3LsY3KWiYs1ps+nTNas9X4cK4s5tLFdH5XadLlkaspTUoMPhM3Y0vxsAAABjYWLeAs/jHq8dBLHgvcvB+zq4itJGAAAA48jktWvDXvx3Hy9JHZXb1W+3K720VGkly67cVV4R4myXaRUVnoXts2WlQxaQp23dGvZ8AklIT1fy/PlDmjeHK3l+blRNcf37JPi/FsykwkLDcyPZOTLocAz5viOt6Z9SWDikgfbFhgalhbGrIdFi0cy9f9Cnq//Bp+9DoHkaBQcJ6eka7OwMe74Bx+/qNHw/jRiFOd47PMLd2eEvpaBQ5+T6PQunVJTbgP2ToN/HoKNTFxsafHqMTKuoCPp5Dzoc6j91SpIrgDhdslQphYVKLVnm87PiDlAubN/utdOhgB0JAADgmjHpriXqrvmdJOni2/Wa/OgPYzKud1mjJOvtSpx1c0zGHW8IEgAAAMaRtJJl6q6pDWvR1b0bYdDhUGd1tdKWlmjqxsc8dfBD3VGekJ6uaRVbPYuo58rLh9wNPXnNmmHtRpCu3hnvqKrShcrtES1KpxQUaFpFdEGGf68D33GDLxwHW5wNtZvBW6CdA5EufrtL8XgHAT3792vQ4QjrbvxEi0XTq3ero3L7kJ4JoSTPz9W0rVtlL8iP6Dx/TptNZ1esiOicOUeOBnze3T8jIT096sbdCWaz0paWqGtvrbr21ipj48aw3kvvEl0hr3GlXFiowCfBbB7y+fQ0NITcKZE8Pzfq3w0AAICx4N27oM/2Qdh/nw3Fu6xRMv0RDFHaCAAAYJyZtnVrWA1U3bsRHNVVSskv0LStW8MOEZLn52p69W6lFBZq0OHQufLyIQukpuxsTVkzvN4I3sxlZbLsb1RG+caQJZwSs7I0raLCVZonyn9cGIUBpuzskGOarNaAn0Gw3gqBBFq4j2bxO1D40BWgIbWRBLNZUzc+Jsv+RqWXloZ8/1MKCnRT5Q5N37172EFSLPXb7eptcYVsw20A7r2zJJxSUeFKnp+rjPKNsuxvDGvXiOT7+aQtLQn6++/+3Zi+e3dM/uENAAAwWhLMZiVZb/d8fTFG5Y28yxrRH8HYDZcvX7481pMAAABAbIXqb5C2tETTtm7VoMOhjsrtYe9ESCkoUHrZQ55F9kGHQ2fLSofsREhIT9fMvX8Y0UXkQYdDziNH1NvS7HnOlG2VyWqNq8Xr8cpps2mws9Pn/U/OzQsraMHIc9psch6xecoYuXamWCNq9A0AABBvLjz7Kzme/bUkVy+DWOwguPDsryS5/g1jec+4nGc8c1z5N1xra2vMx87JyZFEkAAAADBudVRu9zRQ9mfZ36hEi0X9drsSLZYhIYIpO1sJ6a7F4Il5rmbJKQWFPgvEndXV6qjcPiR4SEhP1/Tq3SxYAgAAAIipPtsHOlP8zREZe1JhkW584f8ZkbFH2mgECfRIAAAAGKemrFnr6X/gLW1pieeO/UAhgnu3QiCBGrZ6I0QAAAAAMFKSrF9UQnp6RH3TwkVZo+AIEgAAAMaAB9H0AAAgAElEQVSxqRsfk8lq9Slz5O6NIGnoTgSr1fP6oMMh51HX1t4+2xH1NLztqS8fiCk7WzfteI6yQgAAAABGzJTHn1K//eOYjzsxb0HMxxxPKG0EAABwHehtadG5Des1qbBQUzc+JmloiDAck9esiWljZQAAAABAeChtBAAAgJhIzs3VzL1/8HwdqxAhbWmJJq9dyy4EAAAAABjHCBIAAACuE96NkiUpJb9APfsbIq4vmpCertSSEpnLHiJAAAAAADDqLv3pkC4d+ldNyJyh1PuWSRMmRDxGb9O/6FLre0q65XNK+dt7R2CW4wuljQAAAK5zvS0t6m1pVp/Npn67Xc4jR3xeN2VnK9FiUZLVquTcPCXn5o7RTAEAAABc7xzP/loXnv2V5+ukz8/VTS//ThOm3Rj2GOef2KDuV3Z7vp6Yu0CZr/w+pvMcTaNR2oggAQAAAAAAAAAQ9wbPfSZ73l8Ned78P1Zr8o83hjWG8z/+XWdL7hnyfMbPtijtu2XDnuNYGI0gISHmIwMAAAAAAAAAEGPOo0cCP/8f/x7+GEc+DPz84f+Iak7XC4IEAAAAAAAAAEDcM92WHfj5Lw3dpWA4RvbtgZ+f96Wo5nS9IEgAAAAAAAAAAMS9hGk3avKjP/R5Lunzc5X2f64KewzTl/5Kqd9Z4fNcct7fXLNljUYLPRIAAAAAAAAAANeMS386pEuH/lUTMmco9b5l0oQJEY/R2/QvutT6npJu+ZxS/vbeEZjl6KHZshfbb76vdX/olmTRw89v0/JZQQ5uq9e6lbtkU5G21q1UTlhXaFPdj9Zox1GpePPrWh3eScZad2nJpnrJew6eeUXGuqpS24ozvcYM11yt3vVzFWf6z0kK632UpFN1WvXIbp2UJKP3c6BbJw/W69X6Rh060qYupyQlKS1zlqwL8rX83iLlZPqfBAAAAAAAAAAYLpotu/U26423uiVTkkyy69V9x8Z6RuOAXfUt9pBHnWyqvxIiGPisWdtWrdKqX7ymA++7QwRJ6lNX23Ed+sMubVj5XW2oC30tAAAAAAAAAED8SRzrCYTD+W/NOuCU0u7J1/w363XgrX06+L25Wpg81jOLUGaRttUVDXn6TN3jemjnMem2lXrpl0WaEXKgSHZaBGBKksnZp5ONf9bJZRbNNjzQroONbcbjDNj16pO/Un2bZPpckdb9Y7EWzsmU6cpOImfbcR3c+4K21R1X687HtS2rUuvuSI121gAAAAAAAACAMXAN7Ejo0IH6JklJWrzgAS1anCQ5m1TX1DHWE7t23ZKnhXMknajXwRNBjjvaqD2npRlfXyRroNf/s1F7Tkgy52vTlpVa/LmrIYIkmTJv0eJVz+iZZVMkdav+1SadieX3AQAAAAAAAAAYcfEfJJx6R3taJZnytfBLqZq/IE8mSa173wlecgdB3KZF+RZJbap/17jkkO2dRnUpU0ULbgv4evv/Pq4uSZp5i24OstHAuqRYt0oytbWrfTjTBgAAAAAAAACMurgPEk62NOqkpLS771TOBMmUu0TFZkknalT/4VjP7tp1a26+Zks609gcOJAZOKamA93SnCItnBt4jIz/dovSJOn4UdkcQS42s1g76l7XG9UPBN7ZAAAAAAAAAACIW/EdJAwcU/0eu6RUFd15ZTV7wlwtKkyV1K26fc1yBjsfxmblqfg2SacbA5c3Otqseoc0O/+rxj0UPl+ksttdpaaeWblOm15ulO1Ut5wDIzdtAAAAAAAAAMDoiutmy86WfapzSJqzTEVe1XWsdy3T7JrdOnmgXge+n6eijDGb4hip14bi+pBHWVdValtxpsGrmZr/jbnS0WOqf9euB+dYfF5t/Zd96tJclS2ySDoceIgJmSp+4qc6v+lnevUvdh167QUdeu0FSUnK+MI85S7I0+I7vqrb50zx6Z0AAAAAAAAAALh2xPGOhD4dete148BalOd7V/ysO7U8R5IOa88B4xr/CG5G3p2yKkB5o4HDOtjQJ+Xka5FRDuGWOldlv35Zr/7PR1X29XmaYU6S1Kf2v7yn+uoXtOEfV+neB9Zr2x/5nAAAAAAAAADgWhS/OxLa31HdgT5J87RkyGr2FOV+Y57Uelgn9zTKdt8KWa+rO96LtLVupXKGO0xmnpbk7JKttVEHTyzT7Dmup50tjap3Sjnf+KrC3eyR8blFevDHi/SgJPW26aNjh9VS36Q3Wg6rvfe46n+xTi0fPKEXH5nn6qsAAAAAAAAAALgmxG2QcPJAnVolSYe1rfR+bTM60LFPb7Q8IOuCpFGb2/hxNZDZ03hMD35/rq7uBJmnxXdMiW7Y5Ezd+uV83frlfD040K2P3nxBj+9sVvubz+rV/J16+LbQQwAAAAAAAAAA4kOcljay61CjXVKS0jIzNWOmwZ8rZXQOvPmO2sd6yteojDsWKUdSV0OzbJLU+2c1HeiT7sjXwmDbEZzv6cWV39e9xY+r7rMgx01I1a3Fj2rN1yWpQx8ea4vh7AEAAAAAAAAAIy0+dyR82KhXT0gy5evxnSuVY1S26MPd+tb6OnW11qnxVL6WzxrNSY4TGXkquuMFtf6pUU1HV+jWT5t1QNLiwrzgJYhMmUqb0C2njulga4eKC4PtXkhSKvWMAAAAAAAAAOCaFIc7Evp0cN8+dUlKu/tO4xBBkm7P14NzJMmuV/cdG53pjTupmv+Nr0jqVv3/OqxD7zZJWqRFfx2qVJRFC5dYJEmtL1frYLBdCd3v6UCTJCXp8zeH6t4MAAAAAAAAAIgn8Rck9P5ZTQf7JKWq6G/mhjjYovn5rsXsrrf26WDviM9uXEq7407Nl9TV8Ctt+6NkWpyn+cmhz5tdtFLFN0r6rEmb/8caba45rJPdfVcP6G3TR398TZse/aXqHZLp9lItH3aHaAAAAAAAAADAaIq70kbtTfU64JRkztei20MfP3txsXJ++4JanU2qayrVQp8SO/XaUFwf9HzrqkptK/a9S75u0/2qC3bSbSv10i+LNCP09EZI6O/LLdD3N4Q5T0u+Lh36Y7e6lKTFC74qUziDp87T6l/8UM71z6q+rU0Hf/uUDv428KGmLyzTM0+M5XsGAAAAAAAAAIhGnO1IaFPTvsOSpNnL82UN55SMO1X8ddfD1r3v6OSIzW08S9L8BYtcD035KsoNVdbIy415WrfzJb20eaWW595ypQH2FclTdGtusVZvrtQbv35A1tTYzhoAAAAAAAAAMPJuuHz58uWxngQAAAAAAAAAAIicw+GQJLW2tsZ87JwcV636ONuRAAAAAAAAAAAA4glBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMJY71BAAAGEtLiu8f6ykAAAAAAABE7fWXfzPi12BHAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwFDiWE/A35Li+8d6CgCAEbSv7vWxngIAAAAAAAAiwI4EAAAAAAAAAABgiCABAAAAAAAAAAAYirvSRpS8AAAAAAAAAAAgfrAjAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGEsd6AuGy/eb7WveHbkkWPfz8Ni2fFeTgtnqtW7lLNqPXTamaMWeuFi8t1fKFFqVNCHHx9uM60FCn+rcP68PTHXL6jPGA7l14izKMxmjdpSWb6iUVaWvdSuUEvdBh7Sh+SnWaq9W7fq7iTOlM3eN6aOexEBP0d/V8AAAAAAAAAACG49rYkdDbrDfe6pZMSTLJrlf3Rbqw7sfZrTN/eU+v/mKdvvNkvc4MGBw30K3Wl9fr3tL1eqa6Sa2nu2XKzNSMmZmakey8MsZ6PfjAer34p47hzQkAAAAAAAAAgDh0TexIcP5bsw44pbR78jX/zXodeGufDn5vrhYmhzrTYBeAs1snW1/TM8/U66PWau34Y542L57id1C3Wneu04Y3OyRTphY+9KjWFM1VhsnrkPZjqtv5rF5sOq49T67WR49s09Z7YrsNYEbxz7Wv2P/ZNtX9aI12HJWsqyq1ja0HAAAAAAAAAIARcg3sSOjQgfomSUlavOABLVqcJDmbVNc0jB0AplTNzl2p9d+1SOrToX3Navc75MybFXrizQ7JNFerKyu1qdgvRJCkjLkqXl+pnavmyqQ+tT5foVdPRD8tAAAAAAAAAADiTfwHCafe0Z5WSaZ8LfxSquYvyJNJUuved3RymEPP/tw814MB6ZL3C73Nqtp1TE4lafG6chXPDD7OjOJyrf96kiS7qn7TOCSUAAAAAAAAAADgWhX3QcLJlkadlJR2953KmSCZcpeo2CzpRI3qPxzm2P91WJJkypqiqV7Pu0spybxE9y5IDWOkVC28f7lmSFJro5rahjcvAAAAAAAAAADiRXwHCQPHVL/HLilVRXfOdT03Ya4WFaZK6lbdvmY5oxnX2aGP/rhLz7xsl0xz9fCDrl0Obh9+2Ox6kDtP1glhjjlnnhaaJemYPjzWF82sAAAAAAAAAACIO3HdbNnZsk91DklzlqnotqvPW+9aptk1u3XyQL0OfD9PRRlGI9RrQ3G98QVm5mvTz/9eC316FXfo449cQcCt/80SwWynaMZMSQ7pTHu7JBogAwAAAAAAAACufXG8I6FPh9517TiwFuVptvdLs+7U8hxJOqw9B+zRX+J0o57ZuluHPvN+0ikNuB6Zonx3bKeobQQAAAAAAAAAGB/id0dC+zuqO9AnaZ6WLPK/u3+Kcr8xT2o9rJN7GmW7b4VBCaIiba1bqRz/pwf6dOZEs/b8z+dV95c6bfqxU1ufX6mc5NhM3TqL3QgAAAAAAAAAgPEhboOEkwfq1CpJOqxtpfdrm9GBjn16o+UBWRckhT/4hCTN+Nwird6SKueqCtV/Vq+qt4uVU5wpKVM3z02SjvbJ9l92hV+iqENnTrsezcjwqrU0yaQ0SV3hDDHQF13PBwAAAAAAAAAARkicljay61CjXVKS0jIzNWOmwR9zkqQ+HXjzHbVHc5nUr2jxItdD73JEt9+e53rQcli2gTDHOnFYBx2SNFe3z/UKNTIydbMkqU3tjhBjnGvTyTAvBwAAAAAAAADAaIjPHQkfNurVE5JM+Xp850rlBCxbJOnD3frW+jp1tdap8VS+ls+KzeVNf52nxaYmHXDs0yt/LNbmxVNCnNGtQ3vrdEaScvLlU4lpWqZmS7LpmP7zlLT4duNRnMeOyiZJplt0M9WRAAAAAAAAAABxIA53JPTp4L596pKUdvedxiGCJN2erwfnSJJdr+47Fvmleg/rYJProU9fg+Q8la2cK5P6dKjyl9pzKvgwZ+oqtLmhW5JFZX+XrwzvFyfMVc4dktStuqp6nTHa4TDQprq9rsmYFs5TkLwBAAAAAAAAAIBRE39BQu+f1XSwT1Kqiv5mboiDLZqfb5Ekdb21Twd7w7+M89R7enFjheockkxf0b1+DZ1n3FOup+6ZIjmP6cV/XKPNdcfU7h8CtB/XgZ3rtWrnMTmVJOuq8ivBhrdULX6wWBmSnB/u0qof79ahU91yusca6NOZ/2rSiz9epxePStJclT2YJ1P43woAAAAAAAAAACMm7kobtTfV64BTkjlfi8K4LX/24mLl/PYFtTqbVNdUqoWF3mWI6rWhuD74AKZMFW96VIsz/F9IVc4j27Rj+q+07reHdXDn4zq4M0lpmRlKmyCpu11nHH2uQ5Nv0fIN5Xr4DoMSSLet0LYftGlDZbPO/KVOmx6pM5jLLVq+uVzLZ4b+vgEAAAAAAAAAGA1xFiS0qWnfYUnS7OX5soZzSsadKv76C2r9o9S69x2dLCzW7JAnJSlj5ix9PrdI31meL+uQEMEtVbcue0JvFNp1oH6P6t8+rA9Pt7l6ISRP0Ywvz1NRUbGWLLxFGcFKMEmasfiHeinnuA68+Zp+/y/H9fHpDjk9c7lNOXfl68GiRZptDuebBgAAAAAAAABgdNxw+fLly2M9CQAAxsqS4vvHegoAAAAAAABRe/3l30iSWltbYz52Tk6OpHjskQAAAAAAAAAAAOIGQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwBBBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwBBBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQ4ljPQF/S4rvH+spAABG0L6618d6CgAAAAAAAIgAOxIAAAAAAAAAAIAhggQAAAAAAAAAAGAo7kobUfICAAAAAAAAAID4wY4EAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGAocawnEFBbvdat3CWbirS1bqVyohljoEMfHWzU7+sb1XqsTe29kpSktMxZsuYX66F7FunWjDDHcraptb5R9f/a5DWWZMrI1O25xXpgeb5yZiaFN9Tpw6r/f+u0791j+ritW05JSp6iGXO/quXfXqaiL2XKNCHQmW2q+9Ea7TgqWVdValtxZtDrnKl7XA/tPCbd84T2PTJPktT6/P3a8GaY37PHMD4DAAAAAAAAAMA1Lz6DhGHqev81rd9co4/cC/7mTM3IkDTQrfNtx3XotWd16LXndet9P9LPv/8VZQRcuHc52fArPfF8s844/caSU+dPt6m1fpda66s1o/BRbVuTZzzWgF31v6zQjqY2V3igJGXMzNRUSZfa23Tm/UbteL9RL2bm6eENf6/iL6TG5s0AAAAAAAAAAGAYxl2Q0NW6Sw9vqle7kjRjUanWr8qXNcNrt8BAh2xv7tIzLzXroz9UqOzESu18skgzhgQA3bL99imtrzkup5J0632P6AfL/XYxDPTpzJ+qtfmZen3U8Cv9g+kJvfjIPKX5DzXQprqNP9GOD/uk5Fu0/MePquwOi8/OA+fp91T1i19qz1+atWPDcZ3c9IxW58Q2TMh55HXte8T/2cPaUfyU6iQVb35dq9l6AOA6s6/u9bGeAgAAAAAAQNQcDseIX2N89Uhoq9emza4Qwbpqm15aX+QbIkjShCmyFv9QL1WulNUkOVt36Ynf2YcM5Xz/NT1Vc1xOTVHxkzu14+8ClEKakKQZuSu1o3KFrJLa39yluhP+I/WpddfjrhDhxiJtfekZPZxrGVK+yDTzK3r41zu19Z4pkrNNdZt36WD3MN8PAAAAAAAAAACGaRwFCX06+E/Vsjkl09cf1eYQPQQ0s0ib1y2SSdLJl3epvt37RbvqdtarXVLGsh9p9R0hdgbMLNaq+1Il2bXn7WO+r53ap+fqOiRZVPbkSgXfZJCqnFU/VdkcSc4mbXv1WLCDAQAAAAAAAAAYceMnSOj9s5oO9ElKVfHf5g0tLxRA2qLlenCmJB3Wvqa2qy+caL6ys2CeHlo6N6zLW+8s0uzMeZqfpSs9EFxONtXrpCTlFGvJnDAGmmDR8gcWSZK63npHrQNhXR4AAAAAAAAAgBExfoKEY4d1UJKUp5zbwj3JopwFri0CtiPHPQHAmdZmnZGkz31Ff+VfzsjIbQ9o564ntP6euTJ5nuzQv7/nCihu/et5Cnco05e/qvmS5HxPtlNhngQAAAAAAAAAwAgYN0FC+6krQcDnLLp5SONkYxk3WlwPznbo/JXnznxy3PUg+xbNGNasTunkf7oefX5WiFJL3sxTrly3TefbQxwLAAAAAAAAAMAIShzrCcTKJXcJoCRT0OMMHT2lM1J4wUFbvdat3CVbwBfnavWun8vTouHKNgf/5srh+s+P26ScCEIIAAAAAAAAAABiaNzsSBi222YNc/fByPj8zYQIAAAAAAAAAICxM252JMyYc4tMOibn0eP6eECaEeYOgPbP7K4H06doqnusrFskHZf+t13tCtDbILNI2+qK/J48rB3FT6nO57lZmn27pA+lD09EsLPA0eHq0aBMTfVcPFVp4XSQdhvsi+BgAAAAAAAAAAACGz87EubO00JJUrNaj4Z7kl2t73ZLkqzZt3iaJM/Inqc0SfqwWS3D6lEwRX/1FVd48NG/HVa4Qznf/7MOSZLpK7LOcj+bqozprkcff9YRcgxPnwcAAAAAAAAAAIZh/AQJyV/VosVJkrpV93pTWIv2XX+q057TkjRPSxZ57Ra4LV8PzpGkw9pTbx/WtGYvKtJsSWp9Tb8PJ+AYaFPd3iZJUtrddyrHa2eFa6eE1PVfp0J8f3bZ3nM9ss6ZFfRIAAAAAAAAAACCGT9BgpK08Hulspok55+e11N/CBEAnK7Xpi2N6pI0+7srVeRTv8iior8rUoakky//TDv+1B18rIFutf52t+oDvTZrif6heIqkDu3ZukuHHMEG6lbrzsf14lFJpkVa9+Bcn1c9OyVaX9MrrcZzuhqQWLToy1OCzx0AAAAAAAAAgCDGUZAgKbNImzcVKUN9sv3mJ3romXrZ/G/dH+jQR3/cpdVrdsnmlEy3r9RT37YMGSotZ6W2rZorkzpU9+Qqra5slK3dr+/AQJ/OtNZp86pV2lBzXE4l6dYHSrXYpxVCknJW/lyrb0+SPqvXppXr9WJLm5wDvkM5Tx/Wni3rtOHNDklTVLxppRam+k3qtmKtviNJUofqNq/X5rpjOtPrNUa3Xa01v9KaKwFJWmGpitiQAAAAAAAAAAAYhhsuX758eawnMURbvdat3CVbGIdaV1VqW7FvE+Ouv9Tp5xt3q/XKIrvJnKmpqZIGunW+rVtOSVKSbr3vR/r597+ijCCNmdv/tFuPb63TR+4F++QpmpFhkuTU+dMdV8aSTJl5enjD36v4C/6r/1cMdOhg5eN6pqHNc/2MmRmaKOlSe5vae8Mcp/uYqjb9TK/+JXgz5YwFj2rb+kVhNJ2+2iS6ePPrWp0T6ngAAAAAAAAAQLxwOFxlcFpbW2M+dk6Oa8E4MeYjx4G0LxRr62v5OnmwXq/WN6r1WJvOOCTX4v08LbwrX98qXKRbM/5/9u4/Pqr6TvT/a2lIO5dGTFxGdmSDNsXAMtiRJbZRaB/ECq2I+DWsm95iLQ+XPlbr0lu8RbvQVqt8q3SLt1RpV9ov3Su95lrwFikWYg3fGlq0YXGUoTDSVJiVWRxrqEa+YyGl3z8mgSTkkMkv4o/X8/Hw8cDJmXM+55zPeZ8zn/f5fD49rQmK//Z6Hqi9ltS/b2PLlnp+ufclDv1nbrLjwrPCxGJVTL96KjPLw6df0XvO5rIv3M9jn0qw8bGNbN7+Av/xnxkOt62n7KIP84nZM5k5KUzh6Rr/R1zIDd/8ITN31fPwjzfy3P7DHHr92Iny/PX43Hpmx3oojyRJkiRJkiRJeXhr9kiQJEmSJEmSJEk9OhM9Et5ZcyRIkiRJkiRJkqQBZSJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgQqGugBdfWL2dUNdBEnSINq88ZGhLoIkSZIkSZJ6wR4JkiRJkiRJkiQpkIkESZIkSZIkSZIU6C03tJFDXkiSJEmSJEmS9NZhjwRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSBUXRfMAACAASURBVJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAFQ12AbmW28MUbf8CeHhYrPCvMX4//MJ+YM5vZF53ddSVs/O+38ECyF9u98qtsvinaTXkSbHxsI5ufStB0+Fjus/edzegLo8ycWc3sy87j/e855Ut9336e+9/VhM/dz32zw3kvv+f78/nihiPAeSz47n1UjznNwnmUqfCsMCXnR6n+u2uZHetSjv5+Px+9PU8DeJx7PJb93VYfvj/7rkf4fKyXG5QkSZIkSZKkLt7iPRKG8/5wmNF/1c1/4RHweoamX2/kgSWf54sbM4Ow/SM0Pfp1rr7x6zyw4dmTjdMAb/6BQ89v49+++UX+6+d+QOPrg7D5wfTmMzz2syNQOJxCDvLw5hf6vcqjr2c49Hw9D3zlFj713QRvnLHvD/F5GoRjKUmSJEmSJElvFW/NHgknXMAN37ibwJfs/5Sh8Qff4q6NL7LnwW+w/uLu36rv7Zv67d7Y9gO+uCbBUc7msvkLuWFmOaUjhuf+ePQIqd/U82/ffohfZrbwla+H+eG9sxl9Ss+EPmw/PJP7Ns485eNDG5fy2QdfgPIb+eG/zGR0r/fopKM7nmHrUXj/lVVUPL6FrT/bzC/nXchl7+vpmxfy+R8EnJM3D9L4P1dy18YXOfz4N3hg0oPcNnXEAH//VH0+TwN0nPM6lgN2Tk9z/CRJkiRJkiRpELzFeyT04D1hKj63kE/9FcBB6v99IHslHKHx59s4Ckz4h7v5yrXRk43TAIUjKI3N5isrFlJRCCRrWb9rADc/qP7A1i3bgOFMr6xh6vThcHQbG7f9oX+rfd95VHzuq9z20eHAMbb+/Nne9Uro0/eH+jwN0rGUJEmSJEmSpLeIt3ciAYDz+ODE3L+a0gOZSDjIb3fn/vXBsad5/bt4Kld/FCgs5NDv3yaNxy81sD4OFFZx2aQRVFR+mEIg/pMGUv1eeW59AOxK8ttB//4Qn6dBPZaSJEmSJEmSNPTe/omEI89Q/1TunxXjLxjAFZ9MUDy3+8XTLlnxhUfYvH4Nd32864TPb02pX9eTAt7/yWnE3gOFl3yC2WcBBx5ly28GcEPvK+S9g/79oT1PZ+xYSpIkSZIkSdIQefsmEv50jEO/28YD/7ySrUeBv5xJdWXP4+nnbwQV18ykGEjVLmXubd9j469f5NCbA7iJofCnF9iy/iAwgpnTLsx99p4LmfrxEcARNm5+hqP92sARGrc/k/tn7ELKBv37Q3ieBv1YSpIkSZIkSdLQe4tPtvwCD9x4HQ/0sFThuNl85Z+vJxYwUfCeB2/hEw/2tK2Z3LPxRmIdPnl/7EbuW/QHbr//GQ79pp4HflOf295ZYf4mNpXLPjyZD11yIaU9TFDc1+0PhqO/3szG14Gx1zKz/OTnE664ltJHHyK1dQtb53+YmcV9WHfmBbasWcnqbceAs5k9czKFZ+D7A3Weemswj2Ww/K4Jrvwqm2+KDuSGJUmSJEmSJL1LvcUTCcN5f7iY97/n5CdvvJrhjaMAZ3PZ/M8w95IPM2HM8KAV9Nvo6bfyw8syxLdsYf3WBp7b9weOvp4h/tSjxJ96FBjO6L+t5r8tupbYWYNWjAFyjMbtubfkJ8z8MKUd/zRmGtWxh7gvnmD91oPMvPa8gHXk05A9nAnzv8aCi7o7L/39fvfO/HkaiGMpSZIkSZIkSW99b/FEwgXc8I27md1xDt0/Zdj67aXcu/UP/HLjM0ytnMqEHtYy4XP3c9/s00zE25PCMLHZ1xObfT386Rhv/OeLND77DPVb6nnuwBEO/Xstt8/fyefvv5vZfzUI2x8ohxvYuPUYEOUTU7uW52wu+VgU4glS6+vZM+d6Jrynu5UEKywO8zeTqph53Uymj+39MFP9/X5/z1OvDPKxDHYhn/9Bl2tCkiRJkiRJkgbRWzyR0I33hJn+hbt54+Uv8sBvnuHef/4BxfffSGwgp0c47faH8/4xFzJ9zIVMn309ZJ7lgWX/wsbfvcDqf93G1DumMqAj2Qyg1NaNxAFIcN9nruO+oAVf38xjv65hQmV3PQL625B9hhrCB/k8DcyxlCRJkiRJkqS3vrfnZMvvCTP71s8woRD4/Ra+uuoZ3hjgTRx6/Bt86u+u4+oHE6dfMHwxn19UzWjg6L8nOTDA5Rg4B2msP0huuKgwo/8q4L+zhgPH2Pp4A4eHush5GJrz9M48lpIkSZIkSZLUnbdfj4R24Znc9pkGPvv9Fzj61PdYXRXli387cN0SSs4aweE3gV88y54bo6cfmiY0gmLg0IBtfRD8pp6HDwCFVSx98EZiQfvzm4eYe9tG3ohvpP6lKqrHnMlC9t6QnKd36LGUJEmSJEmSpO68PXsktBl91U3cMBbgCFvuf5Q9fxq4dRdO+TDTC4HXN/Pgj188bY+HQ9sb2ANQPobRA1eEAXSMX27ezBvA+z85LbjhG+BvqvjUWICDPLz5hTNTvH448+fpnXssJUmSJEmSJKk7b+tEAu85j+rPzcyNdf/7jdz344MDt+73fZgbPnshhRxjz49u478ueoitv8twtD1Z8adjvPFSgo3338bnvv8CcDazP1P11kwkvLmTbb88Boxg5qUX9rDweVRUnQfAGz/bzC/fHPTS9c+ZPk/v5GMpSZIkSZIkSd14+w5t1Kbwohpu+Wg9dz11jNSPv8vGqlMn8t3z4C184sF81jaTezbeSKzt/0bP/jL3HfsWX1yT4Oi+jdz7hY0BhQhz2S1f5fMXdT+hbl+3P1AOb9vC1qPAWVVM/Zuely+dPpvYmu8RP7qNjds+w2UfP3uASzSwBuo85WPoj+ULPHDjdTyQz6JXfpXNN0X7uT1JkiRJkiRJ73Zv7x4JAIzgsn+4iYpC4OgLrP63gZx4eQRl136Vx/7nvdz2manE/upsCk/8bTjvD0eZ/pmFPLjmfr4yPXya9QylDNs25yYiLq2uYkI+XymexuyP5v4Z/0kDqUEr20A5U+fp3XAsJUmSJEmSJKmzv/jzn//856EuhCRJkiRJkiRJ6r3XX38dgHg8PuDrjsVy4+e8A3okSJIkSZIkSZKkwWIiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAhUMdQEkSRpKzc1/GOoiSJIkSZKkd4GSkrOHugh9Zo8ESZIkSZIkSZIUyESCJEmSJEmSJEkK5NBGkqR3tbdzt0JJkiRJkqQzwR4JkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgIVDHUBuvrE7OuGugiSpEG0eeMjQ10ESZIkSZIk9YI9EiRJkiRJkiRJUiATCZIkSZIkSZIkKdBbbmgjh7yQJEmSJEmSJOmtwx4JkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFes8dd9xxx1AXQpKkobLiyQyVHxgxRFtvpXnnIzT8IUrZqCEqwkB7pZ4Vd/0rG14ezccvCuc+272W21f8L57/i4uG8FjTx7K00rLvl/yfH69n/U82sLnu5/z85z/n/33mefY2F3DeeedR9N6Oy2eo/9Zd/Otjhxj98YsID1CxM0+u4K4HN/Dzn/+82/9y5QlR9sHRhM7AayKJH93Oiv/1PMM+VMkFfT2lLU3U/yzJiPF/TfsqBmS9p9PaTHxdA69NLOMvB2H1/dbL+jnox0tvI/2LPW/LutRNDMnf4MTq/ur+PHTzrNDdvVYDZlCvh16cu6G4Llua6tn8wgjGj3m7BIIB9lZ6ZpWkXvrjH/8IwKFDhwZ83aNHjwbskSBJ0pBp3rqK5Y/EyRwf6pKoe1kSj9zLsh9sIr4/Q3ZYEUUjiygaGYKWDKmn17PyG8tZn8yeuSIVtpeh43/t5all+TfWkjiDxem7JLXfWE1d05ksbDP1q5ZTuzPDsTO4VUmDYShiyNDwWUFnzJ5alq2uo+nIUBdEkvRWVTDUBZAk6d2q9XjrUBfhzJg4j3vuGepC9EHycdbvbIER5VTffD0V53R4bDreSvpXa1j90yYaH3mc2JJqys7A6xnhjy1g0eXdvMHYmqZu1Urq0wke35omemVk8AvTL8doPeONYq2YQdA7V5iqW++hqo/fjn76Ht5eYXooYsjg6+48vGueFTT0rGuSpB7YI0GSJKkbyecayQLRq+d3TiIADCsgMnUeV5YB2b3sfWkoSthBQYQZ10yjCGjes5fMEBdHkiRJkvTOYo8ESZJOaCX9xCpWPpmmYMwMFt5cRbgPKffWV+Ns+nEdjanm3BuTBSHCY2JU/d0sYucUkBubeQV1r+SWTzx0O7cD0evvYd7Etr8xg5urs/z0/2kgdbSA0JhK5n1uFmWF5MZ5/2ktdTtTNB8FhhVQUlrBjBPr77xPzTs3Ubs1TvqVLK10V562cvzodtbuijLv/76S1sdq2bQjRUsrFIyIcPHV86j+UAnZ/Q2s/z9bSLzcCsMKCE+cRc3fVxI53RPF7rXc/lCC8BWL2t6mP7mPi74wnqb/vY66PWmybdsaP/0aqqeWEurpuBaWUDp5BjVXxSg5ZftZUtvW85Ote0kfaYWCIkqnzKLmgvzPY0FBCMhy7Fgr3T8yhahYcA8Vp1vJaw2s/MYm0qNmsOjWqlPG4W7duYaljySJXLWEhVOL8i9cd0IhQkDLG4dpgZPbammi4bFNPJVM03I091FBUYTxH5vFnEvLKOpSx7PpRuoe23riOOfOSffLdt6Z9l4RBURmLmTh9ICxn9vqAwCv1LHi9jpoOz4nHG+h6cl1rP9FMlfH28/11TFKupYhn/17pZ4V36prS7AkWHv77UCUeffMIxqwOwN5PfSu7nYjm6Lh0Z9Q336djCyl4soaxna3bNvxaF+WYQUURcbz0U/OYVpZz3Ust99hZty6iKpRPfyt7bhyxSIWTmii9tE69r6UpZUCQmPGU3VVNdPO73olQ/Oeeh5/sqFtWSgoLqXiihpmTS7pfKW1pGncso6659vObVCs61COm8qSnc5JybgqamqqKH1vM/GO53FkKZXXXM+sCSePSadz/uhaNsTbjndRhIs/OY85ncqXR6zOt/xt10T0+nu4snUDtY83knqtFQpCRGJzmHdtjJI/pmh4dB1bdmdy1+W5UWb9fQ2VJypb+32lS73Osz6cet77Eqe7xt228k9r5of31ZGZNI97Ph10xbU53kLTrzawqX0ddHM9B8WQfxhObd7xNrgILU0NbPhZ/cn6mW8MpIn1d66mkQoWfK2aspNbpnHNUtYnoWjqzSy5qrTDxrazatkGUm3HpvN5OM2zQoeda301zoaHN/BsHtdeV7263s/EvbtrrCsup+rva4g2fZcVT3BqWbrWd07/t9y5fYq96ZZcWXoZH3v3/AXNz22gdnMjqcPt94iZzL2s5830KN/7eqfYsp61jz2bu64Ki4hcNIt515w8B7nznft35okV3P4EHZ7b6GM8TlD7v+tJHs7Fg3DZNObMrSKfQw2cON71u9Jk2uPBiDCRSVVd6s9AxKvePydK0ruRiQRJkoCBSiLwcj2rvl1HeliIyLgY4RHQ2tzE3v3bqf3WAZq/uJCqUSHOi8YoTyZJprOUnB+jtATGjuywnqM7qH2wmWNjosSKXic17DzGFgLZBGv/ZS2JI7mGsGi0hIIjaRL7tlP7rQR7P72ImontP5WyJH60nLW7slAYpnxyOSFaaW7aS2r/dmq/dZDsbTdT2XG7ZKi/fznpTBGl5THKWtMk9qVpfPj7cDBC4qm9FJw/ntjkY6QTSTK7NrCyNcTdN8R6/1BxPE3dqjoSvy+htDxGSdu2Ej9dReaPizoN4ZPdvZblDyXIUkDR+VHKSgrIHkyQfLqW5bv3Mm9RDdETvxC77neE0JE0iV/XsvzX+RevbFKU0K8bSf5kJeuPz2XG5FKKeruTI2NUnL+JDft30JiuYlanEYdaefa5JFBO5SX9TCIArf9xINdQfm7kZAPay/Ws/HYd6eO54xYrKYAj7cd5NU2ZBXzt2pPNXaceZ2jel8gte2Aeiz8dPaWRKLfxPJMIACPLiE1+ndTOFM2hCOUTwoRGntdhvS1s//691B2B8LgYsRFZ0s8nc3NAHD7G1+ZXnFw23/1733lEJ5ezd0+SdLaE0smllDCWkh6Pav+vh97V3W50vObPLSd2XojswQTbH17O9q4xKptg7f9YSyJbQElplPITxyPBptVNHLxhCTUTBv7xvzVdx6onE2RGljJ+cgnHDiZIvpRg0/cyHOvSQJl5ciUrnkjnGtXKY0Tazu/2R5Zz4PAiFrZf9y/Xs/I7daRbc4mGaLQE2mPpN+Mkrl/MvIldmoV217L8iTTHzi0nNnl4LtYl61hVm2VaSwMNvw9TflGM4c1N7N2fouHfvgsLF3e5LrPEH/4Oid3HCI+LUV7QTFMyReMjy2lKLWDRNWWdY11QrO5D+TNPrmR5OkPR+eOJleXqVHpHLd/nIJE9DewtKGV8LJY7vi8n2HD/Q4TumE+sMODEDER9yDtOd4i7BUWUTizLLbuzluV7Qt3HjVMLTOLhFazdlc0ds/ISCsiSTiRz13N6PkuuK6cgKIaMjPQi3nY/t8Kp9TN3z0z8dDV74z09G5RR/kFo3LWXvSkoO5EvOEAqlftXy0sHaaGU9ojfmtxLCiifML6b9eXxrPC7Ddz7rRayRblrj983kUgl2PS9NK/fvJhZpd2str8G697dMdaNKif21yGy/5Gg7nvLSUQKIM9aFOTEuS0oonRCjJL3kivLS7nrIXPj16ged5oV9Or5q8v2JpZRQjNNezaxane/dqPX93WAbHwt39mVyMXG8rbYuKOW5S8eYMEX5lBWCCVlMWItKeL7mwlFyikfHaIkEjq5zV7Gs9Z0HaufTJApKiXafl9I1rH6fzQx5x8XUNklcXXa431uObHyEPwxF49TT9ey/FCWJf9YSaenp77Eq348J0rSu5GJBEmSgMyTuSRCqGwON91Y2bckApD8RR3p4yVM+8fOP+CzO9aw7LE0exMZqqaHKZ9ZQ3HBCpLpLJFpNdRM7LKi15qh65uLZGmsXUviSIjSq27i5qkdGmsPN7Lm/vXE160nOm4e0UIgXc/ju7IQmcGiWzo3fqR+upxV21I07mymcnrH5tQM6WwFC5ZUU9b2mzD769Xc+WgTjU9liV6/5OSPxblJ1t+1hsY9CRLHY8R6e8xeTZCIzGDRHR3K9nIdK+6rJ7OtgabL297ozDZS+6ME2VAps/7xZqade3IVzTvW8J11cdY/GmX8p6MUAK2717O+u/1u//Gdb/nGVXPT1c25eRAeXUXjo7k3/srGlfHBiy9mygURQj0+SRVRcUk5G/Yn2R1PMyvSoWWrpZHGJDDhYi4OagjMR2uWdLKOdY8mASifEmv7Yd1KfHMd6eMhol1/5GcbWXPXepI7GkleW0Y5wNF47jgPi1B1y83MaH/T+XiG+vtXULdrPY8no1SXd9n+8Qz1q1ZSnw5RdvVNLLj0NEkEgDGV1FxXxNqda2l+f5RZ13V9czhLy/EoNV+eR6y9hWB2nLXLa0kkG4m3VFBZ1Mv9KypnxnXFFHwrSTob4aPX1QT2ROisn9dDL+vuqVpJPLqexBGIXNGhkZ0OjVQdND9dT+IIlM9dwvwpHY5HahPLH9xB0669tE4I2lbfNe9OELliEXd3LN8TK1jxZIaGhiaq2hu10pv44RNpGBGl5r91PL9tDUZP1NIwZSHTRmaoX1tHujVE+dx/Yv6UkzGqNV3HqvvrSfxoDdu7JEJb0mlKr1rMzVPblj+eYsO9q9iebKChS6xp2baSZT9Ns3t3hlmRjjWwicTvyqn+0nwqits+am/Qeno9Wy7pknjoNlb3rfyZ9JtU3LiE6nFt5252I6vvXE/Tjgayk+axpEMiL7nuTtbsSJLYA7EPBZyXgagP+cbp5ONtcbeKhTfPONkr53Aja1auJ3m6bZzY1nbqd2WhvJolHROGc1Ns+uaD7Gh6lr2t5URPE0P6FW9TbfWzuIL5C6sp75CcTv10Nau21bF2a7T7eWraRGNR2JUguS/DrNK25VJ72ZslN6jw/iaajle23S9beXZXLrkRjXZ3FoqCnxXaeilwpIWiyxdy2xWRE+ex/drbsaOJWaVl3ay3nwbl3t0h1l2+kJtP7M/Jlzz6lUg4GmfTk7nYM++/z+uUvM3uWMOd65I0PpukelzXG9yJpXr3/PVKPWuf6GZ7HRrH+6aX9/U2TbuaKJ+7uEMsam9I3876n1ew+MoIkY/UUFO0lvj+ZoomzqLmRD3vWzxr3p0g0hYb20uZu281seHxOBU9vICS3vp4t/c+jqfY9M1VNOxvpPHVSqrO6fClPOvmgD0nStK7kHMkSJLe9dob5PqbRAA4dgwgy+Hft3T6PDRlPnd/fQk3n+5N7U6KmHhRl1cJW+K5hpAxVVw/tct6iiuYdWkYsgkan891/27en+ZYYQHRy099g7L0glwDS3eTOJZOm3Gi0RQgdEFZrpHmnEpmdPzROqycsg8AZGh+Nc/d6iRExSe7lO3cGLFRQDZ74n3RlmcbSR6HyOXXd2qIACiZMotpoyC7q5Fn27r3740nyFLEtGu6rruKuVN7fge9o/ClC1hyxyLmXRGjdFQIWtIkdzaw6QcruXPpUpatqSfV/YutJxREL6Z8GDQ/9yypDp+3PNdIihAVH8m/N0fmiRXcfvvtnf9beicrH9pOuhWKJs+j5kSDYRMH0iEKRk3rfN4AQmMZew5wvPXE/MMtO35F8jiUTJ17MokAMCxM1cwKQoUFvJzuMvtCe5Ih3yRCnso/WXOykRkgFCP2QYA3yb7Z/mHv9q+v+nM99LbunuL4XuK7szByGtd0abwMXz6XacWdF2+/ng+/ephOV3bpLBbf/TWWXDfwSQQAQhXM6lq+WIwwkM2evECant5BM1A+q+v5jTJneoSCES0cTLVCqpHtrwBjqpg7pfM1WxCZkbuOj6fYvqNLfQxVMLPjNT6s9MRb4dGPdY4HRePGUwI0Z06dUSQyfe7JJEJb+WpmlQPN7Hi6qcvS3cTqvpb//GnMGNexso2lbBRACZUf79wbqHxcroE48/vgGVEGpj7kE6dbiT/d2BZ3Z3Qe2qu4grmX5zn5+3Fy5Ww+zOGOBR5Wyqzb7uZrX66h2/b2DvoTb5t27KCZEBXXdEwiAIQovbKK6DDI/Lqx03pPMa6cciCzr4n2p4CWlw7QQikzLi8Hmmhqr0LH95LcB5RH+55MHjmNazokEaD7a29gDcK9uz3WhSqYeXnH/SkgcsWpsa7XFzWFDQAAIABJREFUXjxAOlRA+NIZp/QAC40dm4vpx05zt+jl81fm+TgZcveyTts7EUv6qo/3vVNiUYjo383JXSuN2+ka1TrpTzy+svNwQifuW3t+RWPnx+Qumjnwn8coKIhS1fW5eVgpY8cAtMIpE67nVzcH8jlRkt5t7JEgSXpXa3l6NStbcr9mRk2M9iuJADB+cozQrjiJR5axdFOYyPnlTPpIvm+vdzSW88Z0+SjVlGvAOLKLTY8cPPUrzbkfsKnUAZhSRsmlC1hyKUAr2ZYshw81kXn5IHv3NZFsCn7fqqQ4YJidSOSUMacL+nW8RhEZ3fNSB17MNdu8mdhEbTfFzu12itQBqBiXIZ0GGMvYboZ0iIwrI/RUc++KWRgmenkN0cuB461kDx1gR/wpGp9OkknWsepf0qe84dj5+zEunbyB5I4dNO6bRek4gAyNz6QhVEGsN20KhUUUdd1OYTFjy8YTnVJBbEzHc1fOnC9/jTkAR7O0tLxC+qWXOfhikr3JvaQOd15N+qXccW5PMnVSXs3Xvt71wxa2f38lLS3AsFFEJw5MEgFCnDUy6GLJkPk9MAp6u3991Z/roXd1t5ttvJImfRwoHcup1TnC+HEhGjoMwxC+KEbkyTrSW1ey9JdFRC6IEp18MbEJpZT0p9dLT8499VicqpkDL2WBCGPHnnp+i6Yu5O62cetbd2Ry83xMKKe7ox+JTqToqQYyhzLQccvFxXTf3hgm0rVaDysI+CEUJlp+6lYLxo2nlCSplw7QTFmHYbFOjdWtmT6Wv6Sk2+UhQqRLQ2w+v+IGpj7kE6cP0LQfguJuLmmTpsfIOypKLFJHXbqelV99iqJIGdEJF3Px5CilxXneQPscbzMceDELhDj4dC21z3X9e5bm9wKvHeBgC5QGjUZXeDHR8vUkk3vZe7SSisJW9iZTcE4V0VgBiSeSNO3PwLgw7ImTOA6l5eP7/qO8uCSgzgOvZmiGPIZw661BuHef1RbrPlBG+SnPFREmTSyiYVs/ilw+hyVfmQNA65EWXn81TerQQQ4k95Lcl+q5bvby+Sudzl3b3cW6E7GkbzvSp/tet7GosIzxpZDcf5ADr0LZOd19sx/x7IPl3Z7L3H0rxYGXoHJC0H6WUHnjEioBWrO0HDlM5ncZ0gf38tvfJWl6Keh7+dTNQXhOlKR3ERMJkqR3tWxLC6GyKJF0gtRPH2L7xK5zBvROwYQaFi0Is25dPcnDGVK7M6R2N7CJAorKq7i+porSPHvnBzbSH04RPxz8E/TkW4hZUk/W8tDWJC0d3+4sCBEpLiH7Snc/lMKE/zK/8vXfWRT1YmqA5v1xmvcH/TVL9ihAhszpekecXRzQUJenYQWEImVMi5Qx7RMtxB9eQe2uBI9vTRO9Mvit2/IPRQntaCTxXNvQCelGdrwCJR+tpDcDT4Q/tuC0w2qc4nCc9T9cR+PLnXueFBSHKQllaO7wwmruZczenP8sLS0hyiZGSO9OseHh7US7jlfcJ0UUnx3819aObyD2Yv/6ZmCuh/zqbjd+nzltA1fRyC5He1QVN99a0jbxagvp5HbSye3UAQXnVjD3s9XE+vtmb7cFKcrjvLeSe022hHBAg1W75td6yAK1Tyze9fNzwgPQaBom3N3Y3UVFnAVwDLr24+oaq/ta/vA5A3xyBqQ+5BOns2SzQHHA8Q9M2nQVpurmxZT8JDfRdctLSba/lGT7E0BhmIrqz1L9oZ7PcP/ibZb0nvhphjZp6xUVeEwKGF9eCskkyX1QMbGJpn0QmlJG+JzhlI2so6GpiZYrwmSSTUApF0/qR9Q83bXXTV0dGINw726PdcO6rynvC/VvfgSA5ufW88P1jWQ6xtthBZSMKiH0cnPArBld5PX8laE5uKPQyVjSV32474VHd/fcUNR2Hrt7s/+kPsezbrfZft/Kdr6Xdyebor72IeqTLZ3qccGICCXFWTLdFiufujnIz4mS9A5nIkGS9K4WKq/mn26oILQzN0buQDSGFpVVMf+2KjjaTKppN7t27CKeTNGSrGPVv4VOnRyut+s/ZTzu7mW2rmbVE2k4J8qMj1UyfkKY4vcWESoEdq/l9ofeTm9cFTHt5iV5TBwZzjVSBv1IbOva3mOTxKvbWfXtDaQuqObu+RXdPzANKyL28UrqdtXTfLgZOM3wHeMqmVLcSMPuBMlryymK76aZMDMq8hzyoy+OJqm9v5b4kRCRj8xk5uSJRIpDhIpCFJCh/lsrqOvQ4DB8OHR+478nIcqv/SfmXxKicc2drE9u4KFfRbn50jP0E7yX+zd08q273fjLXMNs0JX6ZvbU2lxwTozqW2JUt2ZJv5hg7+4E8Z1JMi83Uns/FC2ppmxIBjctgOEAzblGnNMkE0pGFgOnaYnrMETFwAsoX9vb3YzoeeLgoS1/Z2emPoQIhYDDuWPUr6hWUEJs7kJic1vJpg+Q2JMg8XwjyZczND78HfgvPUyIC/2Mt+VUf30+Ff3owVM0cRKRx1K5N/KLfkvTcSgrz6UwxpZCw+4mDhwPk9yVhTGTiL6jWy3zjH+vRAiTINPNcIsAHG+lP00XrXtq+c7DcbIjIlTOmMnFEyIU/5cQRaECeKWeFd+qy+uazPf5qyTMyXksujqa7fuQe3287zVnmmFi1yRcW6zjfYTeF7zJvsazzKuHoZu+aodfzQCh3LNooAz1q1dRl4aSiTOY/pHxjB9dTGhEiIJhkPjR7aztc6/DAXpOlKR3KedIkCS9qxWVjqVkGISmzGXO+cD+DTz0q9MO3HoaTWy4dxlL792U67JeWELphGnMuv5mlnx9PhUhYH8TB/pa2HBu+JCW3bu6fVsy/fhybv/qMtY83QxkSOxMAxFmfW4eVZeUESkqOvHDLdcF/e0h91ZbC7sT3e41m+69naXL1rD9MJwcwqSJZDeze7akmk59i7k7xUWc1QokG6h/+TTL/aEl9wM61wp/GhEunlQC2QSJfSmefa4ZxlRQkVeDfR/tayR+BEJTalh4zTTKS0soKgrlmmKOZ0h3+REdGZNrHEl3nQcB4LUGVv7zUpY91NihwaCIsReUACEqrp1D6TByvXpeG7Q96qyX+zcUeld3uzEqQmQY8NskyVPe3mzhwP6OtbmZ7WuWcefSNTQeJdfzaFwFVdfMZ9HXlzBrDHDkAAfyOi5tb5h3kuJA38biaFPC2DEhIE36UDd/Tq7nzqV3smJLioJwmCIgsyfZ7fWaTuzODbUR8MZr/6Q5cODUxszWAwdIA0VjzusxETy05W83kPWhJ2MpLQU40G0daUkmTtcMebLET69h2V1LWbMj12gcipRRcfkc5n/xbpZcFQGyHEjls6a+xNsw4dEASRKJbhqzj8ZZ889LufPeDacfTx5gZDnRUdCS/C2JfUlaODlXx/jycjjeRHJrbgLmoOFizqzBuN57Gf/OCeeGlvxdU7exLpkMSqceO7VH19EDHOjSiL93Z5wsISquW8icqeWUnlOUSyIAZNI9189ePX9BJBIGMiSS3USAF1N9HNaIPt/30qnUqb1TjqY4cAgYOZbzTlMJ+xzPXvxtN8cqzW9fBCildGzwNnklQTwNjJnFTddXUTEuktvPYQAZMt3dQ/I2QM+JkvQuZSJBkiQAiqisnkGkX42hYxk7uoXWwzt4ameXnyFHXuf1PwLFxSeGfiho68J/LJvn4AOjKqg8HzjcwLon0p1/FL5cz7ptzdBazPgJHd86a6G5SyNla7qO2iffRomEKZWUDoPmbeuoS3c+Vpkn19FwGFrPGU+0bYiO6CUVhMjSuGVT54mQDzeybmvwgBWdDIvy0UtLgAz1D66mfl9zl274rbTsq2f1I425xomLe57oIHJZJRGyJLb+lORrUH7pQAwD1LPs4dc7vy14vIX4w+tJdGmsKbq4gvJhkHmytkvyJEvip/Wkj7dSXDa++7f0RlYy94oIHM8NcdTzj/DhuQaBo1ne7HHZ08t3/06+Ed9Nw9Mg6W3dPcWwKJVTQpBtZMvjqU772bxjHfWdxokuYey5w8m2JmnY2iU+tB6m+QgwrJiSHoZuO9H493znpq7mXz/Jjn4micqmTKEESDy6lkTHnTmeoX5LI9lWGPuBUiitoHIU8FI963Z0bkBsTdflYt2wUiqnDE5DfHJTbefytcSp3ZQEwlR+OI+uJUNc/pyBqQ/5KeDiS6KEaKHhJ3V0quotcTbkGXdLSsMMP9JK8hf1nddBK4ebc5GiuLj9/nb6GNKXeJu7d+TOf7xTEMuS+PEGksdbYVw0j+GRwrn78Cs7eHxHBkaNp6xt4wVjxxImy7Nbt9NCCeUTeq4DvX5W6IXBvN57Ff/a77nZRjY8muwU61qe29Al1kGnxM/zHZfOktrcQDftw0CW5te6ZExa4qx9NNHzzvTy+at939Nb19HY8Rksm2LTlsZ+90jK/77XZs8GandnOy//4w0kj0P4koqTc/C01bVstsNV1dd4driBdZ2eNVtJP5E776FJFflNMN7SzOEuz17pJ2qpC+rtkacBeU6UpHcphzaSJKndqCpqrkiwYkuX8d53r+X2hxIwagaLbq06zaSiBcSunMFTybrcZMu/KCd6XgiOZEg2pckeDxG9qurEsA8lo8NAmuTPVrH2d2HKLq2hsusEy50UUfmpGvaurCX55Eru2FHK+LISCo6kSezL0Hq8gMjMuW1zPISJTo5QtyXN9geX0jQuSmQEZA8mSL7cSuicEkKvNp86Od5b0chKrp+7lxWPJKlfeQeN54+nrKTgxL5QEGHG/9WhkWjcHOZ9pInVTzewalmc0vIySlrbjlEoRCjPn/ClV/4D1Ye/y/rdTdT9YDl1wwooapvpuPVIC7k2nQIiM2/qeagNgJExKs7fxIb9KbLDyqmKDvJj2LgKYiMSxJvWs+wbjbm68sdmmpIpWo6XUFKcpflwhswr5IYyClVQ8+kkyx9KUPftpcTHRYmMaKW5aS+p11opGDODuR8JbooLT69hxq4V1O3PZ4ijUblGoHQDtT9ooXTMxcya2ZtZp/uwf5Rw3mggneTxB9fSFC7jo9dV9m8Ylp70tu52o+yqeVQ2rWb7tlUs25W75o+1X8cjQnDk5LKRj88h9u9riG9dyR07S08ck9S+FM1HIXLFLGI9NN6Ep1RS+uQGUttWsXRfOdHzhtP84l5Sr4UoO7+kbVLdPiqdxWevaGLFEwnWLluWuzbfmyWdSJI5CkWTq7lyHECYqnkzSHynjuS65Sx9spTxF5RAcxN797fQSoiyq+f2az6bYCFCdChfa8f4Oo+qvHoRDWX5TxqI+pCvgonVVE9qYu2uelZ+PU7puNITx254KAT5xN3ITOZM3sGanfWsvKOxrX605urf4VaIzGBWrD1udh9DTlxLfYm34+Yw/6MHWfVUgtpvLKW+SwykKEb1J/Ob1aZ9Atrmw1A09YMn77KjxjI2BJlsK4ycyKQ8AlC3zwrvzasYPRrU672X8a/0ys8y43crqNuxhmX7Osa64YRG0CnWQVtj8K5GkuuWsWzHeMpKjpFJNpH+41jKxmQ6Tcg7fnKM0K44TY8uY9nOXDla26/Hc0ooOdJM86EMwU9EvXn+yu373KsTfPcnSdZ/cykN46JECtruT+/NPYf0KZnQ6/teTmgEJB5axrLzc8epPeYWjJnBvOkd9jgcJgKkf1XL6v+vlLGTZjFjQh/j2YgQh59YwdLn2+pVx+vo2ujpG6JOTLy+nVV3NFEejRCi/V4RouScEM2vZkhnyHMoxq7HcWCeEyXp3cgeCZIkdRD+WE2uoaivQxyNqmLhl2qoPD/M8FeTxHfGie/LEBpTSfUti5g3scP73OUzqJ5UQkE2TWJnnGdTeWxvZIz5X15MzUfaGml2xoknmxkeiTJrwW0s7PCDMDx9ATdfFSUSgkwyTnxngtTw8cy4fjFLbr0yNy72SwdOM6nkW0fR5Pks+VINleeX0PpSgvjOOMlXhxOZNIsFty2k6tyOSxdQds0iFl9XSWlRltTuOPGmFsITZ3Hz9dPy7wUwrISK65ew5JZqKs8PUxSCltdaaHmtheywIiLl06j50h2djnkPe0HFJbnG8tDkSwesAS9QYTk1t+SOGS2pXF3Z9wbFU6pZ+OXFfHZKbuiFA/9x8t3K0MR5LF5YTUUkRPO+XJ1Jt4aJXrWA226uyg09EShM1d/nEm099+opofLqaZSOKMht5+n8hj7p7/6VX1FNtLiA7EsJ4juf5cAZGL+gd3W3G4VlzPli7po/K5vbz6Y3wkSvupn5XZM1heXU/PebmTUpQqht2fjuNNlwlBnXL+bmfCbqHlnJ525tO66vJInv3MsrI8Yz55bbmDOu/8mv8OULWXzDNMqLW0nvjhPfmaR5RCmV1y3mtuuiJ3u8nFvFwtsW5PblSG5fEi+1UnJ+JTVfWsKCSwcrAVrEtBsXUxMLkd4THF97NGTl72Ag6kPeQkQ/vTh3zxn+elvczRKZOp9FV+ca34tG9jTFbAHl17WtI9QWu3cmSB8NE71iHos7xaCeYkhf4m0BpVcuZMmCWUQ7xMBU9ixKP1LD4ttqiOY7cHrpeMa3LTv2go69WMoo/2BbCSdNIq+pU/ryrJCvQb7eexX/hoWpuqVLrHszwrQbFjHnA92sfFw1ixbMIjpmONn9CeLxJt4cVcn82xZQ2aWXV8GEGv7pU5WUFkPL/lw59r5WTMW1C1ly62eZMgp49QDp0/VW68XzF0D4Iwty5YsMpzkZJ74nzfAxldTcMiePXi0B+nDfAyi6dAGLr7uYUDo3R0rz8Ej39/VzKrnmo6WEhjXTtDPO9j1tV1Vf4tkH5rBowQzK3mzqw3UUpmpBW+w6niG5M078+RQF5TOY96UlLL4ydwTTB/r6BDtAz4mS9C70F3/+85//PNSFkCTpLW/3Wm5/MsLihVV0na5OylfrzjUsfSRFxY15TBgq6YxK/Oh21u4KM+PWRXn2PFBenlvL7Q8niMxczMLpZ+4Oarx95/Da7KO2HrXhKxaxaEATh6fRNnl1ZtI87vl09MxsU5IEwOuvvw5APB4f8HXHYjHAHgmSJPXseAvxnU2ESj9oEkF915pi0xNJKJ5CpY1akt5Bmh69k6V3rWDTvi5/aE1T94sEUEJZ+Rm8gxpvJUmSBpxzJEiS1JNXG3nqtSnMn5vXIARSJ5mnVrH6l4fb5lUIEbth5uCOyy9JZ1jZlCmctaOBhjVL2V06ntKSAmgfu70VSj5SzcwzEPiMt5IkSYPHRIIkST0ZVcXCW4a6EHq7Khl5FtnXUrQWFFF+9QJqJvj4JekdpnQWi249j00/rif+UoL4foACQmOizJh+JR+dWHJGfngabyVJkgaPcyRIkiRJkiRJkvQ25RwJkiRJkiRJkiRpSJlIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJOn/b+/+g7uuDzyPvyKQRIGYuELxpPG6Kgx7aEGr2IVuS25nY71Ja8F6ev7Arlvbnq67Xp3BrbvsHC1tmbPXrqvTFc/xx9ax66qtzVzb9FpobTilWGFbrk790V2oVMQq+MUgSQi5PwIomHcSEBslj8cMM/L9/Hi/v98Z//k8eX/eFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUjR7uCQAAAAAAQ3N2y/nDPQXgIH239d7hnsJBsyIBAAAAAAAoEhIAAAAAAIAirzYCAAAAgLeht/NrUmCkOFxeR2ZFAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFAkJAAAAAAAAEVCAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFAkJAAAAAAAAEWjh3sCAAAAAACH3NrbcvbftA1wwpg0HDc1Z7bMy2XnTE/DqNceW5ebWxandSjjTL08d9zQnElJsrkt11x+Wx5Pkuo5+Zu7r87s2vKlj9/+sVzzQEeSKbnyts+lZWI/J21el9Zvtea7D63L01u6kyTVDe/Ku/+oKfM/1JwZ+1zTnZX/87J8dkV3zvhvt+ezc8cOOPWuh2/MeZ9vT/WHP5f7/mzKEH6zV0274qZ8ud8JczgSEgAAAACAw9fkmWmZ+foH3l3PrcvKtevStmxdVrRfnmVLd8eAfYxJw3ENqRno/hPG9H+8a1Xa13Rn9nvH9H9dzxNp/37HADfuyNMPfCnX3L4uXRmTcROnZm7L8RmX7mz62ar8y4O3ZfWDd+XEC/42Sy+aknG75zv77LMzbkVrVi9flS1zm9JQvH93Vre3pytj0/K+Kfseqq3PpIbqgb51jjly4OMcXoQEAAAAAODwdWpLrrxier+Hrqmsyc1/8YW0/uKu3PlwUxa+7qF/UxYuuzwzDnTMurEZV+nIivbHcs17Z6XfR+6/XJW2ytiMq+vIy5XXH97U+oVcc/sTycSmLPzCJzN3nxbyyWTzmty85Ia0fv2v8/GORbnziul940ydlea61ty/tj0/2dKU5lJJ2PLjtD6U5IR5aZ66/9e+Ond8qv/fjJHJHgkAAAAAwMhUNzPz501J0p2VP//lobvvcU1pPj3JQ6uyekf/pzz+f5fn5bqmNJ/Zz8H1D2TRsifSdWxzFt+4f0TYbeLMXPn5v0rLscmW1htz557pj5qS5vnHJ1mX77ZvLk5xU/vyrE0y49z3pfGAvhwjkZAAAAAAAIxYk/7d5CRJV8+hvOvEzHn/zCTtaX+0+/WHe9Zl+Xc6Mu6PZ+WMfpYrrP32/dmQZMZF8zNjoG0Oxk7PgsvnpDpb0/q/V6Vr98eNc1syI8njbauyod8LN2Zl2xNJ5qRlTv0BfTNGJiEBAAAAABihurP2J6uSJNMmH9qNgxve25S5SVY8/NjeB/x7/XxV2rrGpvkPp/Rz5RNZ3d6dZGaazxz8If+498zK7CRdK9flF3tiSMNpmTsjyfrlWf1MPxetX5XW9Un13Fk5Y4DNoGEPeyQAAAAAACPPjo1Ze/9tWfTtjuTY5ixo6i8ktOW6lrYBb9Py2XtzZX+bKNSeljl/lKx4aFVW//mszH7NA/u1Dy9P13Hz0zw1eXH5ftdVNmdDJUkmpqFuCN+j9l056feTFb/61/z6hWTGxCSpz9xz5uTmte1pbd+Y+Rccv88lj/+f1mzK2Mw/u7B/w7cX5+xvDzRoc77YehB7R/C2JSQAAAAAAIevQR6KV5/cks9+5pLCK4TGpOG4htQMcPtx/T6J77v2jPfOSR5qT/ujn8rsObs3ct6xKm3f786kj85KY5IX979sR0deTpKpkzNpgHH3+Q777xGdpPrMs9NS1577W5fn8Y9ekmmjdh/oeSLtKzqSEy5J8x8Ublhbn0kNxS+WZOyAvwmHHyEBAAAAADh8TZ6Zlpl7Vht0Z9OaH2f1M90Z9/vNuea6SzP7uH6ewu/VlIXLDv5f3le/Z1bmpj0rHn4s18zp+9f/XWtWZWXX8Vkw5/j+L9rzMvpnN2dLMqSY0NXPNgwZNSVz5o7N/Q8uT/svL8m03dGg6yffTWslaZx/WnmT5aarc8enpg9hZEYKeyQAAAAAAIevU1ty5RWX7/7zyXz2q3dn2Z9NSdev2rL0r+/K2o43ceza0zJn7pjkoVVZvSNJurP64VXpOqEpZ0wuXHPsu/IHdUkqz2RTZQhj7PjXPPWrJJmcSb+376FpZ89LYzrS+qN1uz/ZPX6mZ/7cQsiAfggJAAAAAMCI0vjhv8ric+rTtbktixa3ZVPP4NccnDE5472zUp32tD/anex4LO0rutPYNMBqgPStJEjWpO0nWwcdoWvNqqxMUj13Zt49ar+Dk9+X+TOSru8vz8odSbb8OK0rulM9tzlzG97I92KkERIAAAAAgBFmbGZccW3mH5t0/eK2LPrnjW/aSNUzZ2V2dbLi4cey5dFVWZEpaSm91mi3aR+6INOSrL37/oFXTHSsy63L2tOV+rT8p/42Tq7Pme+fnnStSvua7mz5aXvWZmxaSpssQ4GQAAAAAACMPKOm5OPXtaQhyYa7b8g969+kcWpPy5zZY5KH2rK0rT2Z+r6cMXGQayY2Z+EVU1L927YsuvofsmJzP+dsXpObP/OFtP42aTjn6lw4tf9bNcxpztzq7qx8eHmW/2hdUteUOYVzocRmywAAAADAyDT1kiya9+Nc88DG3Pk/Hsjsv5uXxn1eD7Q8S69Yk5oBb/KuXPj5T6f52NLx3a83WtGetWuTGX8xa0gbKE9q+VxuOvJLWfh3y7P08h/n5hOmZ/apE1Od7mz62ar8y/qOdGVMTrzgc1l60ZSMK92DkrcdAAAUzklEQVSodlY+9MGxWfGdu3JnV9L4saZM2/8VSPtbfmMuWzPImoUT5+XLC5viDUkjg5AAAAAAAIxY0y69NvMf+uvcv/7r+dw/z8qyC1772qHubHm2v+UAr1Wfrl0Dn1F9ZlOaq9vT2jU9c0+vH/LcGv/407nn9CfSdv/9+dZD69LW2t13v4Z35d0fbsr8DzVnxmCrG5JM+8OmjHuwNS8PdZPlHVuz6dlBzqnrTufgd+IwUdXb29s73JMAAAAAAAZ3dsv5e//7u633DuNMgKH4Xfw/W6lUkiRr16495PeeMWNGEnskAAAAAAAAA/BqIwAAAAAAeJvbs3rgzWBFAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFAkJAAAAAAAAEVCAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFA0ergnAAAAAAAcuLNbzh/uKQAjhBUJAAAAAABAkZAAAAAAAAAUVfX29vYO9yQAAAAAAIADV6lU3vQxrEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBo9HBPAACG04svbh3uKQAAAAAjwDHH1A/3FA6aFQkAAAAAAECRkAAAAAAAABRV9fb29g73JAAAAAAAgANXqVTe9DGsSAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKRg/3BAAAAAB4+/v1SccP9xQA3tLe+dTG4Z7CQbMiAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoGj3cEwAAAAAAhsP0jFuyKOPef0pGT6hL1ai+T3u3bEj3j27JlmvvSNd+V4z/2uOpP6suux5ZnI0X31K88zFtGzP2xKT7vuOz6brdH37xh3nneScPaWal+49uWZj6i85NzSmNOaJm94edlfSsfzTbv3p9trZuOMD5Nmb819pSf1Zdkkp2fOWjef6mdYOP2dOZXc+uS+c3b8/Wr3wjO193309kwmOLUltXyY4l0/L87aVvekMmPXVhxuTJdJz0gby49+9DVFmZraedn21DPR8OkpAAAAAAACNN05K844bLUl2Xvofizz+ZnZUkR70jo49rTPW5SzLxrP+Yly66JNvWH+KxezrT2znwKbu2739CY8Yv+6cc3dSYqiTprGTnE8+lN8kRk07OqClNGf/lttTMvDLPLV4+xIk0ZvwdD74aEZY25/lbN+xzfNzf/1PqP/jqmD1PP5ddPUnVhMaMnnx6jrzq9NSeOy8vLThUv1Nnerd3pne/T6uO6isYvfv/LpXXnwtvBiEBAAAAAEaSOTdk0t9fmDE1ya61t2TLpxdn+2sfgp9ydSYsW5jaSU05+qs3pPuca7PjUI7/bw/kmeZrD+iS8Xe0pX5OXdK5Ia8s/Xh+e9drVw005qgb7sox556c6ktvzoRfD7QC4NVrxt/xYOrnTEx6NmfHDR/eLyIktV+8qy8i9GxO112L88KSfVcejG5ZlIaFl6V2clPq77s3OeNQrAy4Ps+dev1+n726amH7qR/Ii294DDhw9kgAAAAAgBGjMfUL52VMTdL79D154bz9IkKS/PzGPH/9N7KzJ6maMi9HXzUsE33Vef+Y8XP2vHroP+8XEZJkQ7Zfe2leeqSSpC61F9+U2gFv2Jjxyx7M0QNEhDTdmobzTk5VKtlxw4fz3JLXv75oZ+viPH/R0uzYkqRhdsYvu/CNfU94CxMSAAAAAGCkOOHq1E6rSbI5nbcOsNJg+VXpWFPpe5XOcR/5HU7w9caf+56MSpLHH8iW/R/477Uh2/7hB9nZ2ZldNUenuni3vtcVHd00MVWdhYiQZPyfzul7lcuAYyZZf0u23P3T9CYZddaFqRv614K3Fa82AgAAAICR4uJT+jby3fJkXrlv4FMrF0xL5XcxpwF9JLUn9j2e7/7Z9f1savwa7Vfl2f8w0Al9r0Cq/2BjX0T4Sv8R4bVjdj0yyJhJdn5lZbr/9PRUH3Vyaj6WZNDXKsHbj5AAAAAAACNE7aTd/2b+xQ15+Q3c54izFuWdTy06uItPvDDvfGqg1wA9mY6T9uwFMCVHjE2SSnqeOrjh9tizj0JVkjzzg2wrrjQ4JUcc0zfmrt8M5c73ZOfzV6f6hLqMmvrG5ghvVUICAAAAAIwQYxrqD82NejrT2znA8ZqaVI06yGvTmd69/z0hVUcdxPz2UzX1L3PMWXWp6qxk1+i6HHHivNR/8dvZdN3yfs6u2z3359IzpNUFG9I72LIFeJsTEgAAAABghHhl09bUH4I3+e9avTQbL76lePyYto0Ze2Lh4L89kGearx3iSE+mp5KMeYNTrmqoSzqfzPbrLk3H7Lty7HknZ8x5N2fCL6fl+WIsODqjzk3yzcHu3pgqT1k5zNlsGQAAAABGiJ3PPN/3r/2Pacy44Z7MkKxLbyVJ6jLqpDdwm90R4YXWDdlx3aV5+fHOJHWp/a/3ZvwJ+5+8Mj3PJ8nEHDHgngt7XJjRE5Kkkp6nD3BeJ9T2vWoJ3uKEBAAAAAAYKb7yaLp7kjScnCPPG/jU0YvaMvn/PZ7jvrYkR/5OJtefldn+xOYkyZhTlwzyepULM6H9Vzm+/Yc59pP7Htm15p680LpnT4QN2XrV0uyoJGmYnaO/ekNq9zn7G9n+i74xq88abMwkV83OmKOSbH8ynbfu+fA72bUlGTSA/MnEvge0lc3pHmwcGEZCAgAAAACMGIvzyprOJBNTs2DRAA/JL0zDB6enqqYuVZ3r8srvboKvs/2uldmZJNPOScMA8WP09ZelZlJNjpjQmZ7vDHLT9bdky1dXZleSqinzUv/Fpn0Od9z+g77gMm1eGj7eWL7PCZ/IhAWnpypJzyP3pLL3wIZ0Pdv3t4ECyNizTu57QLtxXbYNMmUYTkICAAAAAIwglZseSHdnUjXtE3nHfYty1P6v9jnlshz7gyWpnZBk+0/Tsfie4Zjmq9qvysvtlSQTU/vfH86xl07f74TGHHX9tzLx0umpSrLze0uzZf3gt9156/mptFeS1GTMeV/KhNdGivZrs/UbT6Y3dam99sG84/qPvC4GjG5ZlAl3L0xtQ5ItK7Ntyb6/07ZvPpqeJJl2YSbetjC1+/zO0zN2SVvq3z8xSWe6HrljCD8EDB/bgAAAAADASNJ+bX77+aMz4TPnZPSMT+T3vndZGp7dkJ7tSerekdET6lI1Kn37Clx/VV4awkP5A/Lv52Xyz+YNfM6LK7P1A5fk5d1/3XbZlRn19S9l/Hsac+SitrzzLzene9NLSWoy6oTGHFHTd17PI0vzwp8vH/JUtl12ZWp++I85cvLE1C68N+NXn59tu7/vjusuzYudt6bhoump/thNOe6/fD471z+X3iRVExozuqFv0N5nluelBZfsvW6v+67Ptj95MEc3Tcyo91+dCT+4Or3bO5MkVUfV7D2tp31pXliyIfBWZkUCAAAAAIwwO+/+eJ4956ps+9GT6elIjph8csZMOTljJtUlHZvT9b0b88I5H3jNvgKH0KiaVB01yJ+6mv02IV6erRfMzHOLv5GuZyrprZnYN98pjTlidGd2Pb0yHYub85uLb0zXAU1meX67+J50d6Zvv4SbXvu6pw3Z/rfNee7ixdn+6IbsSl1GT+n7nUbXJbue+WleuemqbPpAPxFh9/XbrpiZzYvvyY6nK+ntzN7vl57O7Hrmp9m+uDm/ueyWvlc3wVtYVW9vb+9wTwIAAACAt7dfn3T8cE8B4C3tnU9tfFPuW6lUBj/pDbIiAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAICiqt7e3t7hngQAAAAAAHDgKpXKmz6GFQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUjR7uCQAAAAAAAIfeggULhnzunXfeWTxmRQIAAAAAAByGBooDB3KekAAAAAAAAIepwSLBUGKDkAAAAAAAAIexUiwY6ooFIQEAAAAAAA5z+0eDoUaEJKnq7e3tPdQTAoC3i7Nbzh/uKQAAAAActHvv/l8HdP6CBQsOKCIkViQAAAAAAMCIcaARIRESAAAAAACAAQgJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAU/X/jT9nHzkWyaAAAAABJRU5ErkJggg=="},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:40:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:17.117Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:40:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:40:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:02:54.045Z","_duration":23072,"uid":"test-00-0","cid":"0-16","title":"TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_9: (TestCase_2 modified) should be able to add one item to cart, go to Cart page, logout, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"dfadbbaa-c503-42f3-88cc-e1abf07601bb"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/clear","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/clear","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/value","body":{"text":"performance_glitch_user"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/dfadbbaa-c503-42f3-88cc-e1abf07601bb/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a1949654-85f1-492c-ac3b-7d81dd7e9d3d"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/clear","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/clear","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/value","body":{"text":"secret_sauce"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/a1949654-85f1-492c-ac3b-7d81dd7e9d3d/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd518236-56df-4eea-85d6-66cec370c2e9"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd518236-56df-4eea-85d6-66cec370c2e9/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd518236-56df-4eea-85d6-66cec370c2e9/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f97686d3-953b-469a-ad4f-5e18221b5d3d"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f97686d3-953b-469a-ad4f-5e18221b5d3d/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f97686d3-953b-469a-ad4f-5e18221b5d3d/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"result":{"value":"1"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d6a27bd3-ddc7-44a9-aa07-e1c0b7ae60ad/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/80567c0e-862d-4224-a810-7fdbb53fd9ef/text","body":{},"result":{"value":"1"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"80567c0e-862d-4224-a810-7fdbb53fd9ef"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c83a4fe-bcd5-43ce-9b0e-7c995e99d4d8"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7c83a4fe-bcd5-43ce-9b0e-7c995e99d4d8/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7c83a4fe-bcd5-43ce-9b0e-7c995e99d4d8/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"913fb1b5-7c1e-46b1-93c3-f2784c056df2"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/913fb1b5-7c1e-46b1-93c3-f2784c056df2/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/913fb1b5-7c1e-46b1-93c3-f2784c056df2/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ee4b6e5-c514-47f0-87c6-f00837b45105"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0ee4b6e5-c514-47f0-87c6-f00837b45105"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/0ee4b6e5-c514-47f0-87c6-f00837b45105/text","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/0ee4b6e5-c514-47f0-87c6-f00837b45105/text","body":{},"result":{"value":"1"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"0ee4b6e5-c514-47f0-87c6-f00837b45105"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"aa763326-e1fd-48e7-8b46-418a81ae95ad"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/aa763326-e1fd-48e7-8b46-418a81ae95ad/click","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/aa763326-e1fd-48e7-8b46-418a81ae95ad/click","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":true},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a3c875bb-b278-4012-9eaf-c7cc303b159b","ELEMENT":"a3c875bb-b278-4012-9eaf-c7cc303b159b"}]},"result":{"value":false},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"iVBORw0KGgoAAAANSUhEUgAABhIAAANUCAYAAABWkrf4AAAAAXNSR0IArs4c6QAAIABJREFUeJzs3X101PWd//2XIRlCbgYCGiCD8LO2mLG0m9YlKQu2F0ls0D1RAq0/bUtiL1Z+6wLuoXcQFGulErx6w/lJUC8sV01Yb44tCTXnUrKGcG0NPzdhW7MuOkDX5QcyAlFImNwQJjdcfwwzzEzmO3eZJEN4Ps7hOJn5fj/fT2YSD3xe38/7fcPly5cvCwAAAAAAAAAAXHMcDseIXyNhxK8AAAAAAAAAAACuWQQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAXCfeeOONiM8hSAAAAAAAAAAA4DrgDhEiDRMIEgAAAAAAAAAAGOf8w4NIwgSCBAAAAAAAAAAAxjGj0CDcMIEgAQAAAAAAAACAcSpUWBBOmECQAAAAAAAAAADAOBTujoNQx91w+fLly7GYEAAAAAAAAAAAGF0Oh2PEr8GOBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIChxLGeAAAAAAAAAAAAGJ7W1taYj5mTkyOJHQkAAAAAAAAAACAIggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAARKTrld1xORYAAAAAAABGBs2WAQBhc7ywXRd+uVWSlPadFcMaq+uV3Wp/YoMGHR0y//3aWEwPAAAAAAAgbBf/+S31HnxHfR+8r/4TJzRwoUOSNGHyFCXOmaOkL35ZyQvv1KRv3j3GMx17N1y+fPnyWE8CABD/vEMEScp4amvUYYI7RHCb/KMNhAkAAAAAAGDEDXY61Pni8+p+9Z800H4+rHMmZExV6oPfU/rDjygh3TzCM4ycw+GQJLW2tsZ87JycHEmUNgIAhCntew9p4vw8z9ftT2yIqjSRf4gwcX6e0r73UEzmCAAAAAAAYKT7d6/pTP5COZ57NuwQQZIG2s/L8dyzOpO/UN2/e20EZxi/2JEAAAjbYFenPnu4TJcONXuei2RnQqAQ4cYXq5SQlh7zuQIIn9Nm08X9++U8YlO/3S6nzebzeqLFokSLRcm5eUqyWpVSUDBGMwUAAACA6LT/dKO6Xq6KyVhp3y1Txs+2xGSsWBiNHQkECQCAiEQbJhAiAPGl325XZ3WVumprNXjlL52RSCtZptSSEiXn5o7A7AAAAAAgds6tW62eur0xHTOleKmmbdsR0zGjRWkjAEDcSUhL140vVkVU5ogQAYgf/Xa7zpWXy16QL0dVVVQhgiT1NLythHTX7/CgwxH1OAAAAAAwktp/ujHmIYIk9dTtVftPN8Z83HhFkAAAiFgkYQIhAhA/LlRW6nTJUnXV1gxrnIT0dE2v3i2T1SpJclRXyV5YoJ6GhhjMEgAAAABio/t3r8WsnFEgXS9XXTc9EyhtBACIWqgyR4QIQHwYdDj06ZrV6m1pMTzGlJ2t1JJlnnDAlJ2tBLNZgw6HzpaVevom+IcIgw6H7IUFnh0J5rIyZZRfP3flAAAAAIhPg50OnclfGFFTZUlKfvr/043/fbouPW3Vp78NffyEjKma0XhQCenmKGc6fKNR2igx5iMDAK4b7p0J3mGCd3BAiACMPafNpk/XrFa/3T7ktcSsLE1eu1YpBYVKMAf+S297RYVhiCC5diN4lzVylUvq1LSKihh/JwAAAAAQvs4Xn484REgsrtSUpV/QDQq/dOtA+3l1vvi8Jv9gfaRTvKawIwEAMGyBdiZ4I0QAxobTZtPZstIh/QsS0tOVXlYmc2mZJ0AYdDjU07hfA6fs6m1x/S4PdnYGDBF6W1qUnJurfrtd9oL8gNdOK1lGmAAAAABgzHwy/0sRBQmmNbt14yP5mjBRkhzqDXNHguTalZB16D+immcssCMBAHBNCLQzwY0QARgb7nJG/iGCKTtbN+14TokWiySpt6VFndVVQfsbeIcI58rLNXnNGknShe3bDc/pqq3RxNz5SitZNvxvJginzSbn0SMaOHV1x8XEvFyZbss23GWB2Bh0OOQ8ekT9dvuQ9z8xy+L5GcPY6j10taQZvxcAACBeXGp5N6zjJuYuiGr8i//8VvghwpwSTXn6J0r72mzdMNCmAUemJkT4V6aB9vO6+M9vadI37458stcIggQAQEwkpKVr0jfvHhIkTPrm3YQIwBgIVM4opaBA0yq2KsFsVr/drvaKLSEbJPuHCDekpynRYlG/3a6uvbVBzz1XXi5TttWnFFIsDDoc6qyuHlJWyaPS9Z+UwkKll5YpOTc36Hg9DQ36dM1qn+fSlpZo2tatIedydsUKn4XalIIC3bTjuZDnnd/ytDqrq32em1ZREVXwYi/IH/JZp5eWaurGxyIeK5RBh0Pde/eqp+Ft454bV97/RItFKYWFSl1aEvXPwPktT6vvyBElZWePyPdjxDuEm1axddihyNnSFWEdl2A2Kzk3T6lLlw5rwb9rb606q6o8O4q8maxWpRQUKr20lFABAACMmbbvfCus4zJf/r0m5kUeJvQefCf8gx/5R6V/bbZ06aQubvnvGix9V6lR/DWp9+A7BAkAAITS9cpudTz95JDnO55+UjdMTPY0YAYw8joqtw9Z5PVe4O5taQm4W8Gff4jQ0/C2LPsbJQXfjeDt3MZyzazdG8V3EViwng/+ehoa1NPQoOTc3KCLwYGCBufRI2HNxztEcH19KKzz+mxDx0/OzQvrXG9Omy3ge3Fx/34pxgvvXXtrdWH79rDee0nqt9vlqKqSo6oq5GdgpM92xPUej2IxVqfN5hOwddXWaMqatcMaM1ijc389DQ3qqNyuKWvWKr20NKLrOG02ndtYHjBA8D7GabPJUV0lc2mZZ4cRAABAPLr49r6ogoS+D94P/+ABh/r/9f/WhceeUs8JaWpkfwWL7prXIIIEAMCwdb2y26exsumrf60bJF36879Jutp0mTABGHn9dvuQO91N2dmaVuG6u76rtkbnystDjuMfInTV1mjymjVKMJvltNlC7kZwc9ps6qqtiUmJI6OeD6H0trSofcvThjsFEsxmmbKz5TxydXHfabNp0OEIesd2T4DdHIMOh6eHRNA5+QUQiVlZUd313llVFfD5frs9rHmEY9DhUHtFhbpqa6Ieo7elRfaC/Kh3XYwm//e0u7Z22EGCW/L8XE3MC/yZDDocnuBk0OHQ+S1Py2mzhd1rxP/3IzErS6nLlvkEVL0tzbrY0CDnkSMadDjUUbldkwoKYr5rCAAAIJRgJYsGOy+oz/ahJKm3ObwSSP76T5wI/+DH7tXpqK4yjGtegwgSAADD4h8iuHsiSPLpmUCYAIyOC9u3+yy0J6Sn66YdzynBbFZvS0vEIcL5LU+rq7ZGCenpMpeWSZLaK7ZENqfKypgsHp/bWB5xiOCWXvZQ0Ncn5ub6BAmSa/E7pbDQ8Bx3U+pAzwdbwA90d3o0uxEkqadxv+Fr3TU1ww4SBh0OnS0rDXqHu5t/GBNIQnr8l9Jxv6fppaXqrK6OaSgzMS83ZCjR29KiT1f/gwY7O9VVW6PUkpKwrt1escXz+2FUmis513V9d7iWkG4mRAAAAGMi85XfB33948+7brLps32g/lMfK3HWzRGNP3ChI+q5RWssrjmaEsZ6AgCAa5dRiJCQlu5pwDxx/tXFsfYnNqjrld1jMVXguhCob0F6WZmnp4F/HwAjGRs3ymS1qqu2xrO7Ib2szBNGRFKmxTOvYdzNLrnu/g+0mD15zRrd3HJIc44c1ZwjR3VzyyHdVLlDyfOvLrymFBSEXIgNtJDvPBJ88fySQRmjS83B359AAYTRXerB9DQ0+AQriVlZvq8HCRnCZVQmJyE9XemlpZpevdvz3s/c+wefzyBtaYnPOSkFBUGDmXjQ4/Wemsse8ryn3TXD+/mNRHJurs/umXCu7f17mVJQELK/R3JurqZX79ZNO3YMb7IAAAAjZFJhkefxpSh3JSC2CBIAAFEJFiK4ESYAo8tR9ZLP14lZWZ5dBOfKN4R1N7+79Ix3CaTErCzPXdQXKsPrjeDPv9xSpLoDBBGT16zRlDVrfcoPJZjNSiks1PTduzW9ercSs7KUEUavgEBBQ7BAYNDhMLxL379sUTjjphREvsB+0a+00qTCQp8wYdDhCNlMO5iOyu0Bz08pKJBlf6Ombnws4Pvm/gymbd0qy/5GpRQUKDEry1NeK565f87cpaYmXQk+ehr3R70bJhrJubkyZWd7rh2KdzgVzs+75PqcaLYMAADilXdfhItv74v4/AmTp8RyOnF7zdFEaSMAQMTCCRHc3GECZY6AkXdxv++C4+S1ayPaRRAoRHCPI7kWpifm5mpimCVeLlRWeh67mwJH0wfAde3OIc+FKpeUnJsrS+OBsMYP1CchWCAQ6v0MVgrHf1xTdnbEC7qDDseQ3SfJuXm67Oj0eb67tiaqXQCDDkfA8MeoZI6RRItFN+14Tv12e9wvWg86HOq58juUusz1s5VWskyd1dVXXmsY1f4OiRaLp5dBKH1eoVa0v2MAAADxZNJdS9Tx9JOSpEstke9ISJwzRwPt52M9rZDXHM8IEgAAEYkkRHAjTABGnnuh3pv7LvdOv50KgRiFCIlZWZ7F0wSzOaKms+6mrm49DQ0yl5WFfX4oCenG/9+JhlGfhECBgP9ugMSsLPV/8onXeYH7JAQKIMINZrz17A+wU6CwUIOdvgFDz/79IZtGB+KorhqygG3Kzo4oRPB2LSxud9Vefd/cP/Mmq9Xz2XbX1o5qkBAoPDMywev9jebzBgAAiDeJs25WomWW+u2nNOhw6FLzuz67FNyMQoaEmzJHeopDJH3xy6N+zdFEaSMAQNiiCRHcKHMEjCz/BWr3Xe7ed1kbMQoRJCnlrrvUe6gloj/uQGOS353wfWE07DWSYB76/5n2ioqoxwskYJ+EMMsXue9gd/PfHeI5L0B/hGgaLfsHGSkFBVf+O3T3QaDQIZTu2tohz4VbMuda1X0lgDFlZ/sEH+5G3b0tLUPCupHU/4nrWt79Pox4N0x2VFeN2JwAAABG06S7lngeG5U3avvOtwL+ufh2/WhN0yN54Z2jfs3RRJAAAAjLcEIEN8IEYORc8lugTr1y53SoReRgIYIkOaqqdHbFioj+uHs1+C+QO48eGTJ+uPxDCUnqqq3Rp2tWx2xxN2CfhAAL//12+5Br+t+p7rTZApakCRSmhGoEHej6/uGQ+/1JMJs9oYJboFAgmEC7W0zZ2RHP81ritNk8oVG6364Z79JQPcPoOREJR1WV5zNIXVYS4mhXgOTeoXOhsnLYzc0BAADigfcOhN4oGi7fEMvJhDAhY6omffPuUbzi6CNIAACEJfkbi5U019X4MZoQwc0/TEiam63kbyyO6VyB65F/GRT3HcrBGgaHChGi1WdzBQbuZrFuRnf3hyOtZNmQ8STXwq69IF/nysuHHSi4+yR46z10aMhx/rsKkufnKtFi8Wl07Dpu6HvvP140/RF6AjZAvrrY7R+6RHonfazKL11LvBfe/Xd1JFosnl0BnaNwt39ndbUu7HD1FzFlZ4fViDvBbPZpZn2uvDymIRsAAMBYmJj3N57HfbYP1H/q46HH5C4w/JOQNXrlNVMf/N6oXWus0CMBABCWRMss3fhilc7/6NGoQwQ3754JU3/5rBIts2I4U+D6ZNQY2Ggh0R0iOG02ddfUhlU+JRjnEZsGO11hhnvnQazrtN+04zmdXnqf5zreumpr1FVbo+TcXKUuW6a0paHv4g7Ev0/CoMMxpEm0fzgzMc/13iXn5vn0J+htafa5mz3QLoVAOy1C6fZrspxSUODzXqcUFOqcfIOhngj6Uwx2Dt1JMd7/P+0uRZW2tCTgz23qshJP2S6nzeZTSigSl1pafJqQe3MesfnsBjFlZ2t69e6wf49SCgt1U+UOnSvfoMHOTvU0NKinwdUgOrWkZFzvKAEAAONTgtmsibkLPH0QLjW/q8RZN/sck/nK7w3PH+x06Ez+woibLp8vsiiSMyZkTFX6w49EdI1rEUECACBs7jBhOCGCmztMiMVYAIYKdPe+mztEkFw7F6bvHl55sa7aGvWWX11cD1TSJxYSLRZZ9jfq09WrDYOT3pYW9ba06ML27coo3+izkB+O5Nw8dVZX+43Z7FO6qKdx/5BzJFeg4B0kXPLbfRDoTv9I+yO4F7K9+YcR7vJG3uWPuvfWhh8kBPj8Ilk4d9psaq/YEvSY6dXxU9Kup6HBsK+Hm3c401lVFXXTaffPZygJZrMyNj4WcRiXUlio5NxGtW/Z4vlZdIdsJqtV6WVlUYdsAAAAY2HSXUWeIOHi2/uUuvz+sM9NSDdr8k8e0/nyH47U9CRJk3/ymBLSY3sTVTwiSAAARCSWC/+ECMDIcS9AOo/4Ljp7hwixEKgskn+Jn1hKMJs1ffduddXW6ML27er/5JOAx/Xb7fp0zWqllSxTRnl52AuyAfskNLd43jP/XQUJ6emec4b0hLhyrPvagfotRHqXeKDa94FK30wqLPQJEtx3unvvrIhEJOHQYGdnWIvl8cLduDoxK8sweEowm5W2tERde2vV07hf06K8VvL8XM8OFn99NpsGHZ3qPdSiQYdDZ0tXeHYZRCLBbNa0rVs1ee1aOapeUndtrQY7O+W02XRuwwZd2L5d0yq2skMBAABcE5K/drW8kTtQiETqtx+Q8/D76np5ZEpUpn23TKnffmBExo43BAkAAADjmCnb6rl7P8FsVndtbcTNd/1llG+UyWo17K3gLoMzkvXZ00qWKa1kmXoaGtRZVWW4Q6GrtkbOIzbNrN0b1rgJZrOS5+f6jOfdJNp/gdx7MTbRYpEpO9unNFJvS4tncdq/P0I05aT8Pzv/skZXnx9a3shR9ZKmbnws5DUCjec8Yot4d8e1YNDh8Ny5H6rM1KTCQnXtrXWdU1sTVSA3MS9XU9asDTkn946CnoYGnSsv17SKioivlWixaOrGxzRlzVp11daqs+ol9X/yifrtdp0tXaG0kmVRjQsAADCakqxfVKJllvrtpzTocKjP9oGSrF+MaIyMn23RoOOCeurC+zdBuFKKlyrjZ8F34o4nBAkAAADjgP8CdqA67oMOx7DvFJ9WURE0RJCkBLNrt5F/kDASOxVSCguVUlgop82mzqoqn9JCbk6bTR2V20Mu4LpNzPMLErx2FvjvKpjotwvBv8fCxYYGpRQWqt9uH3JXv9Gd6Ua86+e7DXZ2GtbcT7RYfI6/uH+/FEaQEMjAqfHZtLdn/9XG1Zc7uwzfS38Xr/QeGAnuHQWS1LW3Vl21NcPqcZBgNstcViZzWZkcVVW6ULldg52dnt0thAkAACDeTcxboP6a30mSet7ep8kRBgmSNG3bDiWYJ8dsZ0Lad8uuqxBBIkgAAAAYF/xrcvbb7TJZrUMWxYfDXRYpWIggXV1c77ef8nl+JBv2mqxWTdu6VellZTpXvsFnMV+SOqurww4SknPzdEG+C8runQVDdhX4Le7691hwv/e9AcsaRdYfIVBZo3Br7ksKu1FwSkHhkAX1SMr5JFosmrxmjefrgVP2gAFPPPD+rAK9v0Z69u/3KVs1EjI2bvS8b51VL8WkFJG5rEzJubk6W7rCEybQiBkAAMS7SXctUfeVIOHi2/Wa/Gh0PQ8yfrZFpnlf1oX/6+mIGzC7TciYqsk/eey6KWfkjSABAABgHPAPDHpbmpVSWKi0kmURL1j3tjQPWUgON0SQ5CmB46497z3HkWayWjW9erdOL73Pp3+CezdGOAumgY5xHrEpwWwe0h/Bf1He/9x+u139drsuNfsu9nv3VghX997hb8UOp1GwyWpVYlbWkPcv3HI+iRaLT2jT29ISl0GCd+NqU3Z22A3y3L9nXbXhN7COhneZLf8AazhMVqtu2vGczpaukBS7kAIAAGCkTMy72iehz/bBsG7oSP32A5q05B51vvi8ul/9p7ADhQkZU5X64PeU/vAj10Vj5UAIEgAAAMYBU7bvgra7jE2ixRJxg932Ct8tupGECKbsbM/1vJv9SpHfgR+tBLNZqcuWDQlDXDskwlsw9e+T4B8ESIEDhwSzOUCfhOYhu0IiXbjtaWiIqOGx4Thh7ixIzs0bsvjfXlGhlILCEb0LfzQ5ql7yPL5px3Nh/57Y8xer/5NP1L13ZIMESUqyZnuaL8dScm6u5+c0liEFAADASEgwmzUxd4Gn2fLFt/cpdfn90Y+XbtbkH6zX5B+s18V/fku9B99R3wfvy/n+v+vy4KDnmKRbb1XSF7+s5IV3atI3747J93ItI0gAAAAYBwLdCd9esSXsu2VSS0qUaLG4mhNfuUtbiixEkKSMKzX4/cvERHMHvj/3roJom/5GUlppSJ+Eo0c8vR/cjJrzTios9AkS3LsSfMaPMFTx390hSTdV7gi5qN/T8LZP+Z5Bh0M9V/o2BDN57dohQcKgw6GzZaWaXlUdUZjg/fMUTy5eCbq8w69wuEMqp80WVqmo4RgYwYbl7v83xDqkAAAAGAmT7iryBAmXmv/XsIIEn3G/ebcmffNu9Z/6WKf/j69Jcv3bxfJefP4ddiwRJAAAAIwDCWazUgoKfHYBOKrCaySWmJXlqWnvfRd/pCFC8vxcT1jgvxsgpSC6xX9v7RUV6qqtUUphoaZtqTBczB50ONRdO7SUTkJ6eoCjA/PvkzDocPiU+nEfE865gRr4RhKqDDoc6mn03d1hys4OK1BJtFh8ggTpagPoUOell5YOOddps+lsWaluqtwRcvF90OHQhR2VYf8cjqbelhZPuJMe4a6CtJKru126ams01RpdA+twuAOpSH52IzWSYwMAAMRK8teulje62FAf8/Evvr3P89i7lBKuShjrCQAAACA2jO6QD2Xa1mckuRZF3YurkYYICenpyti4ccg4bpPXhtfo2EhXbY1nl0NPQ4PshQU6V14+pGRQb0uLzpaVDrl+YlZWRHeOB+yT4HVnfWJWluFCeqiQIFBvhWB69g8ta5QaRq8CyRUImLKzfZ7r2lsb1l3oU9asHXKu5Hof7AX5Ad9/9+vtFVtkLyyIyxBBkrprru6YiTTk8n5PY9G3woh32BFqjoMOR8DAyki/3e757OiPAAAArgVJ1i96dhgPOhzqs30Q0/EvNb/reTzpriUxHXu8IEgAAAAYJ9JKlikxKyuicwLtIog0RHCds1Umq1WDDofaKyqGXCPSPg3eXGWafMd0N/89u2KFTmTf5vlztnRFwFI66WUPRXzd5PnGC6yh+j0EPzeyhdtAZY0iKe8UKHTo2T90TH8JZrNu2vGc4R3r3u//x7nzZS/I14ns23S6ZKkcVVVxWzLHe4dHSkFBVD0f3LsY3KWiYs1ps+nTNas9X4cK4s5tLFdH5XadLlkaspTUoMPhM3Y0vxsAAABjYWLeAs/jHq8dBLHgvcvB+zq4itJGAAAA48jktWvDXvx3Hy9JHZXb1W+3K720VGkly67cVV4R4myXaRUVnoXts2WlQxaQp23dGvZ8AklIT1fy/PlDmjeHK3l+blRNcf37JPi/FsykwkLDcyPZOTLocAz5viOt6Z9SWDikgfbFhgalhbGrIdFi0cy9f9Cnq//Bp+9DoHkaBQcJ6eka7OwMe74Bx+/qNHw/jRiFOd47PMLd2eEvpaBQ5+T6PQunVJTbgP2ToN/HoKNTFxsafHqMTKuoCPp5Dzoc6j91SpIrgDhdslQphYVKLVnm87PiDlAubN/utdOhgB0JAADgmjHpriXqrvmdJOni2/Wa/OgPYzKud1mjJOvtSpx1c0zGHW8IEgAAAMaRtJJl6q6pDWvR1b0bYdDhUGd1tdKWlmjqxsc8dfBD3VGekJ6uaRVbPYuo58rLh9wNPXnNmmHtRpCu3hnvqKrShcrtES1KpxQUaFpFdEGGf68D33GDLxwHW5wNtZvBW6CdA5EufrtL8XgHAT3792vQ4QjrbvxEi0XTq3ero3L7kJ4JoSTPz9W0rVtlL8iP6Dx/TptNZ1esiOicOUeOBnze3T8jIT096sbdCWaz0paWqGtvrbr21ipj48aw3kvvEl0hr3GlXFiowCfBbB7y+fQ0NITcKZE8Pzfq3w0AAICx4N27oM/2Qdh/nw3Fu6xRMv0RDFHaCAAAYJyZtnVrWA1U3bsRHNVVSskv0LStW8MOEZLn52p69W6lFBZq0OHQufLyIQukpuxsTVkzvN4I3sxlZbLsb1RG+caQJZwSs7I0raLCVZonyn9cGIUBpuzskGOarNaAn0Gw3gqBBFq4j2bxO1D40BWgIbWRBLNZUzc+Jsv+RqWXloZ8/1MKCnRT5Q5N37172EFSLPXb7eptcYVsw20A7r2zJJxSUeFKnp+rjPKNsuxvDGvXiOT7+aQtLQn6++/+3Zi+e3dM/uENAAAwWhLMZiVZb/d8fTFG5Y28yxrRH8HYDZcvX7481pMAAABAbIXqb5C2tETTtm7VoMOhjsrtYe9ESCkoUHrZQ55F9kGHQ2fLSofsREhIT9fMvX8Y0UXkQYdDziNH1NvS7HnOlG2VyWqNq8Xr8cpps2mws9Pn/U/OzQsraMHIc9psch6xecoYuXamWCNq9A0AABBvLjz7Kzme/bUkVy+DWOwguPDsryS5/g1jec+4nGc8c1z5N1xra2vMx87JyZFEkAAAADBudVRu9zRQ9mfZ36hEi0X9drsSLZYhIYIpO1sJ6a7F4Il5rmbJKQWFPgvEndXV6qjcPiR4SEhP1/Tq3SxYAgAAAIipPtsHOlP8zREZe1JhkW584f8ZkbFH2mgECfRIAAAAGKemrFnr6X/gLW1pieeO/UAhgnu3QiCBGrZ6I0QAAAAAMFKSrF9UQnp6RH3TwkVZo+AIEgAAAMaAB9H0AAAgAElEQVSxqRsfk8lq9Slz5O6NIGnoTgSr1fP6oMMh51HX1t4+2xH1NLztqS8fiCk7WzfteI6yQgAAAABGzJTHn1K//eOYjzsxb0HMxxxPKG0EAABwHehtadG5Des1qbBQUzc+JmloiDAck9esiWljZQAAAABAeChtBAAAgJhIzs3VzL1/8HwdqxAhbWmJJq9dyy4EAAAAABjHCBIAAACuE96NkiUpJb9APfsbIq4vmpCertSSEpnLHiJAAAAAADDqLv3pkC4d+ldNyJyh1PuWSRMmRDxGb9O/6FLre0q65XNK+dt7R2CW4wuljQAAAK5zvS0t6m1pVp/Npn67Xc4jR3xeN2VnK9FiUZLVquTcPCXn5o7RTAEAAABc7xzP/loXnv2V5+ukz8/VTS//ThOm3Rj2GOef2KDuV3Z7vp6Yu0CZr/w+pvMcTaNR2oggAQAAAAAAAAAQ9wbPfSZ73l8Ned78P1Zr8o83hjWG8z/+XWdL7hnyfMbPtijtu2XDnuNYGI0gISHmIwMAAAAAAAAAEGPOo0cCP/8f/x7+GEc+DPz84f+Iak7XC4IEAAAAAAAAAEDcM92WHfj5Lw3dpWA4RvbtgZ+f96Wo5nS9IEgAAAAAAAAAAMS9hGk3avKjP/R5Lunzc5X2f64KewzTl/5Kqd9Z4fNcct7fXLNljUYLPRIAAAAAAAAAANeMS386pEuH/lUTMmco9b5l0oQJEY/R2/QvutT6npJu+ZxS/vbeEZjl6KHZshfbb76vdX/olmTRw89v0/JZQQ5uq9e6lbtkU5G21q1UTlhXaFPdj9Zox1GpePPrWh3eScZad2nJpnrJew6eeUXGuqpS24ozvcYM11yt3vVzFWf6z0kK632UpFN1WvXIbp2UJKP3c6BbJw/W69X6Rh060qYupyQlKS1zlqwL8rX83iLlZPqfBAAAAAAAAAAYLpotu/U26423uiVTkkyy69V9x8Z6RuOAXfUt9pBHnWyqvxIiGPisWdtWrdKqX7ymA++7QwRJ6lNX23Ed+sMubVj5XW2oC30tAAAAAAAAAED8SRzrCYTD+W/NOuCU0u7J1/w363XgrX06+L25Wpg81jOLUGaRttUVDXn6TN3jemjnMem2lXrpl0WaEXKgSHZaBGBKksnZp5ONf9bJZRbNNjzQroONbcbjDNj16pO/Un2bZPpckdb9Y7EWzsmU6cpOImfbcR3c+4K21R1X687HtS2rUuvuSI121gAAAAAAAACAMXAN7Ejo0IH6JklJWrzgAS1anCQ5m1TX1DHWE7t23ZKnhXMknajXwRNBjjvaqD2npRlfXyRroNf/s1F7Tkgy52vTlpVa/LmrIYIkmTJv0eJVz+iZZVMkdav+1SadieX3AQAAAAAAAAAYcfEfJJx6R3taJZnytfBLqZq/IE8mSa173wlecgdB3KZF+RZJbap/17jkkO2dRnUpU0ULbgv4evv/Pq4uSZp5i24OstHAuqRYt0oytbWrfTjTBgAAAAAAAACMurgPEk62NOqkpLS771TOBMmUu0TFZkknalT/4VjP7tp1a26+Zks609gcOJAZOKamA93SnCItnBt4jIz/dovSJOn4UdkcQS42s1g76l7XG9UPBN7ZAAAAAAAAAACIW/EdJAwcU/0eu6RUFd15ZTV7wlwtKkyV1K26fc1yBjsfxmblqfg2SacbA5c3Otqseoc0O/+rxj0UPl+ksttdpaaeWblOm15ulO1Ut5wDIzdtAAAAAAAAAMDoiutmy86WfapzSJqzTEVe1XWsdy3T7JrdOnmgXge+n6eijDGb4hip14bi+pBHWVdValtxpsGrmZr/jbnS0WOqf9euB+dYfF5t/Zd96tJclS2ySDoceIgJmSp+4qc6v+lnevUvdh167QUdeu0FSUnK+MI85S7I0+I7vqrb50zx6Z0AAAAAAAAAALh2xPGOhD4dete148BalOd7V/ysO7U8R5IOa88B4xr/CG5G3p2yKkB5o4HDOtjQJ+Xka5FRDuGWOldlv35Zr/7PR1X29XmaYU6S1Kf2v7yn+uoXtOEfV+neB9Zr2x/5nAAAAAAAAADgWhS/OxLa31HdgT5J87RkyGr2FOV+Y57Uelgn9zTKdt8KWa+rO96LtLVupXKGO0xmnpbk7JKttVEHTyzT7Dmup50tjap3Sjnf+KrC3eyR8blFevDHi/SgJPW26aNjh9VS36Q3Wg6rvfe46n+xTi0fPKEXH5nn6qsAAAAAAAAAALgmxG2QcPJAnVolSYe1rfR+bTM60LFPb7Q8IOuCpFGb2/hxNZDZ03hMD35/rq7uBJmnxXdMiW7Y5Ezd+uV83frlfD040K2P3nxBj+9sVvubz+rV/J16+LbQQwAAAAAAAAAA4kOcljay61CjXVKS0jIzNWOmwZ8rZXQOvPmO2sd6yteojDsWKUdSV0OzbJLU+2c1HeiT7sjXwmDbEZzv6cWV39e9xY+r7rMgx01I1a3Fj2rN1yWpQx8ea4vh7AEAAAAAAAAAIy0+dyR82KhXT0gy5evxnSuVY1S26MPd+tb6OnW11qnxVL6WzxrNSY4TGXkquuMFtf6pUU1HV+jWT5t1QNLiwrzgJYhMmUqb0C2njulga4eKC4PtXkhSKvWMAAAAAAAAAOCaFIc7Evp0cN8+dUlKu/tO4xBBkm7P14NzJMmuV/cdG53pjTupmv+Nr0jqVv3/OqxD7zZJWqRFfx2qVJRFC5dYJEmtL1frYLBdCd3v6UCTJCXp8zeH6t4MAAAAAAAAAIgn8Rck9P5ZTQf7JKWq6G/mhjjYovn5rsXsrrf26WDviM9uXEq7407Nl9TV8Ctt+6NkWpyn+cmhz5tdtFLFN0r6rEmb/8caba45rJPdfVcP6G3TR398TZse/aXqHZLp9lItH3aHaAAAAAAAAADAaIq70kbtTfU64JRkztei20MfP3txsXJ++4JanU2qayrVQp8SO/XaUFwf9HzrqkptK/a9S75u0/2qC3bSbSv10i+LNCP09EZI6O/LLdD3N4Q5T0u+Lh36Y7e6lKTFC74qUziDp87T6l/8UM71z6q+rU0Hf/uUDv428KGmLyzTM0+M5XsGAAAAAAAAAIhGnO1IaFPTvsOSpNnL82UN55SMO1X8ddfD1r3v6OSIzW08S9L8BYtcD035KsoNVdbIy415WrfzJb20eaWW595ypQH2FclTdGtusVZvrtQbv35A1tTYzhoAAAAAAAAAMPJuuHz58uWxngQAAAAAAAAAAIicw+GQJLW2tsZ87JwcV636ONuRAAAAAAAAAAAA4glBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMJY71BAAAGEtLiu8f6ykAAAAAAABE7fWXfzPi12BHAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwFDiWE/A35Li+8d6CgCAEbSv7vWxngIAAAAAAAAiwI4EAAAAAAAAAABgiCABAAAAAAAAAAAYirvSRpS8AAAAAAAAAAAgfrAjAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGEsd6AuGy/eb7WveHbkkWPfz8Ni2fFeTgtnqtW7lLNqPXTamaMWeuFi8t1fKFFqVNCHHx9uM60FCn+rcP68PTHXL6jPGA7l14izKMxmjdpSWb6iUVaWvdSuUEvdBh7Sh+SnWaq9W7fq7iTOlM3eN6aOexEBP0d/V8AAAAAAAAAACG49rYkdDbrDfe6pZMSTLJrlf3Rbqw7sfZrTN/eU+v/mKdvvNkvc4MGBw30K3Wl9fr3tL1eqa6Sa2nu2XKzNSMmZmakey8MsZ6PfjAer34p47hzQkAAAAAAAAAgDh0TexIcP5bsw44pbR78jX/zXodeGufDn5vrhYmhzrTYBeAs1snW1/TM8/U66PWau34Y542L57id1C3Wneu04Y3OyRTphY+9KjWFM1VhsnrkPZjqtv5rF5sOq49T67WR49s09Z7YrsNYEbxz7Wv2P/ZNtX9aI12HJWsqyq1ja0HAAAAAAAAAIARcg3sSOjQgfomSUlavOABLVqcJDmbVNc0jB0AplTNzl2p9d+1SOrToX3Navc75MybFXrizQ7JNFerKyu1qdgvRJCkjLkqXl+pnavmyqQ+tT5foVdPRD8tAAAAAAAAAADiTfwHCafe0Z5WSaZ8LfxSquYvyJNJUuved3RymEPP/tw814MB6ZL3C73Nqtp1TE4lafG6chXPDD7OjOJyrf96kiS7qn7TOCSUAAAAAAAAAADgWhX3QcLJlkadlJR2953KmSCZcpeo2CzpRI3qPxzm2P91WJJkypqiqV7Pu0spybxE9y5IDWOkVC28f7lmSFJro5rahjcvAAAAAAAAAADiRXwHCQPHVL/HLilVRXfOdT03Ya4WFaZK6lbdvmY5oxnX2aGP/rhLz7xsl0xz9fCDrl0Obh9+2Ox6kDtP1glhjjlnnhaaJemYPjzWF82sAAAAAAAAAACIO3HdbNnZsk91DklzlqnotqvPW+9aptk1u3XyQL0OfD9PRRlGI9RrQ3G98QVm5mvTz/9eC316FXfo449cQcCt/80SwWynaMZMSQ7pTHu7JBogAwAAAAAAAACufXG8I6FPh9517TiwFuVptvdLs+7U8hxJOqw9B+zRX+J0o57ZuluHPvN+0ikNuB6Zonx3bKeobQQAAAAAAAAAGB/id0dC+zuqO9AnaZ6WLPK/u3+Kcr8xT2o9rJN7GmW7b4VBCaIiba1bqRz/pwf6dOZEs/b8z+dV95c6bfqxU1ufX6mc5NhM3TqL3QgAAAAAAAAAgPEhboOEkwfq1CpJOqxtpfdrm9GBjn16o+UBWRckhT/4hCTN+Nwird6SKueqCtV/Vq+qt4uVU5wpKVM3z02SjvbJ9l92hV+iqENnTrsezcjwqrU0yaQ0SV3hDDHQF13PBwAAAAAAAAAARkicljay61CjXVKS0jIzNWOmwR9zkqQ+HXjzHbVHc5nUr2jxItdD73JEt9+e53rQcli2gTDHOnFYBx2SNFe3z/UKNTIydbMkqU3tjhBjnGvTyTAvBwAAAAAAAADAaIjPHQkfNurVE5JM+Xp850rlBCxbJOnD3frW+jp1tdap8VS+ls+KzeVNf52nxaYmHXDs0yt/LNbmxVNCnNGtQ3vrdEaScvLlU4lpWqZmS7LpmP7zlLT4duNRnMeOyiZJplt0M9WRAAAAAAAAAABxIA53JPTp4L596pKUdvedxiGCJN2erwfnSJJdr+47Fvmleg/rYJProU9fg+Q8la2cK5P6dKjyl9pzKvgwZ+oqtLmhW5JFZX+XrwzvFyfMVc4dktStuqp6nTHa4TDQprq9rsmYFs5TkLwBAAAAAAAAAIBRE39BQu+f1XSwT1Kqiv5mboiDLZqfb5Ekdb21Twd7w7+M89R7enFjheockkxf0b1+DZ1n3FOup+6ZIjmP6cV/XKPNdcfU7h8CtB/XgZ3rtWrnMTmVJOuq8ivBhrdULX6wWBmSnB/u0qof79ahU91yusca6NOZ/2rSiz9epxePStJclT2YJ1P43woAAAAAAAAAACMm7kobtTfV64BTkjlfi8K4LX/24mLl/PYFtTqbVNdUqoWF3mWI6rWhuD74AKZMFW96VIsz/F9IVc4j27Rj+q+07reHdXDn4zq4M0lpmRlKmyCpu11nHH2uQ5Nv0fIN5Xr4DoMSSLet0LYftGlDZbPO/KVOmx6pM5jLLVq+uVzLZ4b+vgEAAAAAAAAAGA1xFiS0qWnfYUnS7OX5soZzSsadKv76C2r9o9S69x2dLCzW7JAnJSlj5ix9PrdI31meL+uQEMEtVbcue0JvFNp1oH6P6t8+rA9Pt7l6ISRP0Ywvz1NRUbGWLLxFGcFKMEmasfiHeinnuA68+Zp+/y/H9fHpDjk9c7lNOXfl68GiRZptDuebBgAAAAAAAABgdNxw+fLly2M9CQAAxsqS4vvHegoAAAAAAABRe/3l30iSWltbYz52Tk6OpHjskQAAAAAAAAAAAOIGQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwBBBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwBBBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQ4ljPQF/S4rvH+spAABG0L6618d6CgAAAAAAAIgAOxIAAAAAAAAAAIAhggQAAAAAAAAAAGAo7kobUfICAAAAAAAAAID4wY4EAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGAocawnEFBbvdat3CWbirS1bqVyohljoEMfHWzU7+sb1XqsTe29kpSktMxZsuYX66F7FunWjDDHcraptb5R9f/a5DWWZMrI1O25xXpgeb5yZiaFN9Tpw6r/f+u0791j+ritW05JSp6iGXO/quXfXqaiL2XKNCHQmW2q+9Ea7TgqWVdValtxZtDrnKl7XA/tPCbd84T2PTJPktT6/P3a8GaY37PHMD4DAAAAAAAAAMA1Lz6DhGHqev81rd9co4/cC/7mTM3IkDTQrfNtx3XotWd16LXndet9P9LPv/8VZQRcuHc52fArPfF8s844/caSU+dPt6m1fpda66s1o/BRbVuTZzzWgF31v6zQjqY2V3igJGXMzNRUSZfa23Tm/UbteL9RL2bm6eENf6/iL6TG5s0AAAAAAAAAAGAYxl2Q0NW6Sw9vqle7kjRjUanWr8qXNcNrt8BAh2xv7tIzLzXroz9UqOzESu18skgzhgQA3bL99imtrzkup5J0632P6AfL/XYxDPTpzJ+qtfmZen3U8Cv9g+kJvfjIPKX5DzXQprqNP9GOD/uk5Fu0/MePquwOi8/OA+fp91T1i19qz1+atWPDcZ3c9IxW58Q2TMh55HXte8T/2cPaUfyU6iQVb35dq9l6AOA6s6/u9bGeAgAAAAAAQNQcDseIX2N89Uhoq9emza4Qwbpqm15aX+QbIkjShCmyFv9QL1WulNUkOVt36Ynf2YcM5Xz/NT1Vc1xOTVHxkzu14+8ClEKakKQZuSu1o3KFrJLa39yluhP+I/WpddfjrhDhxiJtfekZPZxrGVK+yDTzK3r41zu19Z4pkrNNdZt36WD3MN8PAAAAAAAAAACGaRwFCX06+E/Vsjkl09cf1eYQPQQ0s0ib1y2SSdLJl3epvt37RbvqdtarXVLGsh9p9R0hdgbMLNaq+1Il2bXn7WO+r53ap+fqOiRZVPbkSgXfZJCqnFU/VdkcSc4mbXv1WLCDAQAAAAAAAAAYceMnSOj9s5oO9ElKVfHf5g0tLxRA2qLlenCmJB3Wvqa2qy+caL6ys2CeHlo6N6zLW+8s0uzMeZqfpSs9EFxONtXrpCTlFGvJnDAGmmDR8gcWSZK63npHrQNhXR4AAAAAAAAAgBExfoKEY4d1UJKUp5zbwj3JopwFri0CtiPHPQHAmdZmnZGkz31Ff+VfzsjIbQ9o564ntP6euTJ5nuzQv7/nCihu/et5Cnco05e/qvmS5HxPtlNhngQAAAAAAAAAwAgYN0FC+6krQcDnLLp5SONkYxk3WlwPznbo/JXnznxy3PUg+xbNGNasTunkf7oefX5WiFJL3sxTrly3TefbQxwLAAAAAAAAAMAIShzrCcTKJXcJoCRT0OMMHT2lM1J4wUFbvdat3CVbwBfnavWun8vTouHKNgf/5srh+s+P26ScCEIIAAAAAAAAAABiaNzsSBi222YNc/fByPj8zYQIAAAAAAAAAICxM252JMyYc4tMOibn0eP6eECaEeYOgPbP7K4H06doqnusrFskHZf+t13tCtDbILNI2+qK/J48rB3FT6nO57lZmn27pA+lD09EsLPA0eHq0aBMTfVcPFVp4XSQdhvsi+BgAAAAAAAAAAACGz87EubO00JJUrNaj4Z7kl2t73ZLkqzZt3iaJM/Inqc0SfqwWS3D6lEwRX/1FVd48NG/HVa4Qznf/7MOSZLpK7LOcj+bqozprkcff9YRcgxPnwcAAAAAAAAAAIZh/AQJyV/VosVJkrpV93pTWIv2XX+q057TkjRPSxZ57Ra4LV8PzpGkw9pTbx/WtGYvKtJsSWp9Tb8PJ+AYaFPd3iZJUtrddyrHa2eFa6eE1PVfp0J8f3bZ3nM9ss6ZFfRIAAAAAAAAAACCGT9BgpK08Hulspok55+e11N/CBEAnK7Xpi2N6pI0+7srVeRTv8iior8rUoakky//TDv+1B18rIFutf52t+oDvTZrif6heIqkDu3ZukuHHMEG6lbrzsf14lFJpkVa9+Bcn1c9OyVaX9MrrcZzuhqQWLToy1OCzx0AAAAAAAAAgCDGUZAgKbNImzcVKUN9sv3mJ3romXrZ/G/dH+jQR3/cpdVrdsnmlEy3r9RT37YMGSotZ6W2rZorkzpU9+Qqra5slK3dr+/AQJ/OtNZp86pV2lBzXE4l6dYHSrXYpxVCknJW/lyrb0+SPqvXppXr9WJLm5wDvkM5Tx/Wni3rtOHNDklTVLxppRam+k3qtmKtviNJUofqNq/X5rpjOtPrNUa3Xa01v9KaKwFJWmGpitiQAAAAAAAAAAAYhhsuX758eawnMURbvdat3CVbGIdaV1VqW7FvE+Ouv9Tp5xt3q/XKIrvJnKmpqZIGunW+rVtOSVKSbr3vR/r597+ijCCNmdv/tFuPb63TR+4F++QpmpFhkuTU+dMdV8aSTJl5enjD36v4C/6r/1cMdOhg5eN6pqHNc/2MmRmaKOlSe5vae8Mcp/uYqjb9TK/+JXgz5YwFj2rb+kVhNJ2+2iS6ePPrWp0T6ngAAAAAAAAAQLxwOFxlcFpbW2M+dk6Oa8E4MeYjx4G0LxRr62v5OnmwXq/WN6r1WJvOOCTX4v08LbwrX98qXKRbM/5/9u4/Pqr6TvT/a2lIO5dGTFxGdmSDNsXAMtiRJbZRaB/ECq2I+DWsm95iLQ+XPlbr0lu8RbvQVqt8q3SLt1RpV9ov3Su95lrwFikWYg3fGlq0YXGUoTDSVJiVWRxrqEa+YyGl3z8mgSTkkMkv4o/X8/Hw8cDJmXM+55zPeZ8zn/f5fD49rQmK//Z6Hqi9ltS/b2PLlnp+ufclDv1nbrLjwrPCxGJVTL96KjPLw6df0XvO5rIv3M9jn0qw8bGNbN7+Av/xnxkOt62n7KIP84nZM5k5KUzh6Rr/R1zIDd/8ITN31fPwjzfy3P7DHHr92Iny/PX43Hpmx3oojyRJkiRJkiRJeXhr9kiQJEmSJEmSJEk9OhM9Et5ZcyRIkiRJkiRJkqQBZSJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgQqGugBdfWL2dUNdBEnSINq88ZGhLoIkSZIkSZJ6wR4JkiRJkiRJkiQpkIkESZIkSZIkSZIU6C03tJFDXkiSJEmSJEmS9NZhjwRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSBUXRfMAACAASURBVJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAFQ12AbmW28MUbf8CeHhYrPCvMX4//MJ+YM5vZF53ddSVs/O+38ECyF9u98qtsvinaTXkSbHxsI5ufStB0+Fjus/edzegLo8ycWc3sy87j/e855Ut9336e+9/VhM/dz32zw3kvv+f78/nihiPAeSz47n1UjznNwnmUqfCsMCXnR6n+u2uZHetSjv5+Px+9PU8DeJx7PJb93VYfvj/7rkf4fKyXG5QkSZIkSZKkLt7iPRKG8/5wmNF/1c1/4RHweoamX2/kgSWf54sbM4Ow/SM0Pfp1rr7x6zyw4dmTjdMAb/6BQ89v49+++UX+6+d+QOPrg7D5wfTmMzz2syNQOJxCDvLw5hf6vcqjr2c49Hw9D3zlFj713QRvnLHvD/F5GoRjKUmSJEmSJElvFW/NHgknXMAN37ibwJfs/5Sh8Qff4q6NL7LnwW+w/uLu36rv7Zv67d7Y9gO+uCbBUc7msvkLuWFmOaUjhuf+ePQIqd/U82/ffohfZrbwla+H+eG9sxl9Ss+EPmw/PJP7Ns485eNDG5fy2QdfgPIb+eG/zGR0r/fopKM7nmHrUXj/lVVUPL6FrT/bzC/nXchl7+vpmxfy+R8EnJM3D9L4P1dy18YXOfz4N3hg0oPcNnXEAH//VH0+TwN0nPM6lgN2Tk9z/CRJkiRJkiRpELzFeyT04D1hKj63kE/9FcBB6v99IHslHKHx59s4Ckz4h7v5yrXRk43TAIUjKI3N5isrFlJRCCRrWb9rADc/qP7A1i3bgOFMr6xh6vThcHQbG7f9oX+rfd95VHzuq9z20eHAMbb+/Nne9Uro0/eH+jwN0rGUJEmSJEmSpLeIt3ciAYDz+ODE3L+a0gOZSDjIb3fn/vXBsad5/bt4Kld/FCgs5NDv3yaNxy81sD4OFFZx2aQRVFR+mEIg/pMGUv1eeW59AOxK8ttB//4Qn6dBPZaSJEmSJEmSNPTe/omEI89Q/1TunxXjLxjAFZ9MUDy3+8XTLlnxhUfYvH4Nd32864TPb02pX9eTAt7/yWnE3gOFl3yC2WcBBx5ly28GcEPvK+S9g/79oT1PZ+xYSpIkSZIkSdIQefsmEv50jEO/28YD/7ySrUeBv5xJdWXP4+nnbwQV18ykGEjVLmXubd9j469f5NCbA7iJofCnF9iy/iAwgpnTLsx99p4LmfrxEcARNm5+hqP92sARGrc/k/tn7ELKBv37Q3ieBv1YSpIkSZIkSdLQe4tPtvwCD9x4HQ/0sFThuNl85Z+vJxYwUfCeB2/hEw/2tK2Z3LPxRmIdPnl/7EbuW/QHbr//GQ79pp4HflOf295ZYf4mNpXLPjyZD11yIaU9TFDc1+0PhqO/3szG14Gx1zKz/OTnE664ltJHHyK1dQtb53+YmcV9WHfmBbasWcnqbceAs5k9czKFZ+D7A3Weemswj2Ww/K4Jrvwqm2+KDuSGJUmSJEmSJL1LvcUTCcN5f7iY97/n5CdvvJrhjaMAZ3PZ/M8w95IPM2HM8KAV9Nvo6bfyw8syxLdsYf3WBp7b9weOvp4h/tSjxJ96FBjO6L+t5r8tupbYWYNWjAFyjMbtubfkJ8z8MKUd/zRmGtWxh7gvnmD91oPMvPa8gHXk05A9nAnzv8aCi7o7L/39fvfO/HkaiGMpSZIkSZIkSW99b/FEwgXc8I27md1xDt0/Zdj67aXcu/UP/HLjM0ytnMqEHtYy4XP3c9/s00zE25PCMLHZ1xObfT386Rhv/OeLND77DPVb6nnuwBEO/Xstt8/fyefvv5vZfzUI2x8ohxvYuPUYEOUTU7uW52wu+VgU4glS6+vZM+d6Jrynu5UEKywO8zeTqph53Uymj+39MFP9/X5/z1OvDPKxDHYhn/9Bl2tCkiRJkiRJkgbRWzyR0I33hJn+hbt54+Uv8sBvnuHef/4BxfffSGwgp0c47faH8/4xFzJ9zIVMn309ZJ7lgWX/wsbfvcDqf93G1DumMqAj2Qyg1NaNxAFIcN9nruO+oAVf38xjv65hQmV3PQL625B9hhrCB/k8DcyxlCRJkiRJkqS3vrfnZMvvCTP71s8woRD4/Ra+uuoZ3hjgTRx6/Bt86u+u4+oHE6dfMHwxn19UzWjg6L8nOTDA5Rg4B2msP0huuKgwo/8q4L+zhgPH2Pp4A4eHush5GJrz9M48lpIkSZIkSZLUnbdfj4R24Znc9pkGPvv9Fzj61PdYXRXli387cN0SSs4aweE3gV88y54bo6cfmiY0gmLg0IBtfRD8pp6HDwCFVSx98EZiQfvzm4eYe9tG3ohvpP6lKqrHnMlC9t6QnKd36LGUJEmSJEmSpO68PXsktBl91U3cMBbgCFvuf5Q9fxq4dRdO+TDTC4HXN/Pgj188bY+HQ9sb2ANQPobRA1eEAXSMX27ezBvA+z85LbjhG+BvqvjUWICDPLz5hTNTvH448+fpnXssJUmSJEmSJKk7b+tEAu85j+rPzcyNdf/7jdz344MDt+73fZgbPnshhRxjz49u478ueoitv8twtD1Z8adjvPFSgo3338bnvv8CcDazP1P11kwkvLmTbb88Boxg5qUX9rDweVRUnQfAGz/bzC/fHPTS9c+ZPk/v5GMpSZIkSZIkSd14+w5t1Kbwohpu+Wg9dz11jNSPv8vGqlMn8t3z4C184sF81jaTezbeSKzt/0bP/jL3HfsWX1yT4Oi+jdz7hY0BhQhz2S1f5fMXdT+hbl+3P1AOb9vC1qPAWVVM/Zuely+dPpvYmu8RP7qNjds+w2UfP3uASzSwBuo85WPoj+ULPHDjdTyQz6JXfpXNN0X7uT1JkiRJkiRJ73Zv7x4JAIzgsn+4iYpC4OgLrP63gZx4eQRl136Vx/7nvdz2manE/upsCk/8bTjvD0eZ/pmFPLjmfr4yPXya9QylDNs25yYiLq2uYkI+XymexuyP5v4Z/0kDqUEr20A5U+fp3XAsJUmSJEmSJKmzv/jzn//856EuhCRJkiRJkiRJ6r3XX38dgHg8PuDrjsVy4+e8A3okSJIkSZIkSZKkwWIiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAhUMdQEkSRpKzc1/GOoiSJIkSZKkd4GSkrOHugh9Zo8ESZIkSZIkSZIUyESCJEmSJEmSJEkK5NBGkqR3tbdzt0JJkiRJkqQzwR4JkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgIVDHUBuvrE7OuGugiSpEG0eeMjQ10ESZIkSZIk9YI9EiRJkiRJkiRJUiATCZIkSZIkSZIkKdBbbmgjh7yQJEmSJEmSJOmtwx4JkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFes8dd9xxx1AXQpKkobLiyQyVHxgxRFtvpXnnIzT8IUrZqCEqwkB7pZ4Vd/0rG14ezccvCuc+272W21f8L57/i4uG8FjTx7K00rLvl/yfH69n/U82sLnu5/z85z/n/33mefY2F3DeeedR9N6Oy2eo/9Zd/Otjhxj98YsID1CxM0+u4K4HN/Dzn/+82/9y5QlR9sHRhM7AayKJH93Oiv/1PMM+VMkFfT2lLU3U/yzJiPF/TfsqBmS9p9PaTHxdA69NLOMvB2H1/dbL+jnox0tvI/2LPW/LutRNDMnf4MTq/ur+PHTzrNDdvVYDZlCvh16cu6G4Llua6tn8wgjGj3m7BIIB9lZ6ZpWkXvrjH/8IwKFDhwZ83aNHjwbskSBJ0pBp3rqK5Y/EyRwf6pKoe1kSj9zLsh9sIr4/Q3ZYEUUjiygaGYKWDKmn17PyG8tZn8yeuSIVtpeh43/t5all+TfWkjiDxem7JLXfWE1d05ksbDP1q5ZTuzPDsTO4VUmDYShiyNDwWUFnzJ5alq2uo+nIUBdEkvRWVTDUBZAk6d2q9XjrUBfhzJg4j3vuGepC9EHycdbvbIER5VTffD0V53R4bDreSvpXa1j90yYaH3mc2JJqys7A6xnhjy1g0eXdvMHYmqZu1Urq0wke35omemVk8AvTL8doPeONYq2YQdA7V5iqW++hqo/fjn76Ht5eYXooYsjg6+48vGueFTT0rGuSpB7YI0GSJKkbyecayQLRq+d3TiIADCsgMnUeV5YB2b3sfWkoSthBQYQZ10yjCGjes5fMEBdHkiRJkvTOYo8ESZJOaCX9xCpWPpmmYMwMFt5cRbgPKffWV+Ns+nEdjanm3BuTBSHCY2JU/d0sYucUkBubeQV1r+SWTzx0O7cD0evvYd7Etr8xg5urs/z0/2kgdbSA0JhK5n1uFmWF5MZ5/2ktdTtTNB8FhhVQUlrBjBPr77xPzTs3Ubs1TvqVLK10V562cvzodtbuijLv/76S1sdq2bQjRUsrFIyIcPHV86j+UAnZ/Q2s/z9bSLzcCsMKCE+cRc3fVxI53RPF7rXc/lCC8BWL2t6mP7mPi74wnqb/vY66PWmybdsaP/0aqqeWEurpuBaWUDp5BjVXxSg5ZftZUtvW85Ote0kfaYWCIkqnzKLmgvzPY0FBCMhy7Fgr3T8yhahYcA8Vp1vJaw2s/MYm0qNmsOjWqlPG4W7duYaljySJXLWEhVOL8i9cd0IhQkDLG4dpgZPbammi4bFNPJVM03I091FBUYTxH5vFnEvLKOpSx7PpRuoe23riOOfOSffLdt6Z9l4RBURmLmTh9ICxn9vqAwCv1LHi9jpoOz4nHG+h6cl1rP9FMlfH28/11TFKupYhn/17pZ4V36prS7AkWHv77UCUeffMIxqwOwN5PfSu7nYjm6Lh0Z9Q336djCyl4soaxna3bNvxaF+WYQUURcbz0U/OYVpZz3Ust99hZty6iKpRPfyt7bhyxSIWTmii9tE69r6UpZUCQmPGU3VVNdPO73olQ/Oeeh5/sqFtWSgoLqXiihpmTS7pfKW1pGncso6659vObVCs61COm8qSnc5JybgqamqqKH1vM/GO53FkKZXXXM+sCSePSadz/uhaNsTbjndRhIs/OY85ncqXR6zOt/xt10T0+nu4snUDtY83knqtFQpCRGJzmHdtjJI/pmh4dB1bdmdy1+W5UWb9fQ2VJypb+32lS73Osz6cet77Eqe7xt228k9r5of31ZGZNI97Ph10xbU53kLTrzawqX0ddHM9B8WQfxhObd7xNrgILU0NbPhZ/cn6mW8MpIn1d66mkQoWfK2aspNbpnHNUtYnoWjqzSy5qrTDxrazatkGUm3HpvN5OM2zQoeda301zoaHN/BsHtdeV7263s/EvbtrrCsup+rva4g2fZcVT3BqWbrWd07/t9y5fYq96ZZcWXoZH3v3/AXNz22gdnMjqcPt94iZzL2s5830KN/7eqfYsp61jz2bu64Ki4hcNIt515w8B7nznft35okV3P4EHZ7b6GM8TlD7v+tJHs7Fg3DZNObMrSKfQw2cON71u9Jk2uPBiDCRSVVd6s9AxKvePydK0ruRiQRJkoCBSiLwcj2rvl1HeliIyLgY4RHQ2tzE3v3bqf3WAZq/uJCqUSHOi8YoTyZJprOUnB+jtATGjuywnqM7qH2wmWNjosSKXic17DzGFgLZBGv/ZS2JI7mGsGi0hIIjaRL7tlP7rQR7P72ImontP5WyJH60nLW7slAYpnxyOSFaaW7aS2r/dmq/dZDsbTdT2XG7ZKi/fznpTBGl5THKWtMk9qVpfPj7cDBC4qm9FJw/ntjkY6QTSTK7NrCyNcTdN8R6/1BxPE3dqjoSvy+htDxGSdu2Ej9dReaPizoN4ZPdvZblDyXIUkDR+VHKSgrIHkyQfLqW5bv3Mm9RDdETvxC77neE0JE0iV/XsvzX+RevbFKU0K8bSf5kJeuPz2XG5FKKeruTI2NUnL+JDft30JiuYlanEYdaefa5JFBO5SX9TCIArf9xINdQfm7kZAPay/Ws/HYd6eO54xYrKYAj7cd5NU2ZBXzt2pPNXaceZ2jel8gte2Aeiz8dPaWRKLfxPJMIACPLiE1+ndTOFM2hCOUTwoRGntdhvS1s//691B2B8LgYsRFZ0s8nc3NAHD7G1+ZXnFw23/1733lEJ5ezd0+SdLaE0smllDCWkh6Pav+vh97V3W50vObPLSd2XojswQTbH17O9q4xKptg7f9YSyJbQElplPITxyPBptVNHLxhCTUTBv7xvzVdx6onE2RGljJ+cgnHDiZIvpRg0/cyHOvSQJl5ciUrnkjnGtXKY0Tazu/2R5Zz4PAiFrZf9y/Xs/I7daRbc4mGaLQE2mPpN+Mkrl/MvIldmoV217L8iTTHzi0nNnl4LtYl61hVm2VaSwMNvw9TflGM4c1N7N2fouHfvgsLF3e5LrPEH/4Oid3HCI+LUV7QTFMyReMjy2lKLWDRNWWdY11QrO5D+TNPrmR5OkPR+eOJleXqVHpHLd/nIJE9DewtKGV8LJY7vi8n2HD/Q4TumE+sMODEDER9yDtOd4i7BUWUTizLLbuzluV7Qt3HjVMLTOLhFazdlc0ds/ISCsiSTiRz13N6PkuuK6cgKIaMjPQi3nY/t8Kp9TN3z0z8dDV74z09G5RR/kFo3LWXvSkoO5EvOEAqlftXy0sHaaGU9ojfmtxLCiifML6b9eXxrPC7Ddz7rRayRblrj983kUgl2PS9NK/fvJhZpd2str8G697dMdaNKif21yGy/5Gg7nvLSUQKIM9aFOTEuS0oonRCjJL3kivLS7nrIXPj16ged5oV9Or5q8v2JpZRQjNNezaxane/dqPX93WAbHwt39mVyMXG8rbYuKOW5S8eYMEX5lBWCCVlMWItKeL7mwlFyikfHaIkEjq5zV7Gs9Z0HaufTJApKiXafl9I1rH6fzQx5x8XUNklcXXa431uObHyEPwxF49TT9ey/FCWJf9YSaenp77Eq348J0rSu5GJBEmSgMyTuSRCqGwON91Y2bckApD8RR3p4yVM+8fOP+CzO9aw7LE0exMZqqaHKZ9ZQ3HBCpLpLJFpNdRM7LKi15qh65uLZGmsXUviSIjSq27i5qkdGmsPN7Lm/vXE160nOm4e0UIgXc/ju7IQmcGiWzo3fqR+upxV21I07mymcnrH5tQM6WwFC5ZUU9b2mzD769Xc+WgTjU9liV6/5OSPxblJ1t+1hsY9CRLHY8R6e8xeTZCIzGDRHR3K9nIdK+6rJ7OtgabL297ozDZS+6ME2VAps/7xZqade3IVzTvW8J11cdY/GmX8p6MUAK2717O+u/1u//Gdb/nGVXPT1c25eRAeXUXjo7k3/srGlfHBiy9mygURQj0+SRVRcUk5G/Yn2R1PMyvSoWWrpZHGJDDhYi4OagjMR2uWdLKOdY8mASifEmv7Yd1KfHMd6eMhol1/5GcbWXPXepI7GkleW0Y5wNF47jgPi1B1y83MaH/T+XiG+vtXULdrPY8no1SXd9n+8Qz1q1ZSnw5RdvVNLLj0NEkEgDGV1FxXxNqda2l+f5RZ13V9czhLy/EoNV+eR6y9hWB2nLXLa0kkG4m3VFBZ1Mv9KypnxnXFFHwrSTob4aPX1QT2ROisn9dDL+vuqVpJPLqexBGIXNGhkZ0OjVQdND9dT+IIlM9dwvwpHY5HahPLH9xB0669tE4I2lbfNe9OELliEXd3LN8TK1jxZIaGhiaq2hu10pv44RNpGBGl5r91PL9tDUZP1NIwZSHTRmaoX1tHujVE+dx/Yv6UkzGqNV3HqvvrSfxoDdu7JEJb0mlKr1rMzVPblj+eYsO9q9iebKChS6xp2baSZT9Ns3t3hlmRjjWwicTvyqn+0nwqits+am/Qeno9Wy7pknjoNlb3rfyZ9JtU3LiE6nFt5252I6vvXE/Tjgayk+axpEMiL7nuTtbsSJLYA7EPBZyXgagP+cbp5ONtcbeKhTfPONkr53Aja1auJ3m6bZzY1nbqd2WhvJolHROGc1Ns+uaD7Gh6lr2t5URPE0P6FW9TbfWzuIL5C6sp75CcTv10Nau21bF2a7T7eWraRGNR2JUguS/DrNK25VJ72ZslN6jw/iaajle23S9beXZXLrkRjXZ3FoqCnxXaeilwpIWiyxdy2xWRE+ex/drbsaOJWaVl3ay3nwbl3t0h1l2+kJtP7M/Jlzz6lUg4GmfTk7nYM++/z+uUvM3uWMOd65I0PpukelzXG9yJpXr3/PVKPWuf6GZ7HRrH+6aX9/U2TbuaKJ+7uEMsam9I3876n1ew+MoIkY/UUFO0lvj+ZoomzqLmRD3vWzxr3p0g0hYb20uZu281seHxOBU9vICS3vp4t/c+jqfY9M1VNOxvpPHVSqrO6fClPOvmgD0nStK7kHMkSJLe9dob5PqbRAA4dgwgy+Hft3T6PDRlPnd/fQk3n+5N7U6KmHhRl1cJW+K5hpAxVVw/tct6iiuYdWkYsgkan891/27en+ZYYQHRy099g7L0glwDS3eTOJZOm3Gi0RQgdEFZrpHmnEpmdPzROqycsg8AZGh+Nc/d6iRExSe7lO3cGLFRQDZ74n3RlmcbSR6HyOXXd2qIACiZMotpoyC7q5Fn27r3740nyFLEtGu6rruKuVN7fge9o/ClC1hyxyLmXRGjdFQIWtIkdzaw6QcruXPpUpatqSfV/YutJxREL6Z8GDQ/9yypDp+3PNdIihAVH8m/N0fmiRXcfvvtnf9beicrH9pOuhWKJs+j5kSDYRMH0iEKRk3rfN4AQmMZew5wvPXE/MMtO35F8jiUTJ17MokAMCxM1cwKQoUFvJzuMvtCe5Ih3yRCnso/WXOykRkgFCP2QYA3yb7Z/mHv9q+v+nM99LbunuL4XuK7szByGtd0abwMXz6XacWdF2+/ng+/ephOV3bpLBbf/TWWXDfwSQQAQhXM6lq+WIwwkM2evECant5BM1A+q+v5jTJneoSCES0cTLVCqpHtrwBjqpg7pfM1WxCZkbuOj6fYvqNLfQxVMLPjNT6s9MRb4dGPdY4HRePGUwI0Z06dUSQyfe7JJEJb+WpmlQPN7Hi6qcvS3cTqvpb//GnMGNexso2lbBRACZUf79wbqHxcroE48/vgGVEGpj7kE6dbiT/d2BZ3Z3Qe2qu4grmX5zn5+3Fy5Ww+zOGOBR5Wyqzb7uZrX66h2/b2DvoTb5t27KCZEBXXdEwiAIQovbKK6DDI/Lqx03pPMa6cciCzr4n2p4CWlw7QQikzLi8Hmmhqr0LH95LcB5RH+55MHjmNazokEaD7a29gDcK9uz3WhSqYeXnH/SkgcsWpsa7XFzWFDQAAIABJREFUXjxAOlRA+NIZp/QAC40dm4vpx05zt+jl81fm+TgZcveyTts7EUv6qo/3vVNiUYjo383JXSuN2+ka1TrpTzy+svNwQifuW3t+RWPnx+Qumjnwn8coKIhS1fW5eVgpY8cAtMIpE67nVzcH8jlRkt5t7JEgSXpXa3l6NStbcr9mRk2M9iuJADB+cozQrjiJR5axdFOYyPnlTPpIvm+vdzSW88Z0+SjVlGvAOLKLTY8cPPUrzbkfsKnUAZhSRsmlC1hyKUAr2ZYshw81kXn5IHv3NZFsCn7fqqQ4YJidSOSUMacL+nW8RhEZ3fNSB17MNdu8mdhEbTfFzu12itQBqBiXIZ0GGMvYboZ0iIwrI/RUc++KWRgmenkN0cuB461kDx1gR/wpGp9OkknWsepf0qe84dj5+zEunbyB5I4dNO6bRek4gAyNz6QhVEGsN20KhUUUdd1OYTFjy8YTnVJBbEzHc1fOnC9/jTkAR7O0tLxC+qWXOfhikr3JvaQOd15N+qXccW5PMnVSXs3Xvt71wxa2f38lLS3AsFFEJw5MEgFCnDUy6GLJkPk9MAp6u3991Z/roXd1t5ttvJImfRwoHcup1TnC+HEhGjoMwxC+KEbkyTrSW1ey9JdFRC6IEp18MbEJpZT0p9dLT8499VicqpkDL2WBCGPHnnp+i6Yu5O62cetbd2Ry83xMKKe7ox+JTqToqQYyhzLQccvFxXTf3hgm0rVaDysI+CEUJlp+6lYLxo2nlCSplw7QTFmHYbFOjdWtmT6Wv6Sk2+UhQqRLQ2w+v+IGpj7kE6cP0LQfguJuLmmTpsfIOypKLFJHXbqelV99iqJIGdEJF3Px5CilxXneQPscbzMceDELhDj4dC21z3X9e5bm9wKvHeBgC5QGjUZXeDHR8vUkk3vZe7SSisJW9iZTcE4V0VgBiSeSNO3PwLgw7ImTOA6l5eP7/qO8uCSgzgOvZmiGPIZw661BuHef1RbrPlBG+SnPFREmTSyiYVs/ilw+hyVfmQNA65EWXn81TerQQQ4k95Lcl+q5bvby+Sudzl3b3cW6E7GkbzvSp/tet7GosIzxpZDcf5ADr0LZOd19sx/x7IPl3Z7L3H0rxYGXoHJC0H6WUHnjEioBWrO0HDlM5ncZ0gf38tvfJWl6Keh7+dTNQXhOlKR3ERMJkqR3tWxLC6GyKJF0gtRPH2L7xK5zBvROwYQaFi0Is25dPcnDGVK7M6R2N7CJAorKq7i+porSPHvnBzbSH04RPxz8E/TkW4hZUk/W8tDWJC0d3+4sCBEpLiH7Snc/lMKE/zK/8vXfWRT1YmqA5v1xmvcH/TVL9ihAhszpekecXRzQUJenYQWEImVMi5Qx7RMtxB9eQe2uBI9vTRO9Mvit2/IPRQntaCTxXNvQCelGdrwCJR+tpDcDT4Q/tuC0w2qc4nCc9T9cR+PLnXueFBSHKQllaO7wwmruZczenP8sLS0hyiZGSO9OseHh7US7jlfcJ0UUnx3819aObyD2Yv/6ZmCuh/zqbjd+nzltA1fRyC5He1QVN99a0jbxagvp5HbSye3UAQXnVjD3s9XE+vtmb7cFKcrjvLeSe022hHBAg1W75td6yAK1Tyze9fNzwgPQaBom3N3Y3UVFnAVwDLr24+oaq/ta/vA5A3xyBqQ+5BOns2SzQHHA8Q9M2nQVpurmxZT8JDfRdctLSba/lGT7E0BhmIrqz1L9oZ7PcP/ibZb0nvhphjZp6xUVeEwKGF9eCskkyX1QMbGJpn0QmlJG+JzhlI2so6GpiZYrwmSSTUApF0/qR9Q83bXXTV0dGINw726PdcO6rynvC/VvfgSA5ufW88P1jWQ6xtthBZSMKiH0cnPArBld5PX8laE5uKPQyVjSV32474VHd/fcUNR2Hrt7s/+kPsezbrfZft/Kdr6Xdyebor72IeqTLZ3qccGICCXFWTLdFiufujnIz4mS9A5nIkGS9K4WKq/mn26oILQzN0buQDSGFpVVMf+2KjjaTKppN7t27CKeTNGSrGPVv4VOnRyut+s/ZTzu7mW2rmbVE2k4J8qMj1UyfkKY4vcWESoEdq/l9ofeTm9cFTHt5iV5TBwZzjVSBv1IbOva3mOTxKvbWfXtDaQuqObu+RXdPzANKyL28UrqdtXTfLgZOM3wHeMqmVLcSMPuBMlryymK76aZMDMq8hzyoy+OJqm9v5b4kRCRj8xk5uSJRIpDhIpCFJCh/lsrqOvQ4DB8OHR+478nIcqv/SfmXxKicc2drE9u4KFfRbn50jP0E7yX+zd08q273fjLXMNs0JX6ZvbU2lxwTozqW2JUt2ZJv5hg7+4E8Z1JMi83Uns/FC2ppmxIBjctgOEAzblGnNMkE0pGFgOnaYnrMETFwAsoX9vb3YzoeeLgoS1/Z2emPoQIhYDDuWPUr6hWUEJs7kJic1vJpg+Q2JMg8XwjyZczND78HfgvPUyIC/2Mt+VUf30+Ff3owVM0cRKRx1K5N/KLfkvTcSgrz6UwxpZCw+4mDhwPk9yVhTGTiL6jWy3zjH+vRAiTINPNcIsAHG+lP00XrXtq+c7DcbIjIlTOmMnFEyIU/5cQRaECeKWeFd+qy+uazPf5qyTMyXksujqa7fuQe3287zVnmmFi1yRcW6zjfYTeF7zJvsazzKuHoZu+aodfzQCh3LNooAz1q1dRl4aSiTOY/pHxjB9dTGhEiIJhkPjR7aztc6/DAXpOlKR3KedIkCS9qxWVjqVkGISmzGXO+cD+DTz0q9MO3HoaTWy4dxlL792U67JeWELphGnMuv5mlnx9PhUhYH8TB/pa2HBu+JCW3bu6fVsy/fhybv/qMtY83QxkSOxMAxFmfW4eVZeUESkqOvHDLdcF/e0h91ZbC7sT3e41m+69naXL1rD9MJwcwqSJZDeze7akmk59i7k7xUWc1QokG6h/+TTL/aEl9wM61wp/GhEunlQC2QSJfSmefa4ZxlRQkVeDfR/tayR+BEJTalh4zTTKS0soKgrlmmKOZ0h3+REdGZNrHEl3nQcB4LUGVv7zUpY91NihwaCIsReUACEqrp1D6TByvXpeG7Q96qyX+zcUeld3uzEqQmQY8NskyVPe3mzhwP6OtbmZ7WuWcefSNTQeJdfzaFwFVdfMZ9HXlzBrDHDkAAfyOi5tb5h3kuJA38biaFPC2DEhIE36UDd/Tq7nzqV3smJLioJwmCIgsyfZ7fWaTuzODbUR8MZr/6Q5cODUxszWAwdIA0VjzusxETy05W83kPWhJ2MpLQU40G0daUkmTtcMebLET69h2V1LWbMj12gcipRRcfkc5n/xbpZcFQGyHEjls6a+xNsw4dEASRKJbhqzj8ZZ889LufPeDacfTx5gZDnRUdCS/C2JfUlaODlXx/jycjjeRHJrbgLmoOFizqzBuN57Gf/OCeeGlvxdU7exLpkMSqceO7VH19EDHOjSiL93Z5wsISquW8icqeWUnlOUSyIAZNI9189ePX9BJBIGMiSS3USAF1N9HNaIPt/30qnUqb1TjqY4cAgYOZbzTlMJ+xzPXvxtN8cqzW9fBCildGzwNnklQTwNjJnFTddXUTEuktvPYQAZMt3dQ/I2QM+JkvQuZSJBkiQAiqisnkGkX42hYxk7uoXWwzt4ameXnyFHXuf1PwLFxSeGfiho68J/LJvn4AOjKqg8HzjcwLon0p1/FL5cz7ptzdBazPgJHd86a6G5SyNla7qO2iffRomEKZWUDoPmbeuoS3c+Vpkn19FwGFrPGU+0bYiO6CUVhMjSuGVT54mQDzeybmvwgBWdDIvy0UtLgAz1D66mfl9zl274rbTsq2f1I425xomLe57oIHJZJRGyJLb+lORrUH7pQAwD1LPs4dc7vy14vIX4w+tJdGmsKbq4gvJhkHmytkvyJEvip/Wkj7dSXDa++7f0RlYy94oIHM8NcdTzj/DhuQaBo1ne7HHZ08t3/06+Ed9Nw9Mg6W3dPcWwKJVTQpBtZMvjqU772bxjHfWdxokuYey5w8m2JmnY2iU+tB6m+QgwrJiSHoZuO9H493znpq7mXz/Jjn4micqmTKEESDy6lkTHnTmeoX5LI9lWGPuBUiitoHIU8FI963Z0bkBsTdflYt2wUiqnDE5DfHJTbefytcSp3ZQEwlR+OI+uJUNc/pyBqQ/5KeDiS6KEaKHhJ3V0quotcTbkGXdLSsMMP9JK8hf1nddBK4ebc5GiuLj9/nb6GNKXeJu7d+TOf7xTEMuS+PEGksdbYVw0j+GRwrn78Cs7eHxHBkaNp6xt4wVjxxImy7Nbt9NCCeUTeq4DvX5W6IXBvN57Ff/a77nZRjY8muwU61qe29Al1kGnxM/zHZfOktrcQDftw0CW5te6ZExa4qx9NNHzzvTy+at939Nb19HY8Rksm2LTlsZ+90jK/77XZs8GandnOy//4w0kj0P4koqTc/C01bVstsNV1dd4driBdZ2eNVtJP5E776FJFflNMN7SzOEuz17pJ2qpC+rtkacBeU6UpHcphzaSJKndqCpqrkiwYkuX8d53r+X2hxIwagaLbq06zaSiBcSunMFTybrcZMu/KCd6XgiOZEg2pckeDxG9qurEsA8lo8NAmuTPVrH2d2HKLq2hsusEy50UUfmpGvaurCX55Eru2FHK+LISCo6kSezL0Hq8gMjMuW1zPISJTo5QtyXN9geX0jQuSmQEZA8mSL7cSuicEkKvNp86Od5b0chKrp+7lxWPJKlfeQeN54+nrKTgxL5QEGHG/9WhkWjcHOZ9pInVTzewalmc0vIySlrbjlEoRCjPn/ClV/4D1Ye/y/rdTdT9YDl1wwooapvpuPVIC7k2nQIiM2/qeagNgJExKs7fxIb9KbLDyqmKDvJj2LgKYiMSxJvWs+wbjbm68sdmmpIpWo6XUFKcpflwhswr5IYyClVQ8+kkyx9KUPftpcTHRYmMaKW5aS+p11opGDODuR8JbooLT69hxq4V1O3PZ4ijUblGoHQDtT9ooXTMxcya2ZtZp/uwf5Rw3mggneTxB9fSFC7jo9dV9m8Ylp70tu52o+yqeVQ2rWb7tlUs25W75o+1X8cjQnDk5LKRj88h9u9riG9dyR07S08ck9S+FM1HIXLFLGI9NN6Ep1RS+uQGUttWsXRfOdHzhtP84l5Sr4UoO7+kbVLdPiqdxWevaGLFEwnWLluWuzbfmyWdSJI5CkWTq7lyHECYqnkzSHynjuS65Sx9spTxF5RAcxN797fQSoiyq+f2az6bYCFCdChfa8f4Oo+qvHoRDWX5TxqI+pCvgonVVE9qYu2uelZ+PU7puNITx254KAT5xN3ITOZM3sGanfWsvKOxrX605urf4VaIzGBWrD1udh9DTlxLfYm34+Yw/6MHWfVUgtpvLKW+SwykKEb1J/Ob1aZ9Atrmw1A09YMn77KjxjI2BJlsK4ycyKQ8AlC3zwrvzasYPRrU672X8a/0ys8y43crqNuxhmX7Osa64YRG0CnWQVtj8K5GkuuWsWzHeMpKjpFJNpH+41jKxmQ6Tcg7fnKM0K44TY8uY9nOXDla26/Hc0ooOdJM86EMwU9EvXn+yu373KsTfPcnSdZ/cykN46JECtruT+/NPYf0KZnQ6/teTmgEJB5axrLzc8epPeYWjJnBvOkd9jgcJgKkf1XL6v+vlLGTZjFjQh/j2YgQh59YwdLn2+pVx+vo2ujpG6JOTLy+nVV3NFEejRCi/V4RouScEM2vZkhnyHMoxq7HcWCeEyXp3cgeCZIkdRD+WE2uoaivQxyNqmLhl2qoPD/M8FeTxHfGie/LEBpTSfUti5g3scP73OUzqJ5UQkE2TWJnnGdTeWxvZIz5X15MzUfaGml2xoknmxkeiTJrwW0s7PCDMDx9ATdfFSUSgkwyTnxngtTw8cy4fjFLbr0yNy72SwdOM6nkW0fR5Pks+VINleeX0PpSgvjOOMlXhxOZNIsFty2k6tyOSxdQds0iFl9XSWlRltTuOPGmFsITZ3Hz9dPy7wUwrISK65ew5JZqKs8PUxSCltdaaHmtheywIiLl06j50h2djnkPe0HFJbnG8tDkSwesAS9QYTk1t+SOGS2pXF3Z9wbFU6pZ+OXFfHZKbuiFA/9x8t3K0MR5LF5YTUUkRPO+XJ1Jt4aJXrWA226uyg09EShM1d/nEm099+opofLqaZSOKMht5+n8hj7p7/6VX1FNtLiA7EsJ4juf5cAZGL+gd3W3G4VlzPli7po/K5vbz6Y3wkSvupn5XZM1heXU/PebmTUpQqht2fjuNNlwlBnXL+bmfCbqHlnJ525tO66vJInv3MsrI8Yz55bbmDOu/8mv8OULWXzDNMqLW0nvjhPfmaR5RCmV1y3mtuuiJ3u8nFvFwtsW5PblSG5fEi+1UnJ+JTVfWsKCSwcrAVrEtBsXUxMLkd4THF97NGTl72Ag6kPeQkQ/vTh3zxn+elvczRKZOp9FV+ca34tG9jTFbAHl17WtI9QWu3cmSB8NE71iHos7xaCeYkhf4m0BpVcuZMmCWUQ7xMBU9ixKP1LD4ttqiOY7cHrpeMa3LTv2go69WMoo/2BbCSdNIq+pU/ryrJCvQb7eexX/hoWpuqVLrHszwrQbFjHnA92sfFw1ixbMIjpmONn9CeLxJt4cVcn82xZQ2aWXV8GEGv7pU5WUFkPL/lw59r5WTMW1C1ly62eZMgp49QDp0/VW68XzF0D4Iwty5YsMpzkZJ74nzfAxldTcMiePXi0B+nDfAyi6dAGLr7uYUDo3R0rz8Ej39/VzKrnmo6WEhjXTtDPO9j1tV1Vf4tkH5rBowQzK3mzqw3UUpmpBW+w6niG5M078+RQF5TOY96UlLL4ydwTTB/r6BDtAz4mS9C70F3/+85//PNSFkCTpLW/3Wm5/MsLihVV0na5OylfrzjUsfSRFxY15TBgq6YxK/Oh21u4KM+PWRXn2PFBenlvL7Q8niMxczMLpZ+4Oarx95/Da7KO2HrXhKxaxaEATh6fRNnl1ZtI87vl09MxsU5IEwOuvvw5APB4f8HXHYjHAHgmSJPXseAvxnU2ESj9oEkF915pi0xNJKJ5CpY1akt5Bmh69k6V3rWDTvi5/aE1T94sEUEJZ+Rm8gxpvJUmSBpxzJEiS1JNXG3nqtSnMn5vXIARSJ5mnVrH6l4fb5lUIEbth5uCOyy9JZ1jZlCmctaOBhjVL2V06ntKSAmgfu70VSj5SzcwzEPiMt5IkSYPHRIIkST0ZVcXCW4a6EHq7Khl5FtnXUrQWFFF+9QJqJvj4JekdpnQWi249j00/rif+UoL4foACQmOizJh+JR+dWHJGfngabyVJkgaPcyRIkiRJkiRJkvQ25RwJkiRJkiRJkiRpSJlIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJOn/b+/+g7uuDzyPvyKQRIGYuELxpPG6Kgx7aEGr2IVuS25nY71Ja8F6ev7Arlvbnq67Xp3BrbvsHC1tmbPXrqvTFc/xx9ax66qtzVzb9FpobTilWGFbrk790V2oVMQq+MUgSQi5PwIomHcSEBslj8cMM/L9/Hi/v98Z//k8eX/eFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUjR7uCQAAAAAAQ3N2y/nDPQXgIH239d7hnsJBsyIBAAAAAAAoEhIAAAAAAIAirzYCAAAAgLeht/NrUmCkOFxeR2ZFAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFAkJAAAAAAAAEVCAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFAkJAAAAAAAAEWjh3sCAAAAAACH3NrbcvbftA1wwpg0HDc1Z7bMy2XnTE/DqNceW5ebWxandSjjTL08d9zQnElJsrkt11x+Wx5Pkuo5+Zu7r87s2vKlj9/+sVzzQEeSKbnyts+lZWI/J21el9Zvtea7D63L01u6kyTVDe/Ku/+oKfM/1JwZ+1zTnZX/87J8dkV3zvhvt+ezc8cOOPWuh2/MeZ9vT/WHP5f7/mzKEH6zV0274qZ8ud8JczgSEgAAAACAw9fkmWmZ+foH3l3PrcvKtevStmxdVrRfnmVLd8eAfYxJw3ENqRno/hPG9H+8a1Xa13Rn9nvH9H9dzxNp/37HADfuyNMPfCnX3L4uXRmTcROnZm7L8RmX7mz62ar8y4O3ZfWDd+XEC/42Sy+aknG75zv77LMzbkVrVi9flS1zm9JQvH93Vre3pytj0/K+Kfseqq3PpIbqgb51jjly4OMcXoQEAAAAAODwdWpLrrxier+Hrqmsyc1/8YW0/uKu3PlwUxa+7qF/UxYuuzwzDnTMurEZV+nIivbHcs17Z6XfR+6/XJW2ytiMq+vIy5XXH97U+oVcc/sTycSmLPzCJzN3nxbyyWTzmty85Ia0fv2v8/GORbnziul940ydlea61ty/tj0/2dKU5lJJ2PLjtD6U5IR5aZ66/9e+Ond8qv/fjJHJHgkAAAAAwMhUNzPz501J0p2VP//lobvvcU1pPj3JQ6uyekf/pzz+f5fn5bqmNJ/Zz8H1D2TRsifSdWxzFt+4f0TYbeLMXPn5v0rLscmW1htz557pj5qS5vnHJ1mX77ZvLk5xU/vyrE0y49z3pfGAvhwjkZAAAAAAAIxYk/7d5CRJV8+hvOvEzHn/zCTtaX+0+/WHe9Zl+Xc6Mu6PZ+WMfpYrrP32/dmQZMZF8zNjoG0Oxk7PgsvnpDpb0/q/V6Vr98eNc1syI8njbauyod8LN2Zl2xNJ5qRlTv0BfTNGJiEBAAAAABihurP2J6uSJNMmH9qNgxve25S5SVY8/NjeB/x7/XxV2rrGpvkPp/Rz5RNZ3d6dZGaazxz8If+498zK7CRdK9flF3tiSMNpmTsjyfrlWf1MPxetX5XW9Un13Fk5Y4DNoGEPeyQAAAAAACPPjo1Ze/9tWfTtjuTY5ixo6i8ktOW6lrYBb9Py2XtzZX+bKNSeljl/lKx4aFVW//mszH7NA/u1Dy9P13Hz0zw1eXH5ftdVNmdDJUkmpqFuCN+j9l056feTFb/61/z6hWTGxCSpz9xz5uTmte1pbd+Y+Rccv88lj/+f1mzK2Mw/u7B/w7cX5+xvDzRoc77YehB7R/C2JSQAAAAAAIevQR6KV5/cks9+5pLCK4TGpOG4htQMcPtx/T6J77v2jPfOSR5qT/ujn8rsObs3ct6xKm3f786kj85KY5IX979sR0deTpKpkzNpgHH3+Q777xGdpPrMs9NS1577W5fn8Y9ekmmjdh/oeSLtKzqSEy5J8x8Ublhbn0kNxS+WZOyAvwmHHyEBAAAAADh8TZ6Zlpl7Vht0Z9OaH2f1M90Z9/vNuea6SzP7uH6ewu/VlIXLDv5f3le/Z1bmpj0rHn4s18zp+9f/XWtWZWXX8Vkw5/j+L9rzMvpnN2dLMqSY0NXPNgwZNSVz5o7N/Q8uT/svL8m03dGg6yffTWslaZx/WnmT5aarc8enpg9hZEYKeyQAAAAAAIevU1ty5RWX7/7zyXz2q3dn2Z9NSdev2rL0r+/K2o43ceza0zJn7pjkoVVZvSNJurP64VXpOqEpZ0wuXHPsu/IHdUkqz2RTZQhj7PjXPPWrJJmcSb+376FpZ89LYzrS+qN1uz/ZPX6mZ/7cQsiAfggJAAAAAMCI0vjhv8ric+rTtbktixa3ZVPP4NccnDE5472zUp32tD/anex4LO0rutPYNMBqgPStJEjWpO0nWwcdoWvNqqxMUj13Zt49ar+Dk9+X+TOSru8vz8odSbb8OK0rulM9tzlzG97I92KkERIAAAAAgBFmbGZccW3mH5t0/eK2LPrnjW/aSNUzZ2V2dbLi4cey5dFVWZEpaSm91mi3aR+6INOSrL37/oFXTHSsy63L2tOV+rT8p/42Tq7Pme+fnnStSvua7mz5aXvWZmxaSpssQ4GQAAAAAACMPKOm5OPXtaQhyYa7b8g969+kcWpPy5zZY5KH2rK0rT2Z+r6cMXGQayY2Z+EVU1L927YsuvofsmJzP+dsXpObP/OFtP42aTjn6lw4tf9bNcxpztzq7qx8eHmW/2hdUteUOYVzocRmywAAAADAyDT1kiya9+Nc88DG3Pk/Hsjsv5uXxn1eD7Q8S69Yk5oBb/KuXPj5T6f52NLx3a83WtGetWuTGX8xa0gbKE9q+VxuOvJLWfh3y7P08h/n5hOmZ/apE1Od7mz62ar8y/qOdGVMTrzgc1l60ZSMK92DkrcdAAAUzklEQVSodlY+9MGxWfGdu3JnV9L4saZM2/8VSPtbfmMuWzPImoUT5+XLC5viDUkjg5AAAAAAAIxY0y69NvMf+uvcv/7r+dw/z8qyC1772qHubHm2v+UAr1Wfrl0Dn1F9ZlOaq9vT2jU9c0+vH/LcGv/407nn9CfSdv/9+dZD69LW2t13v4Z35d0fbsr8DzVnxmCrG5JM+8OmjHuwNS8PdZPlHVuz6dlBzqnrTufgd+IwUdXb29s73JMAAAAAAAZ3dsv5e//7u633DuNMgKH4Xfw/W6lUkiRr16495PeeMWNGEnskAAAAAAAAA/BqIwAAAAAAeJvbs3rgzWBFAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFAkJAAAAAAAAEVCAgAAAAAAUCQkAAAAAAAARUICAAAAAABQJCQAAAAAAABFQgIAAAAAAFA0ergnAAAAAAAcuLNbzh/uKQAjhBUJAAAAAABAkZAAAAAAAAAUVfX29vYO9yQAAAAAAIADV6lU3vQxrEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBo9HBPAACG04svbh3uKQAAAAAjwDHH1A/3FA6aFQkAAAAAAECRkAAAAAAAABRV9fb29g73JAAAAAAAgANXqVTe9DGsSAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKhAQAAAAAAKBISAAAAAAAAIqEBAAAAAAAoEhIAAAAAAAAioQEAAAAAACgSEgAAAAAAACKRg/3BAAAAAB4+/v1SccP9xQA3tLe+dTG4Z7CQbMiAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoGj3cEwAAAAAAhsP0jFuyKOPef0pGT6hL1ai+T3u3bEj3j27JlmvvSNd+V4z/2uOpP6suux5ZnI0X31K88zFtGzP2xKT7vuOz6brdH37xh3nneScPaWal+49uWZj6i85NzSmNOaJm94edlfSsfzTbv3p9trZuOMD5Nmb819pSf1Zdkkp2fOWjef6mdYOP2dOZXc+uS+c3b8/Wr3wjO193309kwmOLUltXyY4l0/L87aVvekMmPXVhxuTJdJz0gby49+9DVFmZraedn21DPR8OkpAAAAAAACNN05K844bLUl2Xvofizz+ZnZUkR70jo49rTPW5SzLxrP+Yly66JNvWH+KxezrT2znwKbu2739CY8Yv+6cc3dSYqiTprGTnE8+lN8kRk07OqClNGf/lttTMvDLPLV4+xIk0ZvwdD74aEZY25/lbN+xzfNzf/1PqP/jqmD1PP5ddPUnVhMaMnnx6jrzq9NSeOy8vLThUv1Nnerd3pne/T6uO6isYvfv/LpXXnwtvBiEBAAAAAEaSOTdk0t9fmDE1ya61t2TLpxdn+2sfgp9ydSYsW5jaSU05+qs3pPuca7PjUI7/bw/kmeZrD+iS8Xe0pX5OXdK5Ia8s/Xh+e9drVw005qgb7sox556c6ktvzoRfD7QC4NVrxt/xYOrnTEx6NmfHDR/eLyIktV+8qy8i9GxO112L88KSfVcejG5ZlIaFl6V2clPq77s3OeNQrAy4Ps+dev1+n726amH7qR/Ii294DDhw9kgAAAAAgBGjMfUL52VMTdL79D154bz9IkKS/PzGPH/9N7KzJ6maMi9HXzUsE33Vef+Y8XP2vHroP+8XEZJkQ7Zfe2leeqSSpC61F9+U2gFv2Jjxyx7M0QNEhDTdmobzTk5VKtlxw4fz3JLXv75oZ+viPH/R0uzYkqRhdsYvu/CNfU94CxMSAAAAAGCkOOHq1E6rSbI5nbcOsNJg+VXpWFPpe5XOcR/5HU7w9caf+56MSpLHH8iW/R/477Uh2/7hB9nZ2ZldNUenuni3vtcVHd00MVWdhYiQZPyfzul7lcuAYyZZf0u23P3T9CYZddaFqRv614K3Fa82AgAAAICR4uJT+jby3fJkXrlv4FMrF0xL5XcxpwF9JLUn9j2e7/7Z9f1savwa7Vfl2f8w0Al9r0Cq/2BjX0T4Sv8R4bVjdj0yyJhJdn5lZbr/9PRUH3Vyaj6WZNDXKsHbj5AAAAAAACNE7aTd/2b+xQ15+Q3c54izFuWdTy06uItPvDDvfGqg1wA9mY6T9uwFMCVHjE2SSnqeOrjh9tizj0JVkjzzg2wrrjQ4JUcc0zfmrt8M5c73ZOfzV6f6hLqMmvrG5ghvVUICAAAAAIwQYxrqD82NejrT2znA8ZqaVI06yGvTmd69/z0hVUcdxPz2UzX1L3PMWXWp6qxk1+i6HHHivNR/8dvZdN3yfs6u2z3359IzpNUFG9I72LIFeJsTEgAAAABghHhl09bUH4I3+e9avTQbL76lePyYto0Ze2Lh4L89kGearx3iSE+mp5KMeYNTrmqoSzqfzPbrLk3H7Lty7HknZ8x5N2fCL6fl+WIsODqjzk3yzcHu3pgqT1k5zNlsGQAAAABGiJ3PPN/3r/2Pacy44Z7MkKxLbyVJ6jLqpDdwm90R4YXWDdlx3aV5+fHOJHWp/a/3ZvwJ+5+8Mj3PJ8nEHDHgngt7XJjRE5Kkkp6nD3BeJ9T2vWoJ3uKEBAAAAAAYKb7yaLp7kjScnCPPG/jU0YvaMvn/PZ7jvrYkR/5OJtefldn+xOYkyZhTlwzyepULM6H9Vzm+/Yc59pP7Htm15p680LpnT4QN2XrV0uyoJGmYnaO/ekNq9zn7G9n+i74xq88abMwkV83OmKOSbH8ynbfu+fA72bUlGTSA/MnEvge0lc3pHmwcGEZCAgAAAACMGIvzyprOJBNTs2DRAA/JL0zDB6enqqYuVZ3r8srvboKvs/2uldmZJNPOScMA8WP09ZelZlJNjpjQmZ7vDHLT9bdky1dXZleSqinzUv/Fpn0Od9z+g77gMm1eGj7eWL7PCZ/IhAWnpypJzyP3pLL3wIZ0Pdv3t4ECyNizTu57QLtxXbYNMmUYTkICAAAAAIwglZseSHdnUjXtE3nHfYty1P6v9jnlshz7gyWpnZBk+0/Tsfie4Zjmq9qvysvtlSQTU/vfH86xl07f74TGHHX9tzLx0umpSrLze0uzZf3gt9156/mptFeS1GTMeV/KhNdGivZrs/UbT6Y3dam99sG84/qPvC4GjG5ZlAl3L0xtQ5ItK7Ntyb6/07ZvPpqeJJl2YSbetjC1+/zO0zN2SVvq3z8xSWe6HrljCD8EDB/bgAAAAADASNJ+bX77+aMz4TPnZPSMT+T3vndZGp7dkJ7tSerekdET6lI1Kn37Clx/VV4awkP5A/Lv52Xyz+YNfM6LK7P1A5fk5d1/3XbZlRn19S9l/Hsac+SitrzzLzene9NLSWoy6oTGHFHTd17PI0vzwp8vH/JUtl12ZWp++I85cvLE1C68N+NXn59tu7/vjusuzYudt6bhoump/thNOe6/fD471z+X3iRVExozuqFv0N5nluelBZfsvW6v+67Ptj95MEc3Tcyo91+dCT+4Or3bO5MkVUfV7D2tp31pXliyIfBWZkUCAAAAAIwwO+/+eJ4956ps+9GT6elIjph8csZMOTljJtUlHZvT9b0b88I5H3jNvgKH0KiaVB01yJ+6mv02IV6erRfMzHOLv5GuZyrprZnYN98pjTlidGd2Pb0yHYub85uLb0zXAU1meX67+J50d6Zvv4SbXvu6pw3Z/rfNee7ixdn+6IbsSl1GT+n7nUbXJbue+WleuemqbPpAPxFh9/XbrpiZzYvvyY6nK+ntzN7vl57O7Hrmp9m+uDm/ueyWvlc3wVtYVW9vb+9wTwIAAACAt7dfn3T8cE8B4C3tnU9tfFPuW6lUBj/pDbIiAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAIAiIQEAAAAAACgSEgAAAAAAgCIhAQAAAAAAKBISAAAAAACAIiEBAAAAAAAoEhIAAAAAAICiqt7e3t7hngQAAAAAAHDgKpXKmz6GFQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAUjR7uCQAAAAAAAIfeggULhnzunXfeWTxmRQIAAAAAAByGBooDB3KekAAAAAAAAIepwSLBUGKDkAAAAAAAAIexUiwY6ooFIQEAAAAAAA5z+0eDoUaEJKnq7e3tPdQTAoC3i7Nbzh/uKQAAAAActHvv/l8HdP6CBQsOKCIkViQAAAAAAMCIcaARIRESAAAAAACAAQgJAAAAAABAkZAAAAAAAAAUCQkAAAAAAECRkAAAAAAAABQJCQAAAAAAQJGQAAAAAAAAFAkJAAAAAABAkZAAAAAAAAAU/X/jT9nHzkWyaAAAAABJRU5ErkJggg=="},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"d69349c807b676eea812c065957532b1","cid":"0-16","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:40:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:17.117Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:40:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js:40:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-16","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout9-cart-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T02:03:17.147Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-16\\report.html"}