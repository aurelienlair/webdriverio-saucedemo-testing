{"info":{"type":"runner","start":"2022-02-18T02:02:45.531Z","_duration":23181,"cid":"0-14","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_1337138940"},"goog:chromeOptions":{"debuggerAddress":"localhost:65426"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"5446242f9c540027e3ef23309ea0b55b"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js"],"sessionId":"5446242f9c540027e3ef23309ea0b55b","isMultiremote":false,"instanceOptions":{"5446242f9c540027e3ef23309ea0b55b":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:03:08.712Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":23181,"start":"2022-02-18T02:02:45.531Z","end":"2022-02-18T02:03:08Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:02:45.540Z","_duration":23061,"tests":[{"type":"test","start":"2022-02-18T02:02:45.541Z","_duration":23016,"uid":"test-00-0","cid":"0-14","title":"TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9918fd86-88a6-4a7d-8044-86ccdb2df73d"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/clear","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/clear","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/value","body":{"text":"performance_glitch_user"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8d849ca8-783a-4d26-9a02-be8a9ca767b4"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/clear","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/clear","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/value","body":{"text":"secret_sauce"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6940b076-f6ad-4910-ac14-3febe5bf69f9"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6940b076-f6ad-4910-ac14-3febe5bf69f9/click","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6940b076-f6ad-4910-ac14-3febe5bf69f9/click","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"af2f2f8e-001b-4fdb-a5f3-9e5bc6d285df"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/af2f2f8e-001b-4fdb-a5f3-9e5bc6d285df/text","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/af2f2f8e-001b-4fdb-a5f3-9e5bc6d285df/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb799f3f-ad39-4bfe-99d8-2efa31a64e15"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb799f3f-ad39-4bfe-99d8-2efa31a64e15/click","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb799f3f-ad39-4bfe-99d8-2efa31a64e15/click","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3fcdfe20-8beb-4cfa-a2de-c89c66641962"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3fcdfe20-8beb-4cfa-a2de-c89c66641962"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3fcdfe20-8beb-4cfa-a2de-c89c66641962/text","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3fcdfe20-8beb-4cfa-a2de-c89c66641962/text","body":{},"result":{"value":"1"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3fcdfe20-8beb-4cfa-a2de-c89c66641962"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4b52e83c-6c0f-43de-b935-1ad0493d3340"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4b52e83c-6c0f-43de-b935-1ad0493d3340/click","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4b52e83c-6c0f-43de-b935-1ad0493d3340/click","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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AAAAAAAAEgcVCQAAAAAAAAAAwFDCVSQAAAAAAACMBUtKbor3EgAAGBVUJAAAAAAAAAAAAEMECQAAAADw/7N397GS3fWd59/n+amqbtXt7ttt2pgQJwZnnaRJFqzITiRQRs0w6mSEkyjsTgLIwRrGiFky2QFlMZPBaALKZKyJ8LJyxgoJOxvEjNEkrSVubWRWiRFrGIYO8eDghDjYNG7f7r71eJ6f9o9f+QK2r7uN23TjfF7SFaW6Veece+peq/l9ft/vV0RERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9uRe6gt4RtsneNfNd/MQR/ng8Zs58p0co53x1c/cx38+cR8nH95mWgB4DLau5NrXHeMtb7iRqycXeKxqm5Mn7uPE/3f/txwL/MkWP/SaY/ziTa/jyBXehR3q8Qc58X8f597PPsxj2ykVQDjm0DU/xk0//0aO/vAWvvNM79zm+K+9gzu/Atfe8mHuOLb1rOc5ffy9vOWuh+EN7+Pet18HwMmP/ALv+dQF/sy7nsdnICIiIiIiIiIiIiLf8y7PIOF5Wn3p47z79k/y1ScX/EdbHJoAbcrO9iN8/uO/w+c//hGu/tlf4wNvfRWTZ1y4Nx7909/mfR95gNPVU45Fxc7j25w8cTcnT/wBh376ndzxjuv3PlZ7ihP/9je58/5tEx7gMblii02gnG5z+kv3ceeX7uN3t67nbe/5pxz7weTi3AwRERER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N3L0FVvPfiBnzA3//MP88Zse5PgfH+fezz7MY49vM10f5+ofuZ7XHzvK0R/ewn+2xf/kGt78Wx/l6F/exx/+p+P8xd9NOb2od6/npa80xzl25DzXIyIiIiIiIiIiIiJyAS7PigQRERERERERERERETmv70ZFwotrRoKIiIiIiIiIiIiIiFxUChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRP7qW+gKd6/bFfuNSXICIiL6B7j3/iUl+CiIiIiIiIiIg8B6pIEBERERERERERERGRPSlIEBERERERERERERGRPV12rY3U8kJERERERERERERE5PKhigQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTe6kvQERE5FLa2Zld6ksQEbkgm5vj7/o59d9IEREREZGL51L8m/5iUUWCiIiIiIiIiIiIiIjsSUGCiIiIiIiIiIiIiIjsSa2NRETk77Xv5bJCEXnxu5xaC332//0E585M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"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js:23:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:08.557Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js:23:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js:23:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:02:45.541Z","_duration":23016,"uid":"test-00-0","cid":"0-14","title":"TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_7: (TestCase_2 modified) should be able to add one item to cart, logout from InventoryPage, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9918fd86-88a6-4a7d-8044-86ccdb2df73d"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/clear","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/clear","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/value","body":{"text":"performance_glitch_user"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/9918fd86-88a6-4a7d-8044-86ccdb2df73d/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8d849ca8-783a-4d26-9a02-be8a9ca767b4"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/clear","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/clear","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/value","body":{"text":"secret_sauce"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8d849ca8-783a-4d26-9a02-be8a9ca767b4/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6940b076-f6ad-4910-ac14-3febe5bf69f9"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/6940b076-f6ad-4910-ac14-3febe5bf69f9/click","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/6940b076-f6ad-4910-ac14-3febe5bf69f9/click","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"af2f2f8e-001b-4fdb-a5f3-9e5bc6d285df"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/af2f2f8e-001b-4fdb-a5f3-9e5bc6d285df/text","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/af2f2f8e-001b-4fdb-a5f3-9e5bc6d285df/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bb799f3f-ad39-4bfe-99d8-2efa31a64e15"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/bb799f3f-ad39-4bfe-99d8-2efa31a64e15/click","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/bb799f3f-ad39-4bfe-99d8-2efa31a64e15/click","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3fcdfe20-8beb-4cfa-a2de-c89c66641962"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3fcdfe20-8beb-4cfa-a2de-c89c66641962"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3fcdfe20-8beb-4cfa-a2de-c89c66641962/text","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3fcdfe20-8beb-4cfa-a2de-c89c66641962/text","body":{},"result":{"value":"1"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3fcdfe20-8beb-4cfa-a2de-c89c66641962"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4b52e83c-6c0f-43de-b935-1ad0493d3340"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4b52e83c-6c0f-43de-b935-1ad0493d3340/click","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4b52e83c-6c0f-43de-b935-1ad0493d3340/click","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239"}},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":false},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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AAAAAAAAEgcVCQAAAAAAAAAAwFDCVSQAAAAAAACMBUtKbor3EgAAGBVUJAAAAAAAAAAAAEMECQAAAADw/7N397GS3fWd59/n+amqbtXt7ttt2pgQJwZnnaRJFqzITiRQRs0w6mSEkyjsTgLIwRrGiFky2QFlMZPBaALKZKyJ8LJyxgoJOxvEjNEkrSVubWRWiRFrGIYO8eDghDjYNG7f7r71eJ6f9o9f+QK2r7uN23TjfF7SFaW6Veece+peq/l9ft/vV0RERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9qQgQURERERERERERERE9uRe6gt4RtsneNfNd/MQR/ng8Zs58p0co53x1c/cx38+cR8nH95mWgB4DLau5NrXHeMtb7iRqycXeKxqm5Mn7uPE/3f/txwL/MkWP/SaY/ziTa/jyBXehR3q8Qc58X8f597PPsxj2ykVQDjm0DU/xk0//0aO/vAWvvNM79zm+K+9gzu/Atfe8mHuOLb1rOc5ffy9vOWuh+EN7+Pet18HwMmP/ALv+dQF/sy7nsdnICIiIiIiIiIiIiLf8y7PIOF5Wn3p47z79k/y1ScX/EdbHJoAbcrO9iN8/uO/w+c//hGu/tlf4wNvfRWTZ1y4Nx7909/mfR95gNPVU45Fxc7j25w8cTcnT/wBh376ndzxjuv3PlZ7ihP/9je58/5tEx7gMblii02gnG5z+kv3ceeX7uN3t67nbe/5pxz7weTi3AwRERER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N3L0FVvPfiBnzA3//MP88Zse5PgfH+fezz7MY49vM10f5+ofuZ7XHzvK0R/ewn+2xf/kGt78Wx/l6F/exx/+p+P8xd9NOb2od6/npa80xzl25DzXIyIiIiIiIiIiIiJyAS7PigQRERERERERERERETmv70ZFwotrRoKIiIiIiIiIiIiIiFxUChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRPChJERERERERERERERGRP7qW+gKd6/bFfuNSXICIiL6B7j3/iUl+CiIiIiIiIiIg8B6pIEBERERERERERERGRPSlIEBERERERERERERGRPV12rY3U8kJERERERERERERE5PKhigQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTggQREREREREREREREdmTe6kvQERE5FLa2Zld6ksQEbkgm5vj7/o59d9IEREREZGL51L8m/5iUUWCiIiIiIiIiIiIiIjsSUGCiIiIiIiIiIiIiIjsSa2NRETk77Xv5bJCEXnxu5xaC332//0E585M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"},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"6559586f-f5aa-42b4-aa40-f02e43359239","ELEMENT":"6559586f-f5aa-42b4-aa40-f02e43359239"}]},"result":{"value":true},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"5446242f9c540027e3ef23309ea0b55b","cid":"0-14","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js:23:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:08.557Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js:23:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js:23:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-14","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout7-inventory-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T02:03:08.614Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-14\\report.html"}