{"info":{"type":"runner","start":"2022-02-18T02:03:05.365Z","_duration":23588,"cid":"0-18","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_1014231875"},"goog:chromeOptions":{"debuggerAddress":"localhost:65501"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"e3908ded608f296de577175c34c9ce02"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js"],"sessionId":"e3908ded608f296de577175c34c9ce02","isMultiremote":false,"instanceOptions":{"e3908ded608f296de577175c34c9ce02":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:03:28.953Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":23588,"start":"2022-02-18T02:03:05.366Z","end":"2022-02-18T02:03:28Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:03:05.386Z","_duration":23193,"tests":[{"type":"test","start":"2022-02-18T02:03:05.388Z","_duration":23153,"uid":"test-00-0","cid":"0-18","title":"Login_3:should be able to login, logout, login","fullTitle":"UserStory: Login.Login_3:should be able to login, logout, login","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2c20c166-3f68-4193-b74e-e10d65f2b175"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/clear","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/clear","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/value","body":{"text":"performance_glitch_user"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69941552-050a-4d1c-86e0-b6b1d735affd"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/clear","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/clear","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/value","body":{"text":"secret_sauce"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"069d9b01-ea14-4205-ada1-5958cee6b9fb"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/069d9b01-ea14-4205-ada1-5958cee6b9fb/click","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/069d9b01-ea14-4205-ada1-5958cee6b9fb/click","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5e7ca5ec-64c9-4c8d-82e8-444d9802d16b"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5e7ca5ec-64c9-4c8d-82e8-444d9802d16b/text","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5e7ca5ec-64c9-4c8d-82e8-444d9802d16b/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95e21b43-cf52-49c8-b951-801a4274177c"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/95e21b43-cf52-49c8-b951-801a4274177c/click","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/95e21b43-cf52-49c8-b951-801a4274177c/click","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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3vfho3ztyYB9OObgxAcqdh6frdcCf+s63v7ef8qRH31q9H+tnfHZj76Pj/zJ9u7xJ5dPCIByus20OMd10of5vVv/NX/w1888THny6ndx+3tuOIeh098aEn3ktk9xy6GzvV5ERERERERERERELhWLhWmDc/z48fO+9qFDJmDsnveVLwGDHz3Chz/5Wh797DH+4Ni9HH94m5MLMMH7a7n+H7yWn//ZG3jJ5GwrweSn3swdn3wjj37xfo4du5fP/tU3OPm4GXbsj7Y4dOi1vObnbuDwS7eeeSFnzPX//KP80Zse5OgfHeWezz3MY49vM12v85Ifv47XHTnM4R/bwn+m4H9yNW/5zY9z+C/v5Q/+81H+4u+mnFzUu+fzwpeZdY4cOsv5iIiIiIiIiIiIiIicg0uzIkFERERERERERERERM7q+1GR8PyakSAiIiIiIiIiIiIiIueVEgkiIiIiIiIiIiIiIrInJRJERERERERERERERGRPSiSIiIiIiIiIiIiIiMielEgQEREREREREREREZE9KZEgIiIiIiIiIiIiIiJ7UiJBRERERERERERERET2pESCiIiIiIiIiIiIiIjsSYkEERERERERERERERHZkxIJIiIiIiIiIiIiIiKyJyUSRERERERERERERERkT0okiIiIiIiIiIiIiIjInpRIEBERERERERERERGRPSmRICIiIiIiIiIiIiIie1IiQURERERERERERERE9qREgoiIiIiIiIiIiIiI7EmJBBERERERERERERER2ZMSCSIiIiIiIiIiIiIisiclEkREREREREREREREZE9KJIiIiIiIiIiIiIiIyJ7ci30CT/W6I794sU9BREQuoHuOfupin4KIiIiIiIiIiDwLqkgQEREREREREREREZE9KZEgIiIiIiIiIiIiIiJ7uuRaG6nlhYiIiIiIiIiIiIjIpUMVCSIiIiIiIiIiIiIisiclEkREREREREREREREZE9KJIiIiIiIiIiIiIiIyJ6USBARERERERERERERkT0pkSAiIiIiIiIiIiIiIntSIkFERERERERERERERPakRIKIiIiIiIiIiIiIiOxJiQQREREREREREREREdmTEgkiIiIiIiIiIiIiIrInJRJERERERERERERERGRPSiSIiIiIiIiIiIiIiMielEgQEREREREREREREZE9KZEgIiIi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"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js:15:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:28.541Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js:15:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js:15:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:03:05.388Z","_duration":23153,"uid":"test-00-0","cid":"0-18","title":"Login_3:should be able to login, logout, login","fullTitle":"UserStory: Login.Login_3:should be able to login, logout, login","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"2c20c166-3f68-4193-b74e-e10d65f2b175"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/clear","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/clear","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/value","body":{"text":"performance_glitch_user"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/2c20c166-3f68-4193-b74e-e10d65f2b175/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"69941552-050a-4d1c-86e0-b6b1d735affd"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/clear","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/clear","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/value","body":{"text":"secret_sauce"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/69941552-050a-4d1c-86e0-b6b1d735affd/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"069d9b01-ea14-4205-ada1-5958cee6b9fb"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/069d9b01-ea14-4205-ada1-5958cee6b9fb/click","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/069d9b01-ea14-4205-ada1-5958cee6b9fb/click","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5e7ca5ec-64c9-4c8d-82e8-444d9802d16b"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/5e7ca5ec-64c9-4c8d-82e8-444d9802d16b/text","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/5e7ca5ec-64c9-4c8d-82e8-444d9802d16b/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"95e21b43-cf52-49c8-b951-801a4274177c"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/95e21b43-cf52-49c8-b951-801a4274177c/click","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/95e21b43-cf52-49c8-b951-801a4274177c/click","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":true},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"bef5aa53-f151-4c6d-b593-25c35d8988fa","ELEMENT":"bef5aa53-f151-4c6d-b593-25c35d8988fa"}]},"result":{"value":false},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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3vfho3ztyYB9OObgxAcqdh6frdcCf+s63v7ef8qRH31q9H+tnfHZj76Pj/zJ9u7xJ5dPCIByus20OMd10of5vVv/NX/w1888THny6ndx+3tuOIeh098aEn3ktk9xy6GzvV5ERERERERERERELhWLhWmDc/z48fO+9qFDJmDsnveVLwGDHz3Chz/5Wh797DH+4Ni9HH94m5MLMMH7a7n+H7yWn//ZG3jJ5GwrweSn3swdn3wjj37xfo4du5fP/tU3OPm4GXbsj7Y4dOi1vObnbuDwS7eeeSFnzPX//KP80Zse5OgfHeWezz3MY49vM12v85Ifv47XHTnM4R/bwn+m4H9yNW/5zY9z+C/v5Q/+81H+4u+mnFzUu+fzwpeZdY4cOsv5iIiIiIiIiIiIiIicg0uzIkFERERERERERERERM7q+1GR8PyakSAiIiIiIiIiIiIiIueVEgkiIiIiIiIiIiIiIrInJRJERERERERERERERGRPSiSIiIiIiIiIiIiIiMielEgQEREREREREREREZE9KZEgIiIiIiIiIiIiIiJ7UiJBRERERERERERERET2pESCiIiIiIiIiIiIiIjsSYkEERERERERERERERHZkxIJIiIiIiIiIiIiIiKyJyUSRERERERERERERERkT0okiIiIiIiIiIiIiIjInpRIEBERERERERERERGRPSmRICIiIiIiIiIiIiIie1IiQURERERERERERERE9qREgoiIiIiIiIiIiIiI7EmJBBERERERERERERER2ZMSCSIiIiIiIiIiIiIisiclEkREREREREREREREZE9KJIiIiIiIiIiIiIiIyJ7ci30CT/W6I794sU9BREQuoHuOfupin4KIiIiIiIiIiDwLqkgQEREREREREREREZE9KZEgIiIiIiIiIiIiIiJ7uuRaG6nlhYiIiIiIiIiIiIjIpUMVCSIiIiIiIiIiIiIisiclEkREREREREREREREZE9KJIiIiIiIiIiIiIiIyJ6USBARERERERERERERkT0pkSAiIiIiIiIiIiIiIntSIkFERERERERERERERPakRIKIiIiIiIiIiIiIiOxJiQQREREREREREREREdmTEgkiIiIiIiIiIiIiIrInJRJERERERERERERERGRPSiSIiIiIiIiIiIiIiMielEgQEREREREREREREZE9KZEgIiIi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"},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"e3908ded608f296de577175c34c9ce02","cid":"0-18","type":"result"}],"retries":0,"parent":"UserStory: Login","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js:15:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:28.541Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js:15:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js:15:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-18","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\login3.e2e.js","title":"UserStory: Login","fullTitle":"UserStory: Login","parent":"","end":"2022-02-18T02:03:28.599Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-18\\report.html"}