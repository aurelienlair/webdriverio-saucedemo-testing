{"info":{"type":"runner","start":"2022-02-18T02:02:17.970Z","_duration":23733,"cid":"0-4","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_18376846"},"goog:chromeOptions":{"debuggerAddress":"localhost:65197"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js"],"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","isMultiremote":false,"instanceOptions":{"6aeac624794a1e37fa2dcdfbd1d24851":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:02:41.703Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":23733,"start":"2022-02-18T02:02:17.970Z","end":"2022-02-18T02:02:41Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:02:17.978Z","_duration":23647,"tests":[{"type":"test","start":"2022-02-18T02:02:17.979Z","_duration":23635,"uid":"test-00-0","cid":"0-4","title":"TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e2314407-4ce9-4cf9-a151-bb645f18b732"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/value","body":{"text":"performance_glitch_user"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd4fcc63-a967-478f-bb64-ce4bbcc61ca0"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/value","body":{"text":"secret_sauce"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f7afa6a9-cefc-4fea-97a7-9b2dbb845b49"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f7afa6a9-cefc-4fea-97a7-9b2dbb845b49/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f7afa6a9-cefc-4fea-97a7-9b2dbb845b49/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e4686a75-78dc-4644-9638-473acb7b813e"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4686a75-78dc-4644-9638-473acb7b813e/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4686a75-78dc-4644-9638-473acb7b813e/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"af42cb0d-b2ad-4909-904f-f36077ffdab2"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/af42cb0d-b2ad-4909-904f-f36077ffdab2/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/af42cb0d-b2ad-4909-904f-f36077ffdab2/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6df53d3c-3ef7-40d5-b4fa-189f72654922"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6df53d3c-3ef7-40d5-b4fa-189f72654922"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6df53d3c-3ef7-40d5-b4fa-189f72654922/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6df53d3c-3ef7-40d5-b4fa-189f72654922/text","body":{},"result":{"value":"1"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6df53d3c-3ef7-40d5-b4fa-189f72654922"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"42ad95dc-c263-4163-ab29-ae264416435b"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/42ad95dc-c263-4163-ab29-ae264416435b/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/42ad95dc-c263-4163-ab29-ae264416435b/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8dffb402-d1ce-45f7-adf9-03f66b9b1222"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8dffb402-d1ce-45f7-adf9-03f66b9b1222/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8dffb402-d1ce-45f7-adf9-03f66b9b1222/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d7672ed2-3e6b-461a-8e5c-f31d06e9b8d9"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d7672ed2-3e6b-461a-8e5c-f31d06e9b8d9/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d7672ed2-3e6b-461a-8e5c-f31d06e9b8d9/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d/text","body":{},"result":{"value":"1"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05a6c454-e6a2-4c08-ab7d-1820a2e496bd"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"21fd9119-9f99-475e-b730-f3092aae06d0"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"18496f3d-8ace-461a-9198-d65185f3d872"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05a6c454-e6a2-4c08-ab7d-1820a2e496bd"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/value","body":{"text":"Jane"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"21fd9119-9f99-475e-b730-f3092aae06d0"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/value","body":{"text":"Doe"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"18496f3d-8ace-461a-9198-d65185f3d872"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/value","body":{"text":"90210"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0e793621-0f9a-4c05-a8f5-cd23e2faea25"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0e793621-0f9a-4c05-a8f5-cd23e2faea25/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0e793621-0f9a-4c05-a8f5-cd23e2faea25/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a75756fb-cc23-4b4e-b627-4e2c020fed39"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a75756fb-cc23-4b4e-b627-4e2c020fed39/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a75756fb-cc23-4b4e-b627-4e2c020fed39/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"77faf251-3601-43df-aee9-e8a80b456dfc"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/77faf251-3601-43df-aee9-e8a80b456dfc/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/77faf251-3601-43df-aee9-e8a80b456dfc/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"iVBORw0KGgoAAAANSUhEUgAABhIAAANUCAYAAABWkrf4AAAAAXNSR0IArs4c6QAAIABJREFUeJzs3Xt41PWd9/+XIRlCDgMBDZBBuNUuZiztpnVJyoLtTRIbdK8oga23tjWxP1budYndi54geNhWKsG7B667BPUH5VcT1uplC6HN9VOyhvBrDbebsK1ZFxmga1mQEYhiwuRAmBz4/THMMKfvHJJJZgjPx3VxOZn5fj/fT2aSFj6v7/vzvuHy5cuXBQAAAAAAAAAArjkOh2PMr5E85lcAAAAAAAAAACDBXPyXN9R/8C0NvPeuBk+e1NCFLknSpKnTlDxvnlI+/VmlLr5LU758T5xnGn83UJEAAAAAAAAAALgeDHc71L3jBfW+8s8a6vwkonMmZU1X+kNfV+ajjykp0zzGM4zeeFQkECQAAAAAAAAAACa83l+9qgv/69mIAwR/k7Kma+r3nlD6Vx6M8cxGhyABAAAAY85ps+ni/v1yHrVp0G6X02bzeT3ZYlGyxaLU/AKlWK1KKyqK00wBAAAAYGQ6/2mDel6ujclYGV+rUNYPNsVkrFggSAAAAMCYGLTb1V1Xq576eg2P4C+dGWUrlF5WptT8/DGYHQAAAADEzvm1a9TXsDemY6aVLteMLdtiOuZI0WwZAAAAMTVot+tCTY166veMapy+pjeVWV4uSZ4gIsmceHuFAgAAALi+df7ThpiHCJLU17BXSeapCVWZMJaS4j0BAAAAjI8LNTU6U7Z81CFCUmamZtbtkslqlSQ56mplLy5SX1NTDGYJAAAAALHR+6tXY7adUTA9L9eq91evjtn4iYStjQAAACa4YYdDH1WuUX9bm+ExptxcpZet8IQDptxcJZnNGnY4dK6i3NM3wT9EGHY4ZC8u8lQlmCsqlFW1YYy/IwAAAAAIbbjbobOFi6NurJz67P+nG//HTF161qqPfhH++ElZ0zWr+aCSMuNXoc3WRgAAABgVp82mjyrXaNBuD3gtOSdHUx9/XGlFxYbbEnVWVxuGCJKrGsG7x4KjtlbDjm7NqK6O8XcCAAAAAJHr3vFC1CFCcmmNpi3/C92gyBfmhzo/UfeOFzT1W+uineI1hYoEAACACcpps+lcRXlAM+WkzExlVlTIXF7hCRCGHQ71Ne/X0Gm7+ttaXc91dwcNEfrb2pSan69Bu132osKg184oW0GYAAAAACBuPlz4maiCBFPlLt34WKEmTZYkh/ojrEiQXFUJOYf+Y0TzjIVoKxIqKipUWxvdlk9UJAAAAExA7u2M/EMEU26ubtr2vJItFklSf1ubuutqQ/Y38A4RzldVaWplpSTpwtathuf01O/R5PyFyihbMfpvJgSnzSbnsaMaOn214mJyQb5Mt+fS/HmMDTscch47qkG7PeD9T86xeH7GEF/9h65uacbvBQAASBSX2t6O6LjJ+YtGNP7Ff3kj8hBhXpmmPfs9ZXxhrm4Y6tCQI1uTovwr01DnJ7r4L29oypfviX6y46yiosLz32jCBIIEAACACSjYdkZpRUWaUb1ZSWazBu12dVZvCtsg2T9EuCEzQ8kWiwbtdvXsrQ957vmqKplyrT5bIcXCsMOh7rq6gG2VPGpc/0krLlZmeYVS8/NDjtfX1KSPKtf4PJexvEwzNm8OO5dzDz/ss1CbVlSkm7Y9H/a8TzY9q+66Op/nZlRXjyh4sRcVBnzWmeXlmr7hiajHCmfY4VDv3r3qa3rTuOfGlfc/2WJRWnGx0peXjfhn4JNNz2rg6FGl5OaOyfdjxDuEm1G9edShyLnyhyM6LslsVmp+gdKXLx/Vgn/P3np119Z6Koq8maxWpRUVK7O8nFABAADETcdX/zai47Jf/rUmF0QfJvQffCvygx/7R2V+Ya506ZQubvofGi5/W+kj+GtS/8G3Ej5IcIcI3l9HGiYQJAAAAEwwXTVbAxZ5vRe4+9vaglYr+PMPEfqa3pRlf7Ok0NUI3s5vqNLs+r0j+C6CC9XzwV9fU5P6mpqUmp8fcjE4WNDgPHY0ovl4hwiurw9FdN6ALXD81PyCiM715rTZgr4XF/fvl2K88N6zt14Xtm6N6L2XpEG7XY7aWjlqa8N+BkYGbEdd7/E4bsbqtNl8Arae+j2aVvn4qMYM1ejcX19Tk7pqtmpa5ePKLC+P6jpOm03nN1QFDRC8j3HabHLU1cpcXuGpMAIAAEhEF9/cN6IgYeC9dyM/eMihwX/9v3XhiWfUd1KaHt1fwUZ2zTjwDxG8n48kTCBIAAAAmEAG7faAO91NubmaUe26u76nfo/OV1WFHcc/ROip36OplZVKMpvltNnCViO4OW029dTvickWR0Y9H8Lpb2tT56ZnDSsFksxmmXJz5Tx6dXHfabNp2OEIecd2X5BqjmGHw9NDIuSc/AKI5JycEd313m3wF/5Buz2ieURi2OFQZ3W1eur3jHiM/rY22YsKR1x1MZ7839Pe+vpRBwluqQvzNbkg+Gcy7HB4gpNhh0OfbHpWTpst4l4j/r8fyTk5Sl+xwieg6m9r1cWmJjmPHtWww6Gumq2aUlQU86ohAACAcEJtWTTcfUEDtiOSpP7WyLZA8jd48mTkBz9xn86M6CqjuOY4MwoRvF8PFyYQJAAAAEwgF7Zu9VloT8rM1E3bnleS2az+traoQ4RPNj2rnvo9SsrMlLnc9ZfPzupN0c2ppiYmi8fnN1RFHSK4ZVY8EvL1yfn5PkGC5Fr8TisuNjzH3ZQ62POhFvCD3Z0+kmoESepr3m/4Wu+ePaMOEoYdDp2rKA95h7ubfxgTTFJm4m+l435PM8vL1V1XF9NQZnJBfthQor+tTR+t+QcNd3erp36P0svKIrp2Z/Umz++H0dZcqfmu67vDtaRMMyECAACIi+xf/jrk6x98ynWTzYDtPQ2e/kDJc26OavyhC10jnttIxeOakQgXIngfFypMIEgAAACYIIL1LcisqPD0NPDvA2Aka8MGmaxW9dTv8VQ3ZFZUeMKIaLZp8cxrlFUJfU1NQRezp1ZWylxe4akccFcEdNfWeu76TysqCrsQm5pfEFDJ4TxqCxkkXDLYxuhSa5sUYreYYAGE0V3qofQ1NfkEK8k5ORr88MOrrzfv14yoR/VltE1OUmam0svKlFZ8d8B76/4MLjY1+fw8phUVhXw/E0Gf13tqrnhEF5uaNPjhhzEJZSKVmp+vm7Y97+mrEMm1vX8v04qKwvb3SM3P18y6XbGZMAAAwBiYUlyii02NkqRLrW9HHSTgqmgaKoeSFJNRAAAAEHeO2pd8vk7OyfFUEZyvWh/R3fzurWe8t0BKzsnx3EV9oSay3gj+/Bfpo9UbZFudqZWVmlb5uM/2Q0lms9KKizVz1y7NrNul5JwcZUXQKyDYQu2lVuPAZNjhMLxL33/bokjGTSuKfoH9ot/WSlOKi5Wck+Mzx74wzbRD6arZGvT8tKIiWfY3a/qGJ4K+b+7PYMbmzbLsb1ZaUZGSc3I822slMvfPmXurqSlXgo++5v0jroYZidT8fJlycz3XDsc7nIrk511yfU40WwYAAInKuy/CxTf3RX3+pKnTYjmdhL3meKIiAQAAYIK4uN93wXHq449HVUUQLERwjyO5FqYn5+drcoR3Zl+oqfE8djcFHkkfANe1uwOeC1fhkJqfL0vzgYjGD9YnIVQgEO79DLUVjv+4ptzcqBd0hx2OgOqT1PwCXXZ0+zzfW79nRFUAww5H0PDHaMscI8kWi27a9rwG7faEX7QedjjUd+V3KH2F62cro2yFuuvqrrzWNK79HZItFk8vg3AGvEKtkf6OAQAAJJIpdy9T17PflyRdaou+T0LyvHka6vwk1tMKe82JjCABAABgAnAv1Htz3+Xe7VepEIxRiJCck+NZPE0ym6NqOutu6urW19Qkc4T7c0YiKTMzZmNJxn0SggUC/tUA/tsKGfVJCBZARBrMeOvbH6RSoLhYw92+AUPf/v1hm0YH46irDVjANuXmRhUieLsWFrd76q++b+6feZPV6vlse+vrxzVICBaeGZnk9f6O5PMGAABINMlzblayZY4G7ac17HDoUuvbPlUKbkYhQ9JN2WM9xQApn/7suF9zPBEkAAAATAD+C9Tuu9y977I2YhQiSFLa3XeH3arHX3KOxbMtjPfC/EAEDXuNJJkDQ4PO6mrNqK4e8Zj+gvZJsNmCBwJ+70n6ihU+FRgX9+8PGroE648wkkbL/kFGWlHRlf8W67x8P8OR3EnfW18f8FykW+Zcq3qvBDCm3Fyf4COz4hF1Vm9Sf1vbqKpqojX4oSsYTF0YPmjybpjsqKuNKvADAABIVFPuXqbul34uybW9UbAgoeOrfzve0zKUuviueE9hTBEkAAAATACX/Bao068sHAe7c91bqBBBkhy1tXJE2Zwrs7z8yv75Bbogr+2Njh0NcVZoU4qLAwKRnvo9Gu52KKtqQ0wWd4P2SWhrlfyqKAbt9oDqj4yyFQFbOQW7MzxYmBJtE99Buz3gvXDv5Z9kNiutqMjn9WjvpA9W3WLKzR23ZsPx4LTZPD0vMv0+77TiYnVWb5IU+6oaI47aWs9nkL6iLOzxaUXF6szcpOHubl2oqVGyxTKu1RMAAABjYXLBIk+Q0N8a/fZGN0i6HOM5GZmUNV1TvnzPOF0tPmi2DAAAMAH4b4PivkM5VMPgcCHCSA3YXIGBu1msm1Fz4khklK0IGE9yLezaiwp1vqoqYPE7Wu4+Cd76Dx0KOM6/qiB1Yb6SLRafRseu4wLfe//xRtIfoS9oA+SrfRCm+PVEcN9JH6lYbb90Lenxaubt3/g62WLxVAV010UXqo1Ed12dLmxzhVKm3NyIGnEnmc0+zazPV1Xpo8o1o/6dAAAAiKfJBX/teTxge0+Dpz8IPCZ/keGfpJzx214z/aGvj9u14oWKBAAAgAnAaPsho4VEd4jgtNnUu6c+ou1TQnEetWm42xVmuCsPYr1P+03bnteZ5fd7ruOtp36Peur3KDU/X+krVihjefi7uIPx75Mw7HAEbGfjH85MLnC9d6n5BT79CfrbWn0aHburFLz5L/pHotevyXJaUZHPex10e6Mo7qQf7g5s7ptsmRP1PK8l7kblGcvLgv7cpq8oU/8hVyDjtNl8thKKxqW2Np/KFW/OozafahBTbq5m1u2K+PcorbhYN9Vs0/mq9Rru7lZfU5P6mlzbWqWXlU3oihIAADAxJZnNmpy/yNMH4VLr20qec7PPMdm//LXh+cPdDp0tXBx10+VPSiyK5oxJWdOV+ehjUV3jWkSQAAAAMAEFu3vfzR0iSK7KhZm7do3qWj31e9RfdXVx3X+xPFaSLRZZ9jfrozVrDIOT/rY29be16cLWrcqq2uCzkB+JYH0S+ttafbaJ6WveH3CO5AoUvIOES37VB8Hu9I+2P4J7IdubfxgRdHujvfWRBwlBPr9oFs6dNptnKyAjM+tG9zMXS31NTZ7Fe6Ngxzuc6a6tHXHTaffPZzhJZrOyNjwRdRiXVlys1PxmdW7a5PlZdIdsJqtVmRUVIw7ZAAAA4mHK3SWeIOHim/uUvvKBiM9NyjRr6vee0CdV3x6r6UmSpn7vCSVlxvYmqkREkAAAADABuRcgnUd9F529Q4RYCLYtkv8WP7GUZDZr5q5d6qnfowtbt2rwww+DHjdot+ujyjXKKFuhrKqqiBdkg/ZJaG3zvGf+VQVJmZmec/xDAf8+Cf59LIyuF4r3Fjxuwba+8e8p4b7TfaS9JKIJh4a7uyNaLE8U7sbVyTk5hsFTktmsjOVl6tlbr77m/ZoxwmulLsz3VLD4G7DZNOzoVv+hNg07HDpX/rCnyiAaSWazZmzerKmPPy5H7Uvqra/XcHe3nDabzq9frwtbt2pG9WYqFAAAwDUh9QtXtzdyBwrRSP/Kg3Ieflc9L4/NFpUZX6tQ+lceHJOxEw1BAgAAwARmyrV67t5PMpvVW1+v3vr6MGeFllW1QSar1bC3gnsbnLHcnz2jbIUyylaor6lJ3bW1hhUKPfV75Dxq0+z6vRGNm2Q2K3Vhvs943k2i/RfIvRdjky0WmXJzfbZG6m9r8yxO+/dHGMl2Uv6fnf+2RlefD9zeyFH7kqZveCLsNYKN5zxqi7q641ow7HB47twPt83UlOJi9eytd51Tv2dEgdzkgnxNq3w87JzcFQV9TU06X1WlGdXVUV8r2WLR9A1PaFrl4+qpr1d37Usa/PBDDdrtOlf+sDLKVoxoXAAAgPGUYv20ki1zNGg/rWGHQwO295Ri/XRUY2T9YJOGHRfU1xDZvwkilVa6XFk/CF2JO5EQJAAAAEwA/gvYwfZxH3Y4Rn2n+Izq6pAhgiQlmTMlBQYJY1GpkFZcrLTiYjltNnXX1vpsLeTmtNnUVbM17AKu2+QCvyDBq7LAv6pgsl8Vgn+PhYtNTUorLtag3R5wV7/RnelGvPfPdxvu7jbccz/ZYvE5/uL+/VIEQUIwQ6cnZtPevv1XG1df7u4xfC/9XbzSe2AsuCsKJKlnb7166veMqsdBktksc0WFzBUVctTW6kLNVg13d3uqWwgTAABAoptcsEiDe34lSep7c5+mRhkkSNKMLduUZJ4as8qEjK9VXFchgkSQAAAAMCH478k5aLfLZLUGLIqPhntbpFAhgnR1cX3Qftrn+bFs2GuyWjVj82ZlVlTofNV6n8V8Sequq4s4SEjNL9AF+S4ouysLAqoK/BZ3/XssuN/7/qDbGkXXHyHYtkaR7rkvKeJGwWlFxQEL6tFs55NssWhqZaXn66HT9qABTyLw/qyCvb9G+vbv99m2aixkbdjged+6a1+KyVZE5ooKpebn61z5w54wgUbMAAAg0U25e5l6rwQJF99s1NRvjqznQdYPNsm04LO68L+ejboBs9ukrOma+r0nrpvtjLwRJAAAotLzy13K+OrDCTcWcL3zDwz621qVVlysjLIVUS9Y97e1BiwkRxoiSPJsgePee957jmPNZLVqZt0unVl+v0//BHc1RiQLpsGOcR61KclsDuiP4L8o73/uoN2uQbtdl1p9F/u9eytEqnfv6EuxI2kUbLJalZyTE/D+RbqdT7LF4hPa9Le1JWSQ4N242pSbG3GDPPfvWU995A2sR8J7my3/AGs0TFarbtr2vM6Vu/7/N1YhBQAAwFiZXHC1T8KA7b1R3dCR/pUHNWXZvere8YJ6X/nniAOFSVnTlf7Q15X56GPXRWPlYAgSAAARc7y4VRd+7FqAGm0A0PPLXep8er2GHV0y/31kdwkDMGbK9V3Qdm9jk2yxRN1gt7Pat0Q3mhDBlJvruZ53s18p+jvwRyrJbFb6ihUBYYirQiKyBVP/Pgn+QYAUPHBIMpuD9EloDagKiXbhtq+pKaqGx4bjRFhZkJpfELD431ldrbSi4jG9C388OWpf8jy+advzEf+e2AuXavDDD9W7d2yDBElKseZ6mi/HUmp+vufnNJYhBQAAwFhIMps1OX+Rp9nyxTf3KX3lAyMfL9Osqd9ap6nfWqeL//KG+g++pYH33pXz3X/X5eFhzzEpt92mlE9/VqmL79KUL98Tk+/lWkaQAACIiHeI0Pn0ekkjDxPcIYIkz5iECcDoBLsTvrN6U8R3y6SXlSnZYnE1J75yl7YUXYggSVlX9uD33yZmJHfg+3NXFYy06W80WysF9Ek4dtTT+8HNqDnvlOJinyDBXZXgM36UoYp/dYck3VSzLeyifl/Tmz7b9ww7HOq70rchlKmPPx4QJAw7HDpXUa6ZtXVRhQneP0+J5OKVoMs7/IqEO6Ry2mwRbRU1GkNj2LDc/b8NsQ4pAAAAxsKUu0s8QcKl1v8zqiDBZ9wv36MpX75Hg6c/0Jn//gVJrn+7WN5JzL/DxhNBAgAgIhlff0T9vzugS4dc+3yPNEzwDhEkafLCAmV8/ZHYTRS4TiWZzUorKvKpAnDURtZILDknx7Onvfdd/NGGCKkL8z1hgX81QFrRyBb/vXVWV6unfo/Sios1Y1O14WL2sMOh3vrArXSSMjODHB2cf5+EYYfDZ6sf9zGRnBusgW80ocqww6G+Zt/qDlNubkSBSrLF4hMkSFcbQIc7L7O8POBcp82mcxXluqlmW9jF92GHQxe21UT8czie+tvaPOFOZpRVBRllV6tdeur3aLp1ZA2sI+EOpKL52Y3WWI4NAAAQK6lfuLq90cWmxpiPf/HNfZ7H3lsp4aqkeE8AAHBtSMrI1I07ajV54dWFs86n16vnl7siHiNYiHDjjlolZbCIAcSC0R3y4czY/Jwk16Koe3E12hAhKTNTWRs2BIzjNvXx0VUd9dTv8VQ59DU1yV5cpPNVVQFbBvW3telcRXnA9ZNzcqK6czxonwSvO+uTc3IMF9LDhQTBeiuE0rc/cFuj9Ah6FUiuQMCUm+vzXM/e+ojuQp9W+XjAuZLrfbAXFQZ9/92vd1Zvkr24KCFDBEnq3XO1YibakMv7PY1F3woj3mFHuDkOOxxBAysjg3a757OjPwIAALgWpFg/7akwHnY4NGB7L6bjX2p92/N4yt3LYjr2REGQAACI2GjCBEIEYOxllK1Qck5OVOcEqyKINkRwnbNZJqtVww6HOqurA64RbZ8Gb65tmnzHdDf/PffwwzqZe7vnz7nyh4NupZNZEX3lU+pC4wXWcP0eQp8b3cJtsG2NotneKVjo0Lc/cEx/SWazbtr2vOEd697v/wf5C2UvKtTJ3Nt1pmy5HLW1CbtljneFR1pR0Yh6PrirGNxbRcWa02bTR5VrPF+HC+LOb6hSV81WnSlbHnYrqWGHw2fskfxuAAAAxMPkgkWex31eFQSx4F3l4H0dXEWQAACIykjCBEIEYPxEe+e/+/iumq0atNuVWV6ujLIVV+4qrw5ztsuM6mrPwva5ivKABeQZmzdHNSd/SZmZSl24cMTnpy7MH1FT3MkFxgv+oV6TQleHRFM5MuxwBDStjnZP/2ChQ7BwIphki0Wz9/4maGWC/zz9q0DcYrF1znBPt/oPtUX1x4h3hUeklR3+vCsEIn0vJWnI/mHIOfft36/zVVU6U7bcM8cZ1dUhP+9hh0ODp09LcgUQZ8qW66PKNerbv9/nMxl2ONSzt94nbEgrKqIiAQAAXDO8KwUuvhm77Y28tzVKsd6h5Dk3x2zsiYQeCQCAqLnDhI8frQjbM4EQARhfGWUr1LunPuRCqpu7GmHY4VB3XZ0ylpdp+oYnPPvgh7ujPCkzUzOqN3sWqs9XVQXcDT21snJU1QjS1TvjHbW1ulCzVcPd3RGfm1ZUpBnVIwsy/Hsd+I4bOgwItTgbrprBW7DKgWgXv91b8Xg3gO7bv1/DDkdEd+MnWyyaWbdLXTVbA3omhJO6MF8zNm+WvagwqvP8OW02nXs4up48844eC/q8u39GUmbmiBt3J5nNylhepp699erZW6+sDRsiei+9t+gKe40r24VlhPm8k8zmgM+nr6kpbKVE6sL8Ef9uAAAAxIN374IB23sR/302HO9tjVKv8f4I7e3tMR8zLy9PEhUJAIARiqQygRABiI8ZmzdHdBe4uxrBUVertMIizdi8OeIQIXVhvmbW7VJacbGGHQ6dr6oKWCA15eZqWuXoeiN4M1dUyLK/WVlVG8Ju4ZSck6MZ1dWurXlG+I8LozDAlJsbdkyT1Rr0MwjVWyGYYAv3I1n8DhY+9ARpSG0kyWzW9A1PyLK/WZnl5WHf/7SiIt1Us00zd+0adZAUS4N2u/rbXCHbaBuAe1eWRLJVVKRSF+Yrq2qDLPubw4YIbt6fT8byspC//+7fjZm7dsXkH94AAADjJclsVor1Ds/XF2O0vZH3tkb0RzB2w+XLly/HexIAgGvXcE+3T2WCJGU947rDkRABiJ9w/Q0ylpdpxubNGnY41FWzNeJKhLSiImVWPOJZZB92OHSuojygEiEpM1Oz9/5mTBeRhx0OOY8eVX/b1f/9MeVaZbJaE2rxeqJy2mwa7u72ef9T8wsiClow9pw2m5xHbZ7tjVyVKdaoGn0DAAAkmgs/+4kcP/upJFcvg1hUEFz42U8kuf4NY3nnaJijE5Pjyr/hxrIigSABADBqwcIEb4QIQHx01Wz1NFD2Z9nfrGSLRYN2u5ItloAQwZSbq6RM12Lw5AJXs+S0omKfBeLuujp11WwNCB6SMjM1s24XC5YAAAAAYmrA9p7Oln55TMaeUlyiG1/8f8Zk7LE2HkECPRIAAKMWrGeCGyECED/TKh/39D/wlrG8zHPHfrAQwV2tEMyww6G+5v26sHVr0Oa6hAgAAAAAxkqK9dNKysyMqm9apNjWKDSCBABATCRlZGrKl+8JCBKmfPkeQgQgjqZveEImq9VnmyN3bwRJgZUIVqvn9WGHQ85jrtLeAdtR9TW96dlfPhhTbq5u2vY82woBAAAAGDPTnnxGg/YPYj7u5IJFMR9zImFrIwBATPg3VvaW9cxmZXz14XGeEQBv/W1tOr9+naYUF2v6hickBYYIozG1sjKmjZUBAAAAAJFhayMAwDXBP0Qwff6vdIOkS3/8N0lXmy4TJgDxk5qfr9l7f+P5OlYhQsbyMk19/HGqEAAAAABgAiNIAACMin+I4O6JIMmnZwJhAhB/3o2SJSmtsEh9+5ui3l80KTNT6WVlMlc8QoAAAAAAYNxd+sMhXTr0r5qUPUvp96+QJk2Keoz+lt/pUvs7SrnlVqX9zX1jMMuJha2NAAAjZhQiuHsiDPd0BzRgZpsjIPH0t7Wpv61VAzabBu12OY8e9XndlJurZItFKVarUvMLlJqfH6eZAgAAALjeOX72U1342U88X6d8ar5uevlXmjTjxojH+OTp9er95S7P15PzFyn7l7+O6TzH03hsbUSQAAAYkXAhghthAgAAAAAAiIXh8x/LXvCXAc+b/+caTf3uhojGcP7Hv+tc2b0Bz2f9YJMyvlYx6jnGw3gECUkxHxkAMOFFGiJIUlJGpm7cUavJCws8z3U+vV49Xsk/AAAAAABAOM5jR4M//x//HvkYR48Ef/7wf4xoTtcLggQAQFSiCRHcCBOlbE0jAAAgAElEQVQAAAAAAMBomW7PDf78ZwKrFAzHyL0j+PMLPjOiOV0vCBIAABEbSYjgRpgAAAAAAABGI2nGjZr6zW/7PJfyqfnK+L9WRzyG6TN/qXS/7ZZTC/76mt3WaLzQIwEAEJHRhAje6JkAAAAAAABG49IfDunSoX/VpOxZSr9/hTRpUtRj9Lf8Tpfa31HKLbcq7W/uG4NZjh+aLQMAEsag/bQ+frRCA8ePjjhEcPMOE1Lm5+rGHbVKtsyJ8YwBAAAAAAAmPpotAwASRrJljmdrotGECJLvNkeECAAAAAAAAImNigQAQFSGe7pHFSKM1VgAAAAAAADXIyoSAAAJJ5YL/4QIAAAAAAAAiY8gAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABhKjvcEAACIp2WlD8R7CgAAAAAAACP22ss/H/NrUJEAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMDQNdMjwfbzb2jtb3olWfToC1u0ck6IgzsatXbVTtlUos0Nq5QX0RU61PCdSm07JpVufE1rIjvJWPtOLXuqUfKeg2de0bGurtGW0myvMSM1X2t2/lCl2f5zkiJ6HyXpdINWP7ZLpyTJ6P0c6tWpg416pbFZh452qMcpSSnKyJ4j66JCrbyvRHnZ/icBAAAAAAAAAK4F10ZFQn+rfvtGr2RKkUl2vbLveLxnNAHY1dhmD3vUqZbGKyGCgY9btWX1aq3+0as68K47RJCkAfV0nNCh3+zU+lVf0/qG8NcCAAAAAAAAACSea6IiwflvrTrglDLuLdTC1xt14I19Ovj1+VqcGu+ZRSm7RFsaSgKePtvwpB7Zfly6fZVe+nGJZoUdKJpKiyBMKTI5B3Sq+Y86tcKiuYYH2nWwucN4nCG7Xvn+T9TYIZluLdHafyzV4nnZMk1yvezsOKGDe1/UloYTat/+pLbk1GjtnekjnTUAAAAAAAAAIA6ugYqELh1obJGUoqWLHtSSpSmSs0UNLV3xnti165YCLZ4n6WSjDp4McdyxZu0+I8364hJZg73+n83afVKSuVBPbVqlpbdeDREkyZR9i5aufk7PrZgmqVeNr7TobCy/DwAAAAAAAADAmEv8IOH0W9rdLslUqMWfSdfCRQUySWrf+1boLXcQwu1aUmiR1KHGt423HLK91aweZatk0e1BX+/8rxPqkaTZt+jmEIUG1mWluk2SqaNTnaOZNgAAAAAAAABg3CV8kHCqrVmnJGXcc5fyJkmm/GUqNUs6uUeNR+I9u2vXbfmFmivpbHNr8EBm6LhaDvRK80q0eH7wMbL+2y3KkKQTx2RzhLjY7FJta3hNv617MHhlAwAAAAAAAAAgYSV2kDB0XI277ZLSVXLXldXsSfO1pDhdUq8a9rXKGep8GJtToNLbJZ1pDr690bFWNTqkuYWfN+6h8KkSVdzh2mrquVVr9dTLzbKd7pVzaOymDQAAAAAAAAAYXwndbNnZtk8NDknzVqjEa3cd690rNHfPLp060KgD3yhQSVbcphgnjVpf2hj2KOvqGm0pzTZ4NVsLvzRfOnZcjW/b9dA8i8+r7b/bpx7NV8USi6TDwYeYlK3Sp/9Jnzz1A73yJ7sOvfqiDr36oqQUZf3FAuUvKtDSOz+vO+ZN8+mdAAAAAAAAAAC4diRwRcKADr3tqjiwlhT43hU/5y6tzJOkw9p9wHiPf4Q2q+AuWRVke6OhwzrYNCDlFWqJUQ7hlj5fFT99Wa/872+q4osLNMucImlAnX96R411L2r9P67WfQ+u05bf8zkBAAAAAAAAwLUocSsSOt9Sw4EBSQu0LGA1e5ryv7RAaj+sU7ubZbv/YVmvqzveS7S5YZXyRjtMdoGW5e2Urb1ZB0+u0Nx5rqedbc1qdEp5X/q8Ii32yLp1iR767hI9JEn9HXr/+GG1Nbbot22H1dl/Qo0/Wqu2957WjscWuPoqAAAAAAAAAACuCQkbJJw60KB2SdJhbSl/QFuMDnTs02/bHpR1Ucq4zW3iuBrI7G4+roe+MV9XK0EWaOmd00Y2bGq2bvtsoW77bKEeGurV+6+/qCe3t6rz9Z/plcLtevT28EMAAAAAAAAAABJDgm5tZNehZrukFGVkZ2vWbIM/V7bROfD6W+qM95SvUVl3LlGepJ6mVtkkqf+PajkwIN1ZqMWhyhGc72jHqm/ovtIn1fBxiOMmpeu20m+q8ouS1KUjxztiOHsAAAAAAAAAwFhLzIqEI8165aQkU6Ge3L5KeUbbFh3Zpb9d16Ce9gY1ny7UyjnjOckJIqtAJXe+qPY/NKvl2MO67aNWHZC0tLgg9BZEpmxlTOqVU8d1sL1LpcWhqhdSlM5+RgAAAAAAAABwTUrAioQBHdy3Tz2SMu65yzhEkKQ7CvXQPEmy65V9x8dnehNOuhZ+6XOSetX4fw7r0NstkpZoyV+F2yrKosXLLJKk9pfrdDBUVULvOzrQIkkp+tTN4bo3AwAAAAAAAAASSeIFCf1/VMvBAUnpKvnr+WEOtmhhoWsxu+eNfTrYP+azm5Ay7rxLCyX1NP1EW34vmZYWaGFq+PPmlqxS6Y2SPm7Rxv9ZqY17DutU78DVA/o79P7vX9VT3/yxGh2S6Y5yrRx1h2gAAAAAAAAAwHhKuK2NOlsadcApyVyoJXeEP37u0lLl/eJFtTtb1NBSrsU+W+w0an1pY8jzratrtKXU9y75hqceUEOok25fpZd+XKJZ4ac3RsJ/X27Bvr8A5gIt+6J06Pe96lGKli76vEyRDJ6+QGt+9G051/1MjR0dOviLZ3TwF8EPNf3FCj33dDzfMwAAAAAAAADASCRYRUKHWvYdliTNXVkoaySnZN2l0i+6HrbvfUunxmxuE1mKFi5a4npoKlRJfrhtjbzcWKC121/SSxtXaWX+LVcaYF+ROk235ZdqzcYa/fanD8qaHttZAwAAAAAAAADG3g2XL1++HO9JAAAQL8tKH4j3FAAAAAAAAEbstZd/Lklqb2+P+dh5ea696hOsIgEAAAAAAAAAACQSggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhpLjPQF/y0ofiPcUAABjaF/Da/GeAgAAAAAAAKJARQIAAAAAAAAAADBEkAAAAAAAAAAAAAwl3NZGbHkBAAAAAAAAAEDiSLggAQCAeCjd+AutyUt3fTF0QruXr9OO+E4JAAAAAAAgIbC1EQAAWqC8nPSrX545oYb4TQYAAAAAACChECQAAKDPadaMq1+d/a8WnY3fZAAAAAAAABIKQQIAAF+7XTdPcn/RpQ/aDsdzNgAAAAAAAAmFIAEAcN1bemu2TO4vek+r/UA8ZwMAAAAAAJBYCBIAANe5bOXfPO3ql+dOaHf8JgMAAAAAAJBwCBIAANe5Es3NvvrVqT83xm8qAAAAAAAACYggAQBwfbv/Fs309Efo0Ae/64jnbAAAAAAAABIOQQIA4LqWl5utDPcXnXa1tMdzNgAAAAAAAImHIAEAcF1bevPVfY16Pjgs+iwDAAAAAAD4IkgAAFzX5s50PxrQB0ca4jkVAAAAAACAhESQAAC4rt2ceuXB0GkdeTmuUwEAAAAAAEhIBAkAgOuapz/CmROiHgEAAAAAACAQQQIAAJLO/leLzsZ7EgAAAAAAAAmIIAEAAPXq7JHD8Z4EAAAAAABAQiJIAACg3y4b+xoBAAAAAAAERZAAAMCHx1Qb7zkAAAAAAAAkKIIEAMB179SfG+M9BQAAAAAAgIRFkAAAuM516IPfdcR7EgAAAAAAAAmLIAEAcH3rtKulPd6TAAAAAAAASFwECQCA61rPB4d1IN6TAAAAAAAASGAECQCA69oHRxriPQUAAAAAAICERpAAALiuHXk53jMAAAAAAABIbAQJAIDrGvUIAAAAAAAAoREkAACua2fjPQEAAAAAAIAER5AAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwlx3sCkbL9/Bta+5teSRY9+sIWrZwT4uCORq1dtVM2o9dN6Zo1b76WLi/XysUWZUwKc/HOEzrQ1KDGNw/ryJkuOX3GeFD3Lb5FWUZjtO/UsqcaJZVoc8Mq5YW80GFtK31GDZqvNTt/qNJs6WzDk3pk+/EwE/R39XwAAAAAAAAAAEbj2qhI6G/Vb9/olUwpMsmuV/ZFu7Dux9mrs396R6/8aK2++v1GnR0yOG6oV+0vr9N95ev0XF2L2s/0ypSdrVmzszUr1XlljHV66MF12vGHrtHNCQAAAAAAAACABHRNVCQ4/61VB5xSxr2FWvh6ow68sU8Hvz5fi1PDnWlQBeDs1an2V/Xcc416v71O235foI1Lp/kd1Kv27Wu1/vUuyZStxY98U5Ul85Vl8jqk87gatv9MO1pOaPf31+j9x7Zo872xLQOYVfpD7Sv1f7ZDDd+p1LZjknV1jbZQegAAAAAAAAAAGCPXQEVClw40tkhK0dJFD2rJ0hTJ2aKGllFUAJjSNTd/ldZ9zSJpQIf2tarT75Czr1fr6de7JNN8ramp0VOlfiGCJGXNV+m6Gm1fPV8mDaj9hWq9cnLk0wIAAAAAAAAAINEkfpBw+i3tbpdkKtTiz6Rr4aICmSS1731Lp0Y59NxbF7geDEmXvF/ob1XtzuNyKkVL11apdHbocWaVVmndF1Mk2VX78+aAUAIAAAAAAAAAgGtVwgcJp9qadUpSxj13KW+SZMpfplKzpJN71HhklGP/+bAkyZQzTdO9nndvpSTzMt23KD2CkdK1+IGVmiVJ7c1q6RjdvAAAAAAAAAAASBSJHSQMHVfjbrukdJXcNd/13KT5WlKcLqlXDfta5RzJuM4uvf/7nXruZbtkmq9HH3JVObgdOdLqepC/QNZJEY45b4EWmyXpuI4cHxjJrAAAAAAAAAAASDgJ3WzZ2bZPDQ5J81ao5Parz1vvXqG5e3bp1IFGHfhGgUqyjEZo1PrSRuMLzC7UUz/8ey326VXcpQ/edwUBt/03SxSznaZZsyU5pLOdnZJogAwAAAAAAAAAuPYlcEXCgA697ao4sJYUaK73S3Pu0so8STqs3QfsI7/EmWY9t3mXDn3s/aRTGnI9Mo3w3bGdZm8jAAAAAAAAAMDEkLgVCZ1vqeHAgKQFWrbE/+7+acr/0gKp/bBO7W6W7f6HDbYgKtHmhlXK8396aEBnT7Zq9/9+QQ1/atBT33Vq8wurlJcam6lb51CNAAAAAAAAAACYGBI2SDh1oEHtkqTD2lL+gLYYHejYp9+2PSjropTIB5+Uolm3LtGaTelyrq5W48eNqn2zVHml2ZKydfP8FOnYgGx/tivyLYq6dPaM69GsLK+9lqaYlCGpJ5IhhgZG1vMBAAAAAAAAAIAxkqBbG9l1qNkuKUUZ2dmaNdvgjzlF0oAOvP6WOkdymfTPaekS10Pv7YjuuKPA9aDtsGxDEY518rAOOiRpvu6Y7xVqZGXrZklShzodYcY436FTEV4OAAAAAAAAAIDxkJgVCUea9cpJSaZCPbl9lfKCblsk6cgu/e26BvW0N6j5dKFWzonN5U1/VaClphYdcOzTL39fqo1Lp4U5o1eH9jborCTlFcpnJ6YZ2Zoryabj+s/T0tI7jEdxHj8mmySZbtHN7I4EAAAAAAAAAEgACViRMKCD+/apR1LGPXcZhwiSdEehHponSXa9su949JfqP6yDLa6HPn0NUgtUsWq+TBrQoZofa/fp0MOcbajWxqZeSRZV/F2hsrxfnDRfeXdKUq8aaht11qjCYahDDXtdkzEtXqAQeQMAAAAAAAAAAOMm8YKE/j+q5eCApHSV/PX8MAdbtLDQIknqeWOfDvZHfhnn6Xe0Y0O1GhySTJ/TfX4NnWfdW6Vn7p0mOY9rxz9WamPDcXX6hwCdJ3Rg+zqt3n5cTqXIurrqSrDhLV1LHypVliTnkZ1a/d1dOnS6V073WEMDOvvnFu347lrtOCZJ81XxUIFMkX8rAAAAAAAAAACMmYTb2qizpVEHnJLMhVoSwW35c5eWKu8XL6rd2aKGlnItLvbehqhR60sbQw9gylbpU9/U0iz/F9KV99gWbZv5E639xWEd3P6kDm5PUUZ2ljImSert1FnHgOvQ1Fu0cn2VHr3TYAuk2x/Wlm91aH1Nq87+qUFPPdZgMJdbtHJjlVbODv99AwAAAAAAAAAwHhIsSOhQy77DkqS5KwtljeSUrLtU+sUX1f57qX3vWzpVXKq5YU9KUdbsOfpUfom+urJQ1oAQwS1dt614Wr8ttutA4241vnlYR850uHohpE7TrM8uUElJqZYtvkVZobZgkjRr6bf1Ut4JHXj9Vf36dyf0wZkuOT1zuV15dxfqoZIlmmuO5JsGAAAAAAAAAGB83HD58uXL8Z4EAADxsqz0gXhPAQAAAAAAYMRee/nnkqT29vaYj52XlycpEXskAAAAAAAAAACAhEGQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMAQQQIAAAAAAAAAADBEkAAAAAAAAAAAAAwRJAAAAAAAAAAAAEMECQAAAAAAAAAAwBBBAgAAAAAAAAAAMESQAAAAAAAAAAAADBEkAAAAAAAAAAAAQwQJAAAAAAAAAADAEEECAAAAAAAAAAAwRJAAAAAAAAAAAAAMESQAAAAAAAAAAABDBAkAAAAAAAAAAMBQcrwn4G9Z6QPxngIAYAzta3gt3lMAAAAAAABAFKhIAAAAAAAAAAAAhggSAAAAAAAAAACAoYTb2ogtLwAAAAAAAAAASBxUJAAAAAAAAAAAAEMECQAAAAAAAAAAwFDCbW0EAMB4Yks9AAAAAABwLXM4HGN+DSoSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgiCABAAAAAAAAAAAYIkgAAAAAAAAAAACGCBIAAAAAAAAAAIAhggQAAAAAAAAAAGCIIAEAAAAAAAAAABgiSAAAAAAAAAAAAIYIEgAAAAAAAAAAgCGCBAAAAAAAAAAAYIggAQAAAAAAAAAAGCJIAAAAAAAAAAAAhggSAAAAAAAAAACAIYIEAAAAAAAAAABgKDneEwiqo1FrV+2UTSXa3LBKeSMZY6hL7x9s1q8bm9V+vEOd/ZKUoozsObIWluqRe5fotqwIx3J2qL2xWY3/2uI1lmTKytYd+aV6cGWh8manRDbUmcNq/H8btO/t4/qgo1dOSUqdplnzP6+VX1mhks9kyzQp2JkdavhOpbYdk6yra7SlNDvkdc42PKlHth+X7n1a+x5bIElqf+EBrX89wu/ZYxSfAQAAAAAAAADgmpeYQcIo9bz7qtZt3KP33Qv+5mzNypI01KtPOk7o0Ks/06FXX9Bt939HP/zG55QVdOHe5VTTT/T0C6066/QbS059cqZD7Y071d5Yp1nF39SWygLjsYbsavxxtba1dLjCA6Uoa3a2pku61Nmhs+82a9u7zdqRXaBH1/+9Sv8iPTZvBgAAAAAAAAAAozDhgoSe9p169KlGdSpFs5aUa93qQlmzvKoFhrpke32nnnupVe//ploVJ1dp+/dLNCsgAOiV7RfPaN2eE3IqRbfd/5i+tdKvimFoQGf/UKeNzzXq/aaf6B9MT2vHYwuU4T/UUIcaNnxP244MSKm3aOV3v6mKOy0+lQfOM++o9kc/1u4/tWrb+hM69dRzWpMX2zAh77HXtO8x/2cPa1vpM2qQVLrxNa2h9AAAAAAAAAAA4GVi9UjoaNRTG10hgnX1Fr20rsQ3RJCkSdNkLf22XqpZJatJcrbv1NO/sgcM5Xz3VT2z54ScmqbS72/Xtr8LshXSpBTNyl+lbTUPyyqp8/WdajjpP9KA2nc+6QoRbizR5pee06P5loDti0yzP6dHf7pdm++dJjk71LBxpw72jvL9AAAAAAAAAABglCZQkDCgg/9cJ5tTMn3xm9oYpoeAZpdo49olMkk69fJONXZ6v2hXw/ZGdUrKWvEdrbkzTGXA7FKtvj9dkl273zzu+9rpfXq+oUuSRRXfX6XQRQbpylv9T6qYJ8nZoi2vHA91MAAAAAAAAAAAY27iBAn9f1TLgQFJ6Sr9m4LA7YWCyFiyUg/NlqTD2tfScfWFk61XKgsW6JHl8yO6vPWuEs3NXqCFObrSA8HlVEujTklSXqmWzYtgoEkWrXxwiSSp54231D4U0eUBAAAAAAAAABgTEydIOH5YByVJBcq7PdKTLMpb5CoRsB094QkAzra36qwk3fo5/aX/dkZGbn9Q23c+rXX3zpfJ82SX/v0dV0Bx218tUKRDmT77eS2UJOc7sp2O8CQAAAAAAAAAAMbAhAkSOk9fCQJutejmgMbJxrJutLgenOvSJ1eeO/vhCdeD3Fs0a1SzOq1T/+l69Kk5YbZa8maeduW6HfqkM8yxAAAAAAAAAACMoeR4TyBWLrm3AEoxhTzO0LHTOitFFhx0NGrtqp2yBX1xvtbs/KE8LRqulDn4N1eO1H9+0CHlRRFCAAAAAAAAAAAQQxOmImHUbp8zyuqDsfGpmwkRAAAAAAAAAADxM2EqEmbNu0UmHZfz2Al9MCTNirACoPNju+vBzGma7h4r5xZJJ6T/sqtTQXobZJdoS0OJ35OHta30GTX4PDdHc++QdEQ6cjKKygJHl6tHg7I13XPxdGVE0kHabXggioMBAAAAAAAAAAhu4lQkzF+gxZKkVrUfi/Qku9rf7pUkWXNv8TRJnpW7QBmSdKRVbaPqUTBNf/k5V3jw/r8dVqRDOd/9ow5Jkulzss5xP5uurJmuRx983BV2DE+fBwAAAAAAAAAARmHiBAmpn9eSpSmSetXwWktEi/Y9f2jQ7jOStEDLlnhVC9xeqIfmSdJh7W60j2pac5eUaK4ktb+qX0cScAx1qGFviyQp4567lOdVWeGqlJB6/nw6zPdnl+0d1yPrvDkhjwQAAAAAAAAAIJSJEyQoRYu/Xi6rSXL+4QU985swAcCZRj21qVk9kuZ+bZVKfPYvsqjk70qUJenUyz/Qtj/0hh5rqFftv9ilxmCvzVmmfyidJqlLuzfv1CFHqIF61b79Se04Jsm0RGsfmu/zqqdSov1V/bLdeE5XAxKLlnx2Wui5AwAAAAAAAAAQwgQKEiRll2jjUyXK0oBsP/+eHnmuUTb/W/eHuvT+73dqTeVO2ZyS6Y5VeuYrloChMvJWacvq+TKpSw3fX601Nc2ydfr1HRga0Nn2Bm1cvVrr95yQUym67cFyLfVphZCivFU/1Jo7UqSPG/XUqnXa0dYh55DvUM4zh7V701qtf71L0jSVPrVKi9P9JnV7qdbcmSKpSw0b12ljw3Gd7fcao9eu9j0/UeWVgCSjuFwlFCQAAAAAAAAAAEbhhsuXL1+O9yQCdDRq7aqdskVwqHV1jbaU+jYx7vlTg364YZfaryyym8zZmp4uaahXn/z/7N1/fFT1nej/19KQdi5GTFxGO7JBm2JgGe3oJbZRaB/ECq2I+DWsm95iLQ+XPlbr0lvcorvQVqt8q3SLt1RpV9ov7ZVec614ixQrsYZvDRZtKI4yFEaaCrMyq2NNKpHvWEjx+8ckkIQcMvlFUF/Px8PHAydnzvmccz7nfc583ufz+WQOcBCAkZTN/mfunHcBxceZmLnltw+w5K71NHU02H/gNM4sLgQO0vyff2pfFxSGP8r8W/+RWeO7t/63+8ufePreJdz9y8yR7Rd/sJj3A39uydDyVp7rOfAiP/7q7Ty4+/iTKRdXLuCeW6bkMen00UmiZ93xEF+M9ba8JEmSJEmSJOlksX9/bhiceDw+6OuOxXINxgWDvuaTwCnjZ3FXbRWppzfy4MZ64i9meGU/5Brvo1xyWRVzPjmFsuLe1gTF//Va7qu9mtRvN7NxYz1P73qZV/4zN9lx4alhYrEqpl05hRnl4eOv6H2nccmX7uXRzyRY/+h6Ht/yIv/xnxla2tdTdv5H+dSsGcw4L0zh8Rr/R53Ldd/6ETO21/PgT9fz/J4WXtl/6Eh5/mZCbj2zYr2UR5IkSZIkSZKkPJycPRIkSZIkSZIkSVKvTkSPhHfXHAmSJEmSJEmSJGlQmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkST504xUAACAASURBVJIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSoILhLkB3n5p1zXAXQZI0hB5f/9BwF0GSJEmSJEl9YI8ESZIkSZIkSZIUyESCJEmSJEmSJEkKdNINbeSQF5IkSZIkSZIknTzskSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhSoYLgLIEnScGpu/tNwF0GSJEmSJL0HlJScNtxF6Dd7JEiSJEmSJEmSpEAmEiRJkiRJkiRJUiCHNpIkvae9k7sVSpIkSZIknQj2SJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKdDJOdlyZiNfvv6H7OxlscJTw/zNhI/yqdmzmHV+98kyM6z/55u4L9mH7V7+NR6/IdpDeRKsf3Q9jz+VoKnlUO6zD5zGmedGmTGjmlmXnMUp7zvmS/3ffp77393EL9zLPbPCeS+/8wfz+PK6A8BZzP/ePVSPPc7CeZSp8NQwJWdHqf67q5kV61aOgX4/H309T4N4nHs9lgPdVj++P+uOh/hirI8blCRJkiRJkqRuTvIeCSM5JRzmzA/28F94FOzP0PSb9dy3+It8eX1mCLZ/gKZHvsGV13+D+9Y9d7RxGuCtP/HKC5v58be+zH/7wg9p3D8Emx9Kbz3Lo784AIUjKWQfDz7+4oBXeXB/hldeqOe+r97EZ76X4M0T9v1hPk9DcCwlSZIkSZIk6WRxcvZIOOIcrvvmnQS+ZP+XDI0//DZ3rH+Jnfd/k7UX9PxWfV/f1O/w5uYf8uXVCQ5yGpfMW8B1M8opHTUy98eDB0j9rp4ff+cBns5s5KvfCPOju2dx5jE9E/qx/fAM7lk/45iPX1m/hM/f/yKUX8+P/m0GZ/Z5j446uPVZNh2EUy6vouKxjWz6xeM8PfdcLvlAb988ly/+MOCcvLWPxv+5gjvWv0TLY9/kvvPu55Ypowb5+8fq93kapOOc17EctHN6nOMnSZIkSZIkSUPgJO+R0Iv3han4wgI+80GAfdT/djB7JRyg8ZebOQhM/Ic7+erV0aON0wCFoyiNzeKryxdQUQgka1m7fRA3P6T+xKaNm4GRTKusYcq0kXBwM+s3/2lgq/3AWVR84Wvc8vGRwCE2/fK5vvVK6Nf3h/s8DdGxlCRJkiRJkqSTxDs7kQDAWXx4Uu5fTenBTCTs4/c7cv/68LjjvP5dPIUrPw4UFvLKH98hjccvN7A2DhRWccl5o6io/CiFQPxnDaQGvPLc+gDYnuT3Q/79YT5PQ3osJUmSJEmSJGn4vfMTCQeepf6p3D8rJpwziCs+mqB4fsdLx12y4ksP8fja1dzxye4TPp+cUr+pJwWc8umpxN4HhRd9ilmnAnsfYePvBnFDHyjk/UP+/eE9TyfsWEqSJEmSJEnSMHnnJhL+cohX/rCZ+/51BZsOAn89g+rK3sfTz98oKq6aQTGQql3CnFu+z/rfvMQrbw3iJobDX15k49p9wChmTD0399n7zmXKJ0cBB1j/+LMcHNAGDtC45dncP2PnUjbk3x/G8zTkx1KSJEmSJEmSht9JPtnyi9x3/TXc18tSheNn8dV/vZZYwETBO++/iU/d39u2ZnDX+uuJdfrklNj13LPwT9x677O88rt67vtdfW57p4b529gULvnohXzkonMp7WWC4v5ufygc/M3jrN8PjLuaGeVHP5942dWUPvIAqU0b2TTvo8wo7se6My+ycfUKVm0+BJzGrBkXUngCvj9Y56mvhvJYBsvvmuDyr/H4DdHB3LAkSZIkSZKk96iTPJEwklPCxZzyvqOfvPl6hjcPApzGJfM+x5yLPsrEsSODVjBgZ067mR9dkiG+cSNrNzXw/O4/cXB/hvhTjxB/6hFgJGf+12r++8KriZ06ZMUYJIdo3JJ7S37ijI9S2vlPY6dSHXuAe+IJ1m7ax4yrzwpYRz4N2SOZOO/rzD+/p/My0O/37MSfp8E4lpIkSZIkSZJ08jvJEwnncN0372RW5zl0/5Jh03eWcPemP/H0+meZUjmFib2sZeIX7uWeWceZiLc3hWFis64lNuta+Msh3vzPl2h87lnqN9bz/N4DvPLbWm6dt40v3nsnsz44BNsfLC0NrN90CIjyqSndy3MaF30iCvEEqbX17Jx9LRPf19NKghUWh/nb86qYcc0Mpo3r+zBTA/3+QM9TnwzxsQx2Ll/8YbdrQpIkSZIkSZKG0EmeSOjB+8JM+9KdvPnql7nvd89y97/+kOJ7ryc2mNMjHHf7Izll7LlMG3su02ZdC5nnuG/pv7H+Dy+y6t83M+W2KQzqSDaDKLVpPXEAEtzzuWu4J2jB/Y/z6G9qmFjZU4+AgTZkn6CG8CE+T4NzLCVJkiRJkiTp5PfOnGz5fWFm3fw5JhYCf9zI11Y+y5uDvIlXHvsmn/m7a7jy/sTxFwxfwBcXVnMmcPC3SfYOcjkGzz4a6/eRGy4qzJkfDPjv1JHAITY91kDLcBc5D8Nznt6dx1KSJEmSJEmSevLO65HQITyDWz7XwOd/8CIHn/o+q6qifPm/Dl63hJJTR9HyFvCr59h5ffT4Q9OERlEMvDJoWx8Cv6vnwb1AYRVL7r+eWND+/O4B5tyynjfj66l/uYrqsSeykH03LOfpXXosJUmSJEmSJKkn78weCe3OvOIGrhsHcICN9z7Czr8M3roLJ3+UaYXA/se5/6cvHbfHwytbGtgJUD6WMwevCIPoEE8//jhvAqd8empwwzfA31bxmXEA+3jw8RdPTPEG4MSfp3fvsZQkSZIkSZKknryjEwm87yyqvzAjN9b9H9dzz0/3Dd66P/BRrvv8uRRyiJ0/uYX/tvABNv0hw8GOZMVfDvHmywnW33sLX/jBi8BpzPpc1cmZSHhrG5ufPgSMYsbF5/ay8FlUVJ0FwJu/eJyn3xry0g3MiT5P7+ZjKUmSJEmSJEk9eOcObdSu8Pwabvp4PXc8dYjUT7/H+qpjJ/Ldef9NfOr+fNY2g7vWX0+s/f/OnPUv3HPo23x5dYKDu9dz95fWBxQizCU3fY0vnt/zhLr93f5gadm8kU0HgVOrmPK3vS9fOm0WsdXfJ35wM+s3f45LPnnaIJdocA3WecrH8B/LF7nv+mu4L59FL/8aj98QHeD2JEmSJEmSJL3XvbN7JAAwikv+4QYqCoGDL7Lqx4M58fIoyq7+Go/+z7u55XNTiH3wNAqP/G0kp4SjTPvcAu5ffS9fnRY+znqGU4bNj+cmIi6trmJiPl8pnsqsj+f+Gf9ZA6khK9tgOVHn6b1wLCVJkiRJkiSpq796++233x7uQkiSJEmSJEmSpL7bv38/APF4fNDXHYvlxs95F/RIkCRJkiRJkiRJQ8VEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgIVDHcBuvvUrGuGuwiSpCH0+PqHhrsIkiRJkiRJ6gN7JEiSJEmSJEmSpEAmEiRJkiRJkiRJUqCTbmgjh7yQJEmSJEmSJOnkYY8ESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgf7q7bfffnu4CyFJkiRJkiRJkvpu//79Q74NeyRIkiRJkiRJkqRA77vttttuG+5CSJI0XJY/maHyQ6OGaettNG97iIY/RSkbM0xFGGyv1bP8jn9n3atn8snzw7nPdqzh1uX/ixf+6vxhPNb0syxttO5+mv/z07Ws/dk6Hq/7Jb/85S/5f599gV3NBZx11lkUvb/z8hnqv30H//7oK5z5yfMJD1KxM08u54771/HLX/6yx/9y5QlR9uEzCZ2A10QSP7mV5f/rBUZ8pJJz+ntKW5uo/0WSURP+ho5VDMp6j6etmfjDDbwxqYy/HoLVD1gf6+eQHy+9gwws9rwj61IPMSR/QxOrB6rn89DDs0JP91oNmiG9Hvpw7objumxtqufxF0cxYew7JRAMspPpmVWS+ujPf/7zkG/DHgmSJA2T5k0rWfZQnMzh4S6JepYl8dDdLP3hBuJ7MmRHFFE0uoii0SFozZB6Zi0rvrmMtcnsiStSYUcZOv/XUZ5aln1zDYkTWJz+S1L7zVXUNZ3IwjZTv3IZtdsyHDqBW5U0FIYjhgwPnxV0wuysZemqOpoODHdBJEknq4LhLoAkSe9VbYfbhrsIJ8akudx113AXoh+Sj7F2WyuMKqf6xmupOL3TY9PhNtK/Xs2qnzfR+NBjxBZXU3YCXs8If2I+Cy/t4Q3GtjR1K1dQn07w2KY00csjQ1+YATlE2wlvFGvDDILevcJU3XwXVf38dvSzd/HOCtPDEUOGXk/n4T3zrKDhZ12TJPXCHgmSJEk9SD7fSBaIXjmvaxIBYEQBkSlzubwMyO5i18vDUcJOCiJMv2oqRUDzzl1khrk4kiRJkqR3F3skSJJ0RBvpJ1ay4sk0BWOns+DGKsL9SLm3vR5nw0/raEw1596YLAgRHhuj6u9mEju9gNzYzMupey23fOKBW7kViF57F3Mntf+N6dxYneXn/08DqYMFhMZWMvcLMykrJDfO+89rqduWovkgMKKAktIKph9Zf9d9at62gdpNcdKvZWmjp/K0l+Mnt7Jme5S5//fltD1ay4atKVrboGBUhAuunEv1R0rI7mlg7f/ZSOLVNhhRQHjSTGr+vpLI8Z4odqzh1gcShC9b2P42/dF9XPilCTT974ep25km276tCdOuonpKKaHejmthCaUXTqfmihglx2w/S2rzWn62aRfpA21QUETp5JnUnJP/eSwoCAFZDh1qo+dHphAV8++i4ngreaOBFd/cQHrMdBbeXHXMONxt21az5KEkkSsWs2BKUf6F60koRAhofbOFVji6rdYmGh7dwFPJNK0Hcx8VFEWY8ImZzL64jKJudTybbqTu0U1HjnPunPS8bNed6egVUUBkxgIWTAsY+7m9PgDwWh3Lb62D9uNzxOFWmp58mLW/SubqeMe5vjJGSfcy5LN/r9Wz/Nt17QmWBGtuvRWIMveuuUQDdmcwr4e+1d0eZFM0PPIz6juuk9GlVFxew7ielm0/Hh3LMqKAosgEPv7p2Uwt672O5fY7zPSbF1I1ppe/tR9XLlvIgolN1D5Sx66Xs7RRQGjsBKquqGbq2d2vZGjeWc9jTza0LwsFxaVUXFbDzAtLul5prWkaNz5M3Qvt5zYo1nUqxw1lyS7npGR8FTU1VZS+v5l45/M4upTKq65l5sSjx6TLOX9kDevi7ce7KMIFn57L7C7lyyNW51v+9msieu1dXN62jtrHGkm90QYFISKx2cy9OkbJn1M0PPIwG3dkctflGVFm/n0NlUcqW8d9pVu9zrM+HHve+xOnu8fd9vJPbeZH99SROW8ud3026Iprd7iVpl+vY0PHOujheg6KIf8wktq8421wEVqbGlj3i/qj9TPfGEgTa29fRSMVzP96NWVHt0zj6iWsTULRlBtZfEVpp41tYeXSdaTaj03X83CcZ4VOO9f2epx1D67juTyuve76dL2fiHt391hXXE7V39cQbfoey5/g2LJ0r+8c/2+5c/sUu9KtubL0MT727fkLmp9fR+3jjaRaOu4RM5hzSe+b6VW+9/UusWUtax59LnddFRYROX8mc686eg5y5zv378wTy7n1CTo9t9HPeJyg9n/Xk2zJxYNw2VRmz6kin0MNHDne9dvTZDriwagwkfOqutWfwYhXfX9OlKT3IhMJkiQBg5VE4NV6Vn6njvSIEJHxMcKjoK25iV17tlD77b00f3kBVWNCnBWNUZ5MkkxnKTk7RmkJjBvdaT0Ht1J7fzOHxkaJFe0nNeIsxhUC2QRr/m0NiQO5hrBotISCA2kSu7dQ++0Euz67kJpJHT+VsiR+sow127NQGKb8wnJCtNHctIvUni3Ufnsf2VtupLLzdslQf+8y0pkiSstjlLWlSexO0/jgD2BfhMRTuyg4ewKxCw+RTiTJbF/HirYQd14X6/tDxeE0dSvrSPyxhNLyGCXt20r8fCWZPy/sMoRPdscalj2QIEsBRWdHKSspILsvQfKZWpbt2MXchTVEj/xC7L7fEUIH0iR+U8uy3+RfvLLzooR+00jyZytYe3gO0y8spaivOzk6RsXZG1i3ZyuN6SpmdhlxqI3nnk8C5VReNMAkAtD2H3tzDeVnRI42oL1az4rv1JE+nDtusZICONBxnFfRlJnP168+2tx17HGG5t2J3LJ757Los9FjGolyG88ziQAwuozYhftJbUvRHIpQPjFMaPRZndbbypYf3E3dAQiPjxEblSX9QjI3B0TLIb4+r+Losvnu3wfOInphObt2JklnSyi9sJQSxlHS61Ed+PXQt7rbg87X/BnlxM4Kkd2XYMuDy9jSPUZlE6z5H2tIZAsoKY1SfuR4JNiwqol91y2mZuLgP/63petY+WSCzOhSJlxYwqF9CZIvJ9jw/QyHujVQZp5cwfIn0rlGtfIYkfbzu+WhZextWciCjuv+1XpWfLeOdFsu0RCNlkBHLP1WnMS1i5g7qVuz0I5alj2R5tAZ5cQuHJmLdck6VtZmmdraQMMfw5SfH2NkcxO79qRo+PH3YMGibtdllviD3yWx4xDh8THKC5ppSqZofGgZTan5LLyqrGusC4rV/Sh/5skVLEtnKDp7ArGyXJ1Kb63lB+wjsrOBXQWlTIjFcsf31QTr7n2A0G3ziBUGnJjBqA95x+lOcbegiNJJZbllt9WybGeo57hxbIFJPLicNduzuWNWXkIBWdKJZO56Ts9j8TXlFATFkNGRPsTbnudWOLZ+5u6ZiZ+vYle8t2eDMso/DI3bd7ErBWVH8gV7SaVy/2p9eR+tlNIR8duSu0gB5RMn9LC+PJ4V/rCOu7/dSrYod+3xxyYSqQQbvp9m/42LmFnaw2oHaqju3Z1j3ZhyYn8TIvsfCeq+v4xEpADyrEVBjpzbgiJKJ8YoeT+5srycux4y13+d6vHHWUGfnr+6bW9SGSU007RzAyt3DGg3+nxfB8jG1/Dd7YlcbCxvj41ba1n20l7mf2k2ZYVQUhYj1poivqeZUKSc8jNDlERCR7fZx3jWlq5j1ZMJMkWlRDvuC8k6Vv2PJmb/43wquyWujnu8zygnVh6CP+ficeqZWpa9kmXxP1bS5empP/FqAM+JkvReZCJBkiQg82QuiRAqm80N11f2L4kAJH9VR/pwCVP/sesP+OzW1Sx9NM2uRIaqaWHKZ9RQXLCcZDpLZGoNNZO6reiNZuj+5iJZGmvXkDgQovSKG7hxSqfG2pZGVt+7lvjDa4mOn0u0EEjX89j2LESms/Cmro0fqZ8vY+XmFI3bmqmc1rk5NUM6W8H8xdWUtf8mzP5mFbc/0kTjU1mi1y4++mNxTpK1d6ymcWeCxOEYsb4es9cTJCLTWXhbp7K9Wsfye+rJbG6g6dL2NzqzjdT+JEE2VMrMf7yRqWccXUXz1tV89+E4ax+JMuGzUQqAth1rWdvTfnf8+M63fOOrueHK5tw8CI+spPGR3Bt/ZePL+PAFFzD5nAihXp+kiqi4qJx1e5LsiKeZGenUstXaSGMSmHgBFwQ1BOajLUs6WcfDjyQBKJ8ca/9h3Ub88TrSh0NEu//Izzay+o61JLc2kry6jHKAg/HccR4RoeqmG5ne8abz4Qz19y6nbvtaHktGqS7vtv3DGepXrqA+HaLsyhuYf/FxkggAYyupuaaINdvW0HxKlJnXdH9zOEvr4Sg1/zKXWEcLwaw4a5bVkkg2Em+toLKoj/tXVM70a4op+HaSdDbCx6+pCeyJ0NUAr4c+1t1jtZF4ZC2JAxC5rFMjO50aqTppfqaexAEon7OYeZM7HY/UBpbdv5Wm7btomxi0rf5r3pEgctlC7uxcvieWs/zJDA0NTVR1NGqlN/CjJ9IwKkrNf+98ftsbjJ6opWHyAqaOzlC/po50W4jyOf/EvMlHY1Rbuo6V99aT+MlqtnRLhLam05ResYgbp7QvfzjFurtXsiXZQEO3WNO6eQVLf55mx44MMyOda2ATiT+UU/2VeVQUt3/U0aD1zFo2XtQt8dBjrO5f+TPpt6i4fjHV49vP3axGVt2+lqatDWTPm8viTom85MO3s3prksROiH0k4LwMRn3IN04nH2uPu1UsuHH60V45LY2sXrGW5PG2cWRbW6jfnoXyahZ3ThjOSbHhW/eztek5drWVEz1ODBlQvE2118/iCuYtqKa8U3I69fNVrNxcx5pN0Z7nqWkXjUVhe4Lk7gwzS9uXS+1iV5bcoMJ7mmg6XNl+v2zjue255EY02tNZKAp+VmjvpcCBVoouXcAtl0WOnMeOa2/r1iZmlpb1sN4BGpJ7d6dYd+kCbjyyP0df8hhQIuFgnA1P5mLP3H+e2yV5m926mtsfTtL4XJLq8d1vcEeW6tvz12v1rHmih+11ahzvnz7e19s1bW+ifM6iTrGooyF9C2t/WcGiyyNEPlZDTdEa4nuaKZo0k5oj9bx/8ax5R4JIe2zsKGXuvtXEusfiVPTyAkp602M93vs4nGLDt1bSsKeRxtcrqTq905fyrJuD9pwoSe9BzpEgSXrP62iQG2gSAeDQIYAsLX9s7fJ5aPI87vzGYm483pvaXRQx6fxurxK2xnMNIWOruHZKt/UUVzDz4jBkEzS+kOv+3bwnzaHCAqKXHvsGZek5uQaWniZxLJ06/UijKUDonLJcI83plUzv/KN1RDllHwLI0Px6nrvVRYiKT3cr2xkxYmOAbPbI+6KtzzWSPAyRS6/t0hABUDJ5JlPHQHZ7I8+1d+/fFU+QpYipV3VfdxVzpvT+Dnpn4Yvns/i2hcy9LEbpmBC0pklua2DDD1dw+5IlLF1dT6rnF1uPKIheQPkIaH7+OVKdPm99vpEUISo+ln9vjswTy7n11lu7/rfkdlY8sIV0GxRdOJeaIw2GTexNhygYM7XreQMIjWPc6cDhtiPzD7du/TXJw1AyZc7RJALAiDBVMyoIFRbwarrb7AsdSYZ8kwh5Kv90zdFGZoBQjNiHAd4i+1bHh33bv/4ayPXQ17p7jMO7iO/IwuipXNWt8TJ86RymFnddvON6bnm9hS5XdulMFt35dRZfM/hJBABCFczsXr5YjDCQzR69QJqe2UozUD6z+/mNMntahIJRrexLtUGqkS2vAWOrmDO56zVbEJmeu44Pp9iytVt9DFUwo/M1PqL0yFvh0U90jQdF4ydQAjRnjp1RJDJtztEkQnv5amaWA81sfaap29I9xOr+lv/sqUwf37myjaNsDEAJlZ/s2huofHyugTjzx+AZUQanPuQTp9uIP9PYHnendx3aq7iCOZfmOfn7YXLlbG6hpXOBR5Qy85Y7+fq/1NBje3snA4m3TVu30kyIiqs6JxEAQpReXkV0BGR+09hlvccYX045kNndRMdTQOvLe2mllOmXlgNNNHVUocO7SO4GyqP9TyaPnspVnZII0PO1N7iG4N7dEetCFcy4tPP+FBC57NhY12cv7SUdKiB88fRjeoCFxo3LxfRDx7lb9PH5K/NCnAy5e1mX7R2JJf3Vz/veMbEoRPTvZueulcYtdI9q9IeTSgAAIABJREFUXQwkHl/edTihI/etnb+msetjcjfN7P3PQxQURKnq/tw8opRxYwHa4JgJ1/Orm4P5nChJ7zX2SJAkvae1PrOKFa25XzNjJkUHlEQAmHBhjND2OImHlrJkQ5jI2eWc97F8317vbBxnje32Uaop14BxYDsbHtp37Feacz9gU6m9MLmMkovns/higDayrVlaXmki8+o+du1uItkU/L5VSXHAMDuRyDFjThcM6HiNIXJm70vtfSnXbPNWYgO1PRQ7t9spUnuhYnyGdBpgHON6GNIhMr6M0FPNfStmYZjopTVELwUOt5F9ZS9b40/R+EySTLKOlf+WPuYNx67fj3HxhetIbt1K4+6ZlI4HyND4bBpCFcT60qZQWERR9+0UFjOubALRyRXExnY+d+XM/pevMxvgYJbW1tdIv/wq+15Ksiu5i1RL19WkX84d544kUxfl1Xz9G90/bGXLD1bQ2gqMGEN00uAkESDEqaODLpYMmT8CY6Cv+9dfA7ke+lZ3e9jGa2nSh4HScRxbnSNMGB+iodMwDOHzY0SerCO9aQVLni4ick6U6IUXEJtYSslAer305oxjj8Wxmtn7chaIMG7csee3aMoC7mwft75tayY3z8fEcno6+pHoJIqeaiDzSgY6b7m4mJ7bG8NEulfrEQUBP4TCRMuP3WrB+AmUkiT18l6aKes0LNaxsbot08/yl5T0uDxEiHRriM3nV9zg1Id84vRemvZAUNzNJW3S9Bp5x0SJReqoS9ez4mtPURQpIzrxAi64MEppcZ430H7H2wx7X8oCIfY9U0vt893/nqX5/cAbe9nXCqVBo9EVXkC0fC3J5C52HaykorCNXckUnF5FNFZA4okkTXsyMD4MO+MkDkNp+YT+/ygvLgmo88DrGZohjyHc+moI7t2ntse6D5VRfsxzRYTzJhXRsHkARS6fzeKvzgag7UAr+19Pk3plH3uTu0juTvVeN/v4/JVO567tnmLdkVjSvx3p132vx1hUWMaEUkju2cfe16Hs9J6+OYB49uHyHs9l7r6VYu/LUDkxaD9LqLx+MZUAbVlaD7SQ+UOG9L5d/P4PSZpeDvpePnVzCJ4TJek9xESCJOk9LdvaSqgsSiSdIPXzB9gyqfucAX1TMLGGhfPDPPxwPcmWDKkdGVI7GthAAUXlVVxbU0Vpnr3zAxvpW1LEW4J/gh59CzFL6slaHtiUpLXz250FISLFJWRf6+mHUpjwX+dXvoE7laI+TA3QvCdO856gv2bJHgTIkDle74jTigMa6vI0ooBQpIypkTKmfqqV+IPLqd2e4LFNaaKXB791W/6RKKGtjSSebx86Id3I1teg5OOV9GXgifAn5h93WI1jtMRZ+6OHaXy1a8+TguIwJaEMzZ1eWM29jNmX85+ltTVE2aQI6R0p1j24hWj38Yr7pYji04L/2tb5DcQ+7F//DM71kF/d7cEfM8dt4Coa3e1oj6nixptL2idebSWd3EI6uYU6oOCMCuZ8vprYQN/s7bEgRXmc9zZyr8mWEA5osOrQ/EYvWaCOicW7f356eBAaTcOEexq7u6iIUwEOQfd+XN1jdX/LHz59kE/OoNSHfOJ0lmwWKA44/oFJm+7CVN24iJKf5Sa6bn05yZaXk2x5AigMU1H9eao/0vsZHli8zZLeGT/O0CbtvaICj0kBE8pLIZkkuRsqJjXRtBtCk8sInz6SstF1NDQ10XpZmEyyCSjlgvMGEDWPd+31UFcHxxDcuzti3Yiea8oHQgObHwGg+fm1/GhtI5nO8XZEASVjSgi92hwwa0Y3eT1/ZWgO7ih0NJb0Vz/ue+Eze3puKGo/jz292X9Uv+NZj9vsuG9lu97Le5JNUV/7APXJ1i71uGBUhJLiLJkei5VP3Rzi50RJepczkSBJek8LlVfzT9dVENqWGyN3MBpDi8qqmHdLFRxsJtW0g+1btxNPpmhN1rHyx6FjJ4fr6/qPGY+7Z5lNq1j5RBpOjzL9E5VMmBim+P1FhAqBHWu49YF30htXRUy9cXEeE0eGc42UQT8S27u299ok8foWVn5nHalzqrlzXkXPD0wjioh9spK67fU0tzQDxxm+Y3wlk4sbadiRIHl1OUXxHTQTZnpFnkN+9MfBJLX31hI/ECLysRnMuHASkeIQoaIQBWSo//Zy6jo1OIwcCV3f+O9NiPKr/4l5F4VoXH07a5PreODXUW68+AT9BO/j/g2ffOtuD/461zAbdKW+lT22NhecHqP6phjVbVnSLyXYtSNBfFuSzKuN1N4LRYurKRuWwU0LYCRAc64R5zjJhJLRxcBxWuI6DVEx+ALK1/52N6N6nzh4eMvf1YmpDyFCIaAld4wGFNUKSojNWUBsThvZ9F4SOxMkXmgk+WqGxge/C/+llwlxYYDxtpzqb8yjYgA9eIomnUfk0VTujfyi39N0GMrKcymMcaXQsKOJvYfDJLdnYex5RN/VrZZ5xr/XIoRJkOlhuEUADrcxkKaLtp21fPfBONlRESqnz+CCiRGK/0uIolABvFbP8m/X5XVN5vv8VRLm6DwW3R3M9n/IvX7e95ozzTCpexKuPdbxAUIfCN5kf+NZ5vUW6KGvWsvrGSCUexYNlKF+1Urq0lAyaTrTPjaBCWcWExoVomAEJH5yK2v63etwkJ4TJek9yjkSJEnvaUWl4ygZAaHJc5h9NrBnHQ/8+rgDtx5HE+vuXsqSuzfkuqwXllA6cSozr72Rxd+YR0UI2NPE3v4WNpwbPqR1x/Ye35ZMP7aMW7+2lNXPNAMZEtvSQISZX5hL1UVlRIqKjvxwy3VBf2fIvdXWyo5Ej3vNhrtvZcnS1WxpgaNDmDSR7GF2z9ZU07FvMfekuIhT24BkA/WvHme5P7XmfkDnWuGPI8IF55VANkFid4rnnm+GsRVU5NVg30+7G4kfgNDkGhZcNZXy0hKKikK5ppjDGdLdfkRHxuYaR9Ld50EAeKOBFf+6hKUPNHZqMChi3DklQIiKq2dTOoJcr543hmyPuurj/g2HvtXdHoyJEBkB/D5J8pi3N1vZu6dzbW5my+ql3L5kNY0HyfU8Gl9B1VXzWPiNxcwcCxzYy968jkv7G+ZdpNjbv7E42pUwbmwISJN+pYc/J9dy+5LbWb4xRUE4TBGQ2Zns8XpNJ3bkhtoIeON1YNLs3XtsY2bb3r2kgaKxZ/WaCB7e8ncYzPrQm3GUlgLs7bGOtCYTx2uGPFriZ1az9I4lrN6aazQORcqouHQ28758J4uviABZ9qbyWVN/4m2Y8JkASRKJHhqzD8ZZ/a9LuP3udccfTx5gdDnRMdCa/D2J3UlaOTpXx4TycjjcRHJTbgLmoOFiTqyhuN77GP9OD+eGlvxDU4+xLpkMSqceOrZH18G97O3WiL9rW5wsISquWcDsKeWUnl6USyIAZNK9188+PX9BJBIGMiSSPUSAl1L9HNaIft/30qnUsb1TDqbY+wowehxnHacS9juevfT7Ho5Vmt+/BFBK6bjgbfJagngaGDuTG66tomJ8JLefIwAyZHq6h+RtkJ4TJek9ykSCJEkAFFFZPZ3IgBpDxzHuzFbaWrby1LZuP0MO7Gf/n4Hi4iNDPxS0d+E/lM1z8IExFVSeDbQ08PAT6a4/Cl+t5+HNzdBWzISJnd86a6W5WyNlW7qO2iffQYmEyZWUjoDmzQ9Tl+56rDJPPkxDC7SdPoFo+xAd0YsqCJGlceOGrhMhtzTy8KbgASu6GBHl4xeXABnq719F/e7mbt3w22jdXc+qhxpzjRMX9D7RQeSSSiJkSWz6Ock3oPziwRgGqHfZlv1d3xY83Er8wbUkujXWFF1QQfkIyDxZ2y15kiXx83rSh9soLpvQ81t6oyuZc1kEDueGOOr9R/jIXIPAwSxv9brs8eW7f0ffiO+h4WmI9LXuHmNElMrJIcg2svGxVJf9bN76MPVdxokuYdwZI8m2JWnY1C0+tLXQfAAYUUxJL0O3HWn8e6FrU1fzb55k6wCTRGWTJ1MCJB5ZQ6LzzhzOUL+xkWwbjPtQKZRWUDkGeLmeh7d2bUBsS9flYt2IUionD01DfHJDbdfytcap3ZAEwlR+NI+uJcNc/pzBqQ/5KeCCi6KEaKXhZ3V0qeqtcdblGXdLSsOMPNBG8lf1XddBGy3NuUhRXNxxfzt+DOlPvM3dO3LnP94liGVJ/HQdycNtMD6ax/BI4dx9+LWtPLY1A2MmUNa+8YJx4wiT5blNW2ilhPKJvdeBPj8r9MFQXu99in8d99xsI+seSXaJda3Pr+sW66BL4ueFzktnST3eQA/tw0CW5je6ZUxa46x5JNH7zvTx+atj39ObHqax8zNYNsWGjY0D7pGU/32v3c511O7Idl3+p+tIHobwRRVH5+Bpr2vZbKerqr/xrKWBh7s8a7aRfiJ33kPnVeQ3wXhrMy3dnr3ST9RSF9TbI0+D8pwoSe9RDm0kSVKHMVXUXJZg+cZu473vWMOtDyRgzHQW3lx1nElFC4hdPp2nknW5yZZ/VU70rBAcyJBsSpM9HCJ6RdWRYR9KzgwDaZK/WMmaP4Qpu7iGyu4TLHdRROVnati1opbkkyu4bWspE8pKKDiQJrE7Q9vhAiIz5rTP8RAmemGEuo1ptty/hKbxUSKjILsvQfLVNkKnlxB6vfnYyfFORqMruXbOLpY/lKR+xW00nj2BspKCI/tCQYTp/1enRqLxs5n7sSZWPdPAyqVxSsvLKGlrP0ahEKE8f8KXXv4PVLd8j7U7mqj74TLqRhRQ1D7TcduBVnJtOgVEZtzQ+1AbAKNjVJy9gXV7UmRHlFMVHeLHsPEVxEYliDetZek3G3N15c/NNCVTtB4uoaQ4S3NLhsxr5IYyClVQ89kkyx5IUPedJcTHR4mMaqO5aRepN9ooGDudOR8LbooLT6th+vbl1O3JZ4ijMblGoHQDtT9spXTsBcyc0ZdZp/uxf5Rw1plAOslj96+hKVzGx6+pHNgwLL3pa93tQdkVc6lsWsWWzStZuj13zR/quI5HheDA0WUjn5xN7LeriW9awW3bSo8ck9TuFM0HIXLZTGK9NN6EJ1dS+uQ6UptXsmR3OdGzRtL80i5Sb4QoO7ukfVLdfiqdyecva2L5EwnWLF2auzbfnyWdSJI5CEUXVnP5eIAwVXOnk/huHcmHl7HkyVImnFMCzU3s2tNKGyHKrpwzoPlsgoUI0al8bZ3j61yq8upFNJzlP2ow6kO+CiZVU31eE2u217PiG3FKx5ceOXYjQyHIJ+5GZjD7wq2s3lbPitsa2+tHW67+tbRBZDozYx1xs+cYcuRa6k+8HT+beR/fx8qnEtR+cwn13WIgRTGqP53frDYdE9A2t0DRlA8fvcuOGce4EGSybTB6EuflEYB6fFZ4f17F6NWQXu99jH+ll3+e6X9YTt3W1Szd3TnWjSQ0ii6xDtobg7c3knx4KUu3TqCs5BCZZBPpP4+jbGymy4S8Ey6MEdoep+mRpSzdlitHW8f1eHoJJQeaaX4lQ/ATUV+ev3L7PufKBN/7WZK131pCw/gokYL2+9P7c88h/Uom9Pm+lxMaBYkHlrL07Nxx6oi5BWOnM3dapz0Oh4kA6V/Xsur/K2XceTOZPrGf8WxUiJYnlrPkhfZ61fk6ujp6/IaoIxOvb2HlbU2URyOE6LhXhCg5PUTz6xnSGfIcirH7cRyc50RJei+yR4IkSZ2EP1GTayjq7xBHY6pY8JUaKs8OM/L1JPFtceK7M4TGVlJ900LmTur0Pnf5dKrPK6EgmyaxLc5zqTy2NzrGvH9ZRM3H2htptsWJJ5sZGYkyc/4tLOj0gzA8bT43XhElEoJMMk58W4LUyAlMv3YRi2++PDcu9st7jzOp5Mmj6MJ5LP5KDZVnl9D2coL4tjjJ10cSOW8m829ZQNUZnZcuoOyqhSy6ppLSoiypHXHiTa2EJ83kxmun5t8LYEQJFdcuZvFN1VSeHaYoBK1vtNL6RivZEUVEyqdS85XbuhzzXvaCiotyjeWhCy8etAa8QIXl1NyUO2a0pnJ1ZfebFE+uZsG/LOLzk3NDL+z9j6PvVoYmzWXRgmoqIiGad+fqTLotTPSK+dxyY1Vu6IlAYar+Ppdo671XTwmVV06ldFRBbjvP5Df0yUD3r/yyaqLFBWRfThDf9hx7T8D4BX2ruz0oLGP2l3PX/KnZ3H42vRkmesWNzOuerCksp+afb2TmeRFC7cvGd6TJhqNMv3YRN+YzUffoSr5wc/txfS1JfNsuXhs1gdk33cLs8QNPfoUvXcCi66ZSXtxGekec+LYkzaNKqbxmEbdcEz3a4+WMKhbcMj+3Lwdy+5J4uY2Ssyup+cpi5l88VAnQIqZev4iaWIj0zuD42qthK38ng1Ef8hYi+tlFuXvOyP3tcTdLZMo8Fl6Za3wvGt3bFLMFlF/Tvo5Qe+zeliB9MEz0srks6hKDeosh/Ym3BZRevoDF82cS7RQDU9lTKf1YDYtuqSGa78DppROY0L7suHM692Ipo/zD7SU87zzymjqlP88K+Rri671P8W9EmKqbusW6tyJMvW4hsz/Uw8rHV7Nw/kyiY0eS3ZMgHm/irTGVzLtlPpXdenkVTKzhnz5TSWkxtO7JlWPXG8VUXL2AxTd/nsljgNf3kj5eb7U+PH8BhD82P1e+yEiak3HiO9OMHFtJzU2z8+jVEqAf9z2Aoovns+iaCwilc3OkNI+M9HxfP72Sqz5eSmhEM03b4mzZ2X5V9SeefWg2C+dPp+ytpn5cR2Gq5rfHrsMZktvixF9IUVA+nblfWcyiy3NHML23v0+wg/ScKEnvQX/19ttvvz3chZAk6aS3Yw23Phlh0YIquk9XJ+WrbdtqljyUouL6PCYMlXRCJX5yK2u2h5l+88I8ex4oL8+v4dYHE0RmLGLBtBN3BzXevnt4bfZTe4/a8GULWTioicPjaJ+8OnPeXO76bPTEbFOSBMD+/fuHfBv2SJAkqTeHW4lvayJU+mGTCOq/thQbnkhC8WQqbdSS9C7S9MjtLLljORt2d/tDW5q6XyWAEsrKT+Ad1HgrSZI06JwjQZKk3rzeyFNvTGbenLwGIZC6yDy1klVPt7TPqxAidt2MoR2XX5JOsLLJkzl1awMNq5ewo3QCpSUF0DF2exuUfKyaGScg8BlvJUmSho6JBEmSejOmigU3DXch9E5VMvpUsm+kaCsoovzK+dRM9PFL0rtM6UwW3nwWG35aT/zlBPE9AAWExkaZPu1yPj6p5IT88DTeSpIkDR3nSJAkSZIkSZIk6R3KORIkSZIkSZIkSdKwMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEmSJEmSJAUykSBJkiRJkiRJkgKZSJAkSZIkSZIkSYFMJEiSJEmSJEmSpEAmEiRJkiRJkiRJUiATCZIkSZIkSZIkKZCJBEmSJEmSJEmSFMhEgiRJkiRJkiRJCmQiQZIkSZIkSZIkBTKRIEmSJEmSJEmSAplIkCRJkiRJkiRJgUwkSJIkSZIkSZKkQCYSJEmSJEmSJElSIBMJkiRJkiRJkiQpkIkESZIkSZIkSZIUyESCJEmSJEmSJEkKZCJBkiRJkiRJkiQFMpEgSZIkSZIkSZICmUiQJEmSJEmSJEmBTCRIkiRJkiRJkqRAJhIkSZIkSZIkSVIgEwmSJEmSJEmSJCmQiQRJkiRJkiRJkhTIRIIkSZIkSZIkSQpkIkGSJEn/f/v2D6pVHQZw/BHMJYjbIkGES/RnCqFwvi22SFsIDRKC0B8IJCKhIaKhIjJCCkIRh6Cp5ULQUhAuERFFELlFSzhdXmhJ4m1q8Oq37pUub3g/n/Gc33vOc971ywMAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAAKT9qx4AAFZpc3Nz1SMAAAAAe8Da2tqqR7hlNhIAAAAAAIAkJAAAAAAAAGnfcrlcrnoIAAAAAABg5xaLxa6/w0YCAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAACo5yOjAAAGRklEQVQAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgLR/1QMAwCptbm6uegQAAABgD1hbW1v1CLfMRgIAAAAAAJCEBAAAAAAAIO1bLpfLVQ8BAAAAAADs3GKx2PV32EgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAAkpAAAAAAAAAkIQEAAAAAAEhCAgAAAAAAkIQEAAAAAAAgCQkAAAAAAEASEgAAAAAAgCQkAAAAAAAASUgAAAAAAACSkAAAAAAAACQhAQAAAAAASEICAAAAAACQhAQAAAAAACAJCQAAAAAAQBISAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIAkJAAAAAABAEhIAAAAAAIAkJAAAAAAAAElIAAAAAAAA0v5VDwAAAAAAAPz3Tpw4se2zly5dyns2EgAAAAAA4Db0T3FgJ+eEBAAAAAAAuE39WyTYTmwQEgAAAAAA4DZWsWC7GwtCAgAAAAAA3Oa2RoPtRoQZIQEAAAAAAPaEv+PBTiLCzMy+5XK53I2BAAAAAACA3bVYLHb9HTYSAAAAAACAJCQAAAAAAABJSAAAAAAAAJKQAAAAAAAAJCEBAAAAAABIQgIAAAAAAJCEBAAAAAAAIO1f9QAA8P9zdTZeemE++Hnnv3z41Ll599jBmZn5bePVeeajK9cfePDkXHzn6NyzrTE+n9MnL8xP1118YJ678MYcOzjzx+X358m3Lm/50eF5+eMzs37XzR/5/YdPzyufXbvpTHOzebfjum/ayX93x9x58O65/6HH5+hTR2f90J0zszlfvvb8vP3tlhkPHJ6Xz5+Z9btvfMpPF0/N6U83t1y9d06cOzvHD/04Hxx7fTauu3d03tw4OY9s9/sAAABgj7ORAMCe9sxbX8yvf656iltz4NEjs35g69Xv5psfrt3s+MxcmW8u33jvkSeObC9s/Oeuze9Xr873X30yb79wak5vXJ2ZtVl/8dl5bOt3/fHdvHf+6/l96yN++XTO3hARZu57+qU5fmiXxgYAAIA95i++FWzpFOdadwAAAABJRU5ErkJggg=="},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js:35:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:02:41.614Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js:35:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js:35:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:02:17.979Z","_duration":23635,"uid":"test-00-0","cid":"0-4","title":"TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","fullTitle":"UserStory: Logout.TestCase_13: (TestCase_2 modified) should be able to add one item to cart, logout at checkoutStep2 page, log back in and check it out successfully","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e2314407-4ce9-4cf9-a151-bb645f18b732"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/value","body":{"text":"performance_glitch_user"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/e2314407-4ce9-4cf9-a151-bb645f18b732/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fd4fcc63-a967-478f-bb64-ce4bbcc61ca0"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/value","body":{"text":"secret_sauce"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fd4fcc63-a967-478f-bb64-ce4bbcc61ca0/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f7afa6a9-cefc-4fea-97a7-9b2dbb845b49"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/f7afa6a9-cefc-4fea-97a7-9b2dbb845b49/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/f7afa6a9-cefc-4fea-97a7-9b2dbb845b49/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"e4686a75-78dc-4644-9638-473acb7b813e"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/e4686a75-78dc-4644-9638-473acb7b813e/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/e4686a75-78dc-4644-9638-473acb7b813e/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"af42cb0d-b2ad-4909-904f-f36077ffdab2"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/af42cb0d-b2ad-4909-904f-f36077ffdab2/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/af42cb0d-b2ad-4909-904f-f36077ffdab2/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6df53d3c-3ef7-40d5-b4fa-189f72654922"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"6df53d3c-3ef7-40d5-b4fa-189f72654922"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/6df53d3c-3ef7-40d5-b4fa-189f72654922/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/6df53d3c-3ef7-40d5-b4fa-189f72654922/text","body":{},"result":{"value":"1"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"6df53d3c-3ef7-40d5-b4fa-189f72654922"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"42ad95dc-c263-4163-ab29-ae264416435b"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/42ad95dc-c263-4163-ab29-ae264416435b/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/42ad95dc-c263-4163-ab29-ae264416435b/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#checkout"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"8dffb402-d1ce-45f7-adf9-03f66b9b1222"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/8dffb402-d1ce-45f7-adf9-03f66b9b1222/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/8dffb402-d1ce-45f7-adf9-03f66b9b1222/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-one.html"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d7672ed2-3e6b-461a-8e5c-f31d06e9b8d9"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d7672ed2-3e6b-461a-8e5c-f31d06e9b8d9/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d7672ed2-3e6b-461a-8e5c-f31d06e9b8d9/text","body":{},"result":{"value":"CHECKOUT: YOUR INFORMATION"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d/text","body":{},"result":{"value":"1"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05a6c454-e6a2-4c08-ab7d-1820a2e496bd"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"21fd9119-9f99-475e-b730-f3092aae06d0"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"18496f3d-8ace-461a-9198-d65185f3d872"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"firstName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"05a6c454-e6a2-4c08-ab7d-1820a2e496bd"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/value","body":{"text":"Jane"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/05a6c454-e6a2-4c08-ab7d-1820a2e496bd/value","body":{"text":"Jane"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"lastName\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"21fd9119-9f99-475e-b730-f3092aae06d0"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/value","body":{"text":"Doe"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/21fd9119-9f99-475e-b730-f3092aae06d0/value","body":{"text":"Doe"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[data-test=\"postalCode\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"18496f3d-8ace-461a-9198-d65185f3d872"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/clear","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/clear","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/value","body":{"text":"90210"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"9a3e1f92-796b-4d24-8ab0-058fe3d8fc5d"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/18496f3d-8ace-461a-9198-d65185f3d872/value","body":{"text":"90210"},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"input[type=\"submit\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0e793621-0f9a-4c05-a8f5-cd23e2faea25"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0e793621-0f9a-4c05-a8f5-cd23e2faea25/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0e793621-0f9a-4c05-a8f5-cd23e2faea25/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/checkout-step-two.html"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a75756fb-cc23-4b4e-b627-4e2c020fed39"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a75756fb-cc23-4b4e-b627-4e2c020fed39/text","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a75756fb-cc23-4b4e-b627-4e2c020fed39/text","body":{},"result":{"value":"CHECKOUT: OVERVIEW"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"77faf251-3601-43df-aee9-e8a80b456dfc"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/77faf251-3601-43df-aee9-e8a80b456dfc/click","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/77faf251-3601-43df-aee9-e8a80b456dfc/click","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#logout_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1"}},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":true},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"648d9733-ac0b-43e5-b478-d893a65af8a1","ELEMENT":"648d9733-ac0b-43e5-b478-d893a65af8a1"}]},"result":{"value":false},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"6aeac624794a1e37fa2dcdfbd1d24851","cid":"0-4","type":"result"}],"retries":0,"parent":"UserStory: Logout","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js:35:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:02:41.614Z","errors":[{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js:35:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#logout_sidebar_link\") still not clickable after 5000ms","stack":"Error: element (\"#logout_sidebar_link\") still not clickable after 5000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.logout (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:49:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js:35:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-4","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\checkout13-checkout2-logout.e2e.js","title":"UserStory: Logout","fullTitle":"UserStory: Logout","parent":"","end":"2022-02-18T02:02:41.629Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-4\\report.html"}