{"info":{"type":"runner","start":"2022-02-18T02:03:24.231Z","_duration":22653,"cid":"0-22","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"98.0.4758.82","chrome":{"chromedriverVersion":"97.0.4692.71 (adefa7837d02a07a604c1e6eff0b3a09422ab88d-refs/branch-heads/4692@{#1247})","userDataDir":"C:\\Users\\14084\\AppData\\Local\\Temp\\scoped_dir51440_1565772535"},"goog:chromeOptions":{"debuggerAddress":"localhost:52461"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a"},"sanitizedCapabilities":"chrome.98_0_4758_82.windows","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js"],"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","isMultiremote":false,"instanceOptions":{"5c7f55cc1559e09125e0c5d08c7d8d8a":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","acceptInsecureCerts":true},"logLevel":"warn","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","acceptInsecureCerts":true},"specs":["./test/specs/**/*.js"],"exclude":[],"suites":{},"baseUrl":"https://www.saucedemo.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"mocha","reporters":["spec",["allure",{"outputDir":"allure-results","disableWebdriverStepsReporting":true,"disableWebdriverScreenshotsReporting":false,"addConsoleLogs":true}],["html-nice",{"outputDir":"./docs/reports/html-reports/performance_glitch_user","filename":"report.html","reportTitle":"Sauce Demo Report for performance_glitch_user ","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":10,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[null],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":1,"retries":0,"end":"2022-02-18T02:03:46.884Z"},"metrics":{"passed":0,"skipped":0,"failed":1,"duration":22653,"start":"2022-02-18T02:03:24.233Z","end":"2022-02-18T02:03:46Z"},"title":"Sauce Demo Report for performance_glitch_user ","suites":[{"type":"suite:start","start":"2022-02-18T02:03:24.264Z","_duration":22483,"tests":[{"type":"test","start":"2022-02-18T02:03:24.266Z","_duration":22461,"uid":"test-00-0","cid":"0-22","title":"Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","fullTitle":"UserStory: Reset Cart State.Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c45da70b-9c43-431e-b32e-c35e3460a7ba"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/clear","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/clear","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/value","body":{"text":"performance_glitch_user"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c7a10904-5f17-49fe-8ee1-61af8fe89420"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/clear","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/clear","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/value","body":{"text":"secret_sauce"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c27d2b2-a56c-4fb0-82c5-c1804837c228"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7c27d2b2-a56c-4fb0-82c5-c1804837c228/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7c27d2b2-a56c-4fb0-82c5-c1804837c228/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d83eab0e-ebb0-47ca-a0bd-e927923b8d6d"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83eab0e-ebb0-47ca-a0bd-e927923b8d6d/text","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d83eab0e-ebb0-47ca-a0bd-e927923b8d6d/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"53e9fc25-fba9-44e0-bc2d-c85e99d269fb"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/53e9fc25-fba9-44e0-bc2d-c85e99d269fb/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/53e9fc25-fba9-44e0-bc2d-c85e99d269fb/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0d51aa01-ac86-4a6b-830d-b59eb3e8844a"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0d51aa01-ac86-4a6b-830d-b59eb3e8844a/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0d51aa01-ac86-4a6b-830d-b59eb3e8844a/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3bcfa9c7-a843-4954-960b-dd01c0bea768"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3bcfa9c7-a843-4954-960b-dd01c0bea768"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3bcfa9c7-a843-4954-960b-dd01c0bea768/text","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3bcfa9c7-a843-4954-960b-dd01c0bea768/text","body":{},"result":{"value":"2"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3bcfa9c7-a843-4954-960b-dd01c0bea768"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"31c02bad-7bbc-4393-94d3-0515de807a53"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/31c02bad-7bbc-4393-94d3-0515de807a53/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/31c02bad-7bbc-4393-94d3-0515de807a53/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"561cc3d4-466a-45d6-beba-eac99d6b5028"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/561cc3d4-466a-45d6-beba-eac99d6b5028/text","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/561cc3d4-466a-45d6-beba-eac99d6b5028/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"724814f0-d9e2-49f5-bf10-629fc4b6c0a7"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/724814f0-d9e2-49f5-bf10-629fc4b6c0a7/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/724814f0-d9e2-49f5-bf10-629fc4b6c0a7/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js:23:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:46.727Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js:23:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js:23:9)","type":"Error"}}],"hooks":[],"suites":[],"hooksAndTests":[{"type":"test","start":"2022-02-18T02:03:24.266Z","_duration":22461,"uid":"test-00-0","cid":"0-22","title":"Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","fullTitle":"UserStory: Reset Cart State.Reset_2: should be able to add two items to cart and zero it out by Reset App State from burger menu on the Cart Page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c45da70b-9c43-431e-b32e-c35e3460a7ba"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/clear","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/clear","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/value","body":{"text":"performance_glitch_user"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c45da70b-9c43-431e-b32e-c35e3460a7ba/value","body":{"text":"performance_glitch_user"},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"c7a10904-5f17-49fe-8ee1-61af8fe89420"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/clear","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/clear","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/value","body":{"text":"secret_sauce"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/c7a10904-5f17-49fe-8ee1-61af8fe89420/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"7c27d2b2-a56c-4fb0-82c5-c1804837c228"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/7c27d2b2-a56c-4fb0-82c5-c1804837c228/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/7c27d2b2-a56c-4fb0-82c5-c1804837c228/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/inventory.html"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d83eab0e-ebb0-47ca-a0bd-e927923b8d6d"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/d83eab0e-ebb0-47ca-a0bd-e927923b8d6d/text","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/d83eab0e-ebb0-47ca-a0bd-e927923b8d6d/text","body":{},"result":{"value":"PRODUCTS"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-backpack"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"53e9fc25-fba9-44e0-bc2d-c85e99d269fb"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/53e9fc25-fba9-44e0-bc2d-c85e99d269fb/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/53e9fc25-fba9-44e0-bc2d-c85e99d269fb/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#add-to-cart-sauce-labs-bike-light"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0d51aa01-ac86-4a6b-830d-b59eb3e8844a"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0d51aa01-ac86-4a6b-830d-b59eb3e8844a/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0d51aa01-ac86-4a6b-830d-b59eb3e8844a/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3bcfa9c7-a843-4954-960b-dd01c0bea768"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3bcfa9c7-a843-4954-960b-dd01c0bea768"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3bcfa9c7-a843-4954-960b-dd01c0bea768/text","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3bcfa9c7-a843-4954-960b-dd01c0bea768/text","body":{},"result":{"value":"2"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"css selector","value":".shopping_cart_badge"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"3bcfa9c7-a843-4954-960b-dd01c0bea768"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"31c02bad-7bbc-4393-94d3-0515de807a53"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/31c02bad-7bbc-4393-94d3-0515de807a53/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/31c02bad-7bbc-4393-94d3-0515de807a53/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://www.saucedemo.com/cart.html"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#header_container > div.header_secondary_container > span"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"561cc3d4-466a-45d6-beba-eac99d6b5028"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/561cc3d4-466a-45d6-beba-eac99d6b5028/text","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/561cc3d4-466a-45d6-beba-eac99d6b5028/text","body":{},"result":{"value":"YOUR CART"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#react-burger-menu-btn"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"724814f0-d9e2-49f5-bf10-629fc4b6c0a7"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/724814f0-d9e2-49f5-bf10-629fc4b6c0a7/click","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/724814f0-d9e2-49f5-bf10-629fc4b6c0a7/click","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#reset_sidebar_link"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof DocumentFragment) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":true},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementClickable(elem) {\n    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n        return false;\n    }\n    // Edge before switching to Chromium\n    const isOldEdge = !!window.StyleMedia;\n    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n    // get overlapping element\n    function getOverlappingElement(elem, context) {\n        context = context || document;\n        const elemDimension = elem.getBoundingClientRect();\n        const x = elemDimension.left + (elem.clientWidth / 2);\n        const y = elemDimension.top + (elem.clientHeight / 2);\n        return context.elementFromPoint(x, y);\n    }\n    // get overlapping element rects (currently only the first)\n    // applicable if element's text is multiline.\n    function getOverlappingRects(elem, context) {\n        context = context || document;\n        const elems = [];\n        const rects = elem.getClientRects();\n        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n        const rect = rects[0];\n        const x = rect.left + (rect.width / 2);\n        const y = rect.top + (rect.height / 2);\n        elems.push(context.elementFromPoint(x, y));\n        return elems;\n    }\n    // get overlapping elements\n    function getOverlappingElements(elem, context) {\n        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n    }\n    // is a node a descendant of a given node\n    function nodeContains(elem, otherNode) {\n        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n        if (isOldEdge) {\n            let tmpElement = otherNode;\n            while (tmpElement) {\n                if (tmpElement === elem) {\n                    return true;\n                }\n                tmpElement = tmpElement.parentNode;\n                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                    tmpElement = tmpElement.host;\n                }\n            }\n            return false;\n        }\n        return elem.contains(otherNode);\n    }\n    // is one of overlapping elements the `elem` or one of its child\n    function isOverlappingElementMatch(elementsFromPoint, elem) {\n        if (elementsFromPoint.some(function (elementFromPoint) {\n            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n        })) {\n            return true;\n        }\n        // shadow root\n        // filter unique elements with shadowRoot\n        // @ts-ignore\n        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n        });\n        // getOverlappingElements of every element with shadowRoot\n        let shadowElementsFromPoint = [];\n        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n            let shadowElement = elemsWithShadowRoot[i];\n            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n        }\n        // remove duplicates and parents\n        // @ts-ignore\n        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n            return !elementsFromPoint.includes(x);\n        });\n        if (shadowElementsFromPoint.length === 0) {\n            return false;\n        }\n        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n    }\n    // copied from `isElementInViewport.js`\n    function isElementInViewport(elem) {\n        if (!elem.getBoundingClientRect) {\n            return false;\n        }\n        const rect = elem.getBoundingClientRect();\n        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n        return (vertInView && horInView);\n    }\n    function isClickable(elem) {\n        return (isElementInViewport(elem) && elem.disabled !== true &&\n            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n    }\n    // scroll to the element if it's not clickable\n    if (!isClickable(elem)) {\n        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n        // if element is still not clickable take another scroll attempt\n        if (!isClickable(elem)) {\n            // scroll to element, try put it in the screen center.\n            // Should definitely work even if element was covered with sticky header/footer\n            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n            return isClickable(elem);\n        }\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"9d47a50b-b650-4929-ab7f-afb7ee68b779","ELEMENT":"9d47a50b-b650-4929-ab7f-afb7ee68b779"}]},"result":{"value":false},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"5c7f55cc1559e09125e0c5d08c7d8d8a","cid":"0-22","type":"result"}],"retries":0,"parent":"UserStory: Reset Cart State","state":"failed","events":[{"type":"Error","value":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js:23:9)","type":"Error"}}],"errorIndex":1,"end":"2022-02-18T02:03:46.727Z","errors":[{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js:23:9)","type":"Error"}],"error":{"name":"Error","message":"element (\"#reset_sidebar_link\") still not clickable after 7000ms","stack":"Error: element (\"#reset_sidebar_link\") still not clickable after 7000ms\n    at C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:66:23\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async Element.elementErrorHandlerCallbackFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n    at async Element.wrapCommandFn (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n    at async LoginPage.resetAppState (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\pageobjects\\login.page.js:66:9)\n    at async Context.<anonymous> (C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js:23:9)","type":"Error"}}],"uid":"suite-0-0","cid":"0-22","file":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\test\\specs\\reset2.e2e.js","title":"UserStory: Reset Cart State","fullTitle":"UserStory: Reset Cart State","parent":"","end":"2022-02-18T02:03:46.756Z"}],"reportFile":"C:\\pallavi\\code\\webdriverio\\webdriverio-saucedemo-testing\\docs\\reports\\html-reports\\performance_glitch_user\\suite-0-0\\0-22\\report.html"}